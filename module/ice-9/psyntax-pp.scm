(eval-when (compile) (set-current-module (resolve-module (quote (guile)))))
(void)
(letrec ((and-map*17 (lambda (f57 first56 . rest55) (or (null? first56) (if (null? rest55) (let andmap58 ((first59 first56)) (let ((x60 (car first59)) (first61 (cdr first59))) (if (null? first61) (f57 x60) (and (f57 x60) (andmap58 first61))))) (let andmap62 ((first63 first56) (rest64 rest55)) (let ((x65 (car first63)) (xr66 (map car rest64)) (first67 (cdr first63)) (rest68 (map cdr rest64))) (if (null? first67) (apply f57 (cons x65 xr66)) (and (apply f57 (cons x65 xr66)) (andmap62 first67 rest68)))))))))) (letrec ((lambda-var-list150 (lambda (vars355) (let lvl356 ((vars357 vars355) (ls358 (quote ())) (w359 (quote (())))) (cond ((pair? vars357) (lvl356 (cdr vars357) (cons (wrap129 (car vars357) w359 #f) ls358) w359)) ((id?101 vars357) (cons (wrap129 vars357 w359 #f) ls358)) ((null? vars357) ls358) ((syntax-object?85 vars357) (lvl356 (syntax-object-expression86 vars357) ls358 (join-wraps120 w359 (syntax-object-wrap87 vars357)))) ((annotation? vars357) (lvl356 (annotation-expression vars357) ls358 w359)) (else (cons vars357 ls358)))))) (gen-var149 (lambda (id360) (let ((id361 (if (syntax-object?85 id360) (syntax-object-expression86 id360) id360))) (if (annotation? id361) (build-annotated78 (annotation-source id361) (gensym (symbol->string (annotation-expression id361)))) (build-annotated78 #f (gensym (symbol->string id361))))))) (strip148 (lambda (x362 w363) (if (memq (quote top) (wrap-marks104 w363)) (if (or (annotation? x362) (and (pair? x362) (annotation? (car x362)))) (strip-annotation147 x362 #f) x362) (let f364 ((x365 x362)) (cond ((syntax-object?85 x365) (strip148 (syntax-object-expression86 x365) (syntax-object-wrap87 x365))) ((pair? x365) (let ((a366 (f364 (car x365))) (d367 (f364 (cdr x365)))) (if (and (eq? a366 (car x365)) (eq? d367 (cdr x365))) x365 (cons a366 d367)))) ((vector? x365) (let ((old368 (vector->list x365))) (let ((new369 (map f364 old368))) (if (and-map*17 eq? old368 new369) x365 (list->vector new369))))) (else x365)))))) (strip-annotation147 (lambda (x370 parent371) (cond ((pair? x370) (let ((new372 (cons #f #f))) (begin (if parent371 (set-annotation-stripped! parent371 new372)) (set-car! new372 (strip-annotation147 (car x370) #f)) (set-cdr! new372 (strip-annotation147 (cdr x370) #f)) new372))) ((annotation? x370) (or (annotation-stripped x370) (strip-annotation147 (annotation-expression x370) x370))) ((vector? x370) (let ((new373 (make-vector (vector-length x370)))) (begin (if parent371 (set-annotation-stripped! parent371 new373)) (let loop374 ((i375 (- (vector-length x370) 1))) (unless (fx<73 i375 0) (vector-set! new373 i375 (strip-annotation147 (vector-ref x370 i375) #f)) (loop374 (fx-71 i375 1)))) new373))) (else x370)))) (ellipsis?146 (lambda (x376) (and (nonsymbol-id?100 x376) (free-id=?124 x376 (quote #(syntax-object ... ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))))))) (chi-void145 (lambda () (build-annotated78 #f (list (build-annotated78 #f (quote void)))))) (eval-local-transformer144 (lambda (expanded377 mod378) (let ((p379 (local-eval-hook75 expanded377 mod378))) (if (procedure? p379) p379 (syntax-violation #f "nonprocedure transformer" p379))))) (chi-local-syntax143 (lambda (rec?380 e381 r382 w383 s384 mod385 k386) ((lambda (tmp387) ((lambda (tmp388) (if tmp388 (apply (lambda (_389 id390 val391 e1392 e2393) (let ((ids394 id390)) (if (not (valid-bound-ids?126 ids394)) (syntax-violation #f "duplicate bound keyword" e381) (let ((labels396 (gen-labels107 ids394))) (let ((new-w397 (make-binding-wrap118 ids394 labels396 w383))) (k386 (cons e1392 e2393) (extend-env95 labels396 (let ((w399 (if rec?380 new-w397 w383)) (trans-r400 (macros-only-env97 r382))) (map (lambda (x401) (cons (quote macro) (eval-local-transformer144 (chi137 x401 trans-r400 w399 mod385) mod385))) val391)) r382) new-w397 s384 mod385)))))) tmp388) ((lambda (_403) (syntax-violation #f "bad local syntax definition" (source-wrap130 e381 w383 s384 mod385))) tmp387))) ($sc-dispatch tmp387 (quote (any #(each (any any)) any . each-any))))) e381))) (chi-lambda-clause142 (lambda (e404 docstring405 c406 r407 w408 mod409 k410) ((lambda (tmp411) ((lambda (tmp412) (if (if tmp412 (apply (lambda (args413 doc414 e1415 e2416) (and (string? (syntax->datum doc414)) (not docstring405))) tmp412) #f) (apply (lambda (args417 doc418 e1419 e2420) (chi-lambda-clause142 e404 doc418 (cons args417 (cons e1419 e2420)) r407 w408 mod409 k410)) tmp412) ((lambda (tmp422) (if tmp422 (apply (lambda (id423 e1424 e2425) (let ((ids426 id423)) (if (not (valid-bound-ids?126 ids426)) (syntax-violation (quote lambda) "invalid parameter list" e404) (let ((labels428 (gen-labels107 ids426)) (new-vars429 (map gen-var149 ids426))) (k410 new-vars429 docstring405 (chi-body141 (cons e1424 e2425) e404 (extend-var-env96 labels428 new-vars429 r407) (make-binding-wrap118 ids426 labels428 w408) mod409)))))) tmp422) ((lambda (tmp431) (if tmp431 (apply (lambda (ids432 e1433 e2434) (let ((old-ids435 (lambda-var-list150 ids432))) (if (not (valid-bound-ids?126 old-ids435)) (syntax-violation (quote lambda) "invalid parameter list" e404) (let ((labels436 (gen-labels107 old-ids435)) (new-vars437 (map gen-var149 old-ids435))) (k410 (let f438 ((ls1439 (cdr new-vars437)) (ls2440 (car new-vars437))) (if (null? ls1439) ls2440 (f438 (cdr ls1439) (cons (car ls1439) ls2440)))) docstring405 (chi-body141 (cons e1433 e2434) e404 (extend-var-env96 labels436 new-vars437 r407) (make-binding-wrap118 old-ids435 labels436 w408) mod409)))))) tmp431) ((lambda (_442) (syntax-violation (quote lambda) "bad lambda" e404)) tmp411))) ($sc-dispatch tmp411 (quote (any any . each-any)))))) ($sc-dispatch tmp411 (quote (each-any any . each-any)))))) ($sc-dispatch tmp411 (quote (any any any . each-any))))) c406))) (chi-body141 (lambda (body443 outer-form444 r445 w446 mod447) (let ((r448 (cons (quote ("placeholder" placeholder)) r445))) (let ((ribcage449 (make-ribcage108 (quote ()) (quote ()) (quote ())))) (let ((w450 (make-wrap103 (wrap-marks104 w446) (cons ribcage449 (wrap-subst105 w446))))) (let parse451 ((body452 (map (lambda (x458) (cons r448 (wrap129 x458 w450 mod447))) body443)) (ids453 (quote ())) (labels454 (quote ())) (vars455 (quote ())) (vals456 (quote ())) (bindings457 (quote ()))) (if (null? body452) (syntax-violation #f "no expressions in body" outer-form444) (let ((e459 (cdar body452)) (er460 (caar body452))) (call-with-values (lambda () (syntax-type135 e459 er460 (quote (())) #f ribcage449 mod447)) (lambda (type461 value462 e463 w464 s465 mod466) (let ((t467 type461)) (if (memv t467 (quote (define-form))) (let ((id468 (wrap129 value462 w464 mod466)) (label469 (gen-label106))) (let ((var470 (gen-var149 id468))) (begin (extend-ribcage!117 ribcage449 id468 label469) (parse451 (cdr body452) (cons id468 ids453) (cons label469 labels454) (cons var470 vars455) (cons (cons er460 (wrap129 e463 w464 mod466)) vals456) (cons (cons (quote lexical) var470) bindings457))))) (if (memv t467 (quote (define-syntax-form))) (let ((id471 (wrap129 value462 w464 mod466)) (label472 (gen-label106))) (begin (extend-ribcage!117 ribcage449 id471 label472) (parse451 (cdr body452) (cons id471 ids453) (cons label472 labels454) vars455 vals456 (cons (cons (quote macro) (cons er460 (wrap129 e463 w464 mod466))) bindings457)))) (if (memv t467 (quote (begin-form))) ((lambda (tmp473) ((lambda (tmp474) (if tmp474 (apply (lambda (_475 e1476) (parse451 (let f477 ((forms478 e1476)) (if (null? forms478) (cdr body452) (cons (cons er460 (wrap129 (car forms478) w464 mod466)) (f477 (cdr forms478))))) ids453 labels454 vars455 vals456 bindings457)) tmp474) (syntax-violation #f "source expression failed to match any pattern" tmp473))) ($sc-dispatch tmp473 (quote (any . each-any))))) e463) (if (memv t467 (quote (local-syntax-form))) (chi-local-syntax143 value462 e463 er460 w464 s465 mod466 (lambda (forms480 er481 w482 s483 mod484) (parse451 (let f485 ((forms486 forms480)) (if (null? forms486) (cdr body452) (cons (cons er481 (wrap129 (car forms486) w482 mod484)) (f485 (cdr forms486))))) ids453 labels454 vars455 vals456 bindings457))) (if (null? ids453) (build-sequence80 #f (map (lambda (x487) (chi137 (cdr x487) (car x487) (quote (())) mod466)) (cons (cons er460 (source-wrap130 e463 w464 s465 mod466)) (cdr body452)))) (begin (if (not (valid-bound-ids?126 ids453)) (syntax-violation #f "invalid or duplicate identifier in definition" outer-form444)) (let loop488 ((bs489 bindings457) (er-cache490 #f) (r-cache491 #f)) (if (not (null? bs489)) (let ((b492 (car bs489))) (if (eq? (car b492) (quote macro)) (let ((er493 (cadr b492))) (let ((r-cache494 (if (eq? er493 er-cache490) r-cache491 (macros-only-env97 er493)))) (begin (set-cdr! b492 (eval-local-transformer144 (chi137 (cddr b492) r-cache494 (quote (())) mod466) mod466)) (loop488 (cdr bs489) er493 r-cache494)))) (loop488 (cdr bs489) er-cache490 r-cache491))))) (set-cdr! r448 (extend-env95 labels454 bindings457 (cdr r448))) (build-letrec83 #f vars455 (map (lambda (x495) (chi137 (cdr x495) (car x495) (quote (())) mod466)) vals456) (build-sequence80 #f (map (lambda (x496) (chi137 (cdr x496) (car x496) (quote (())) mod466)) (cons (cons er460 (source-wrap130 e463 w464 s465 mod466)) (cdr body452)))))))))))))))))))))) (chi-macro140 (lambda (p497 e498 r499 w500 rib501 mod502) (letrec ((rebuild-macro-output503 (lambda (x504 m505) (cond ((pair? x504) (cons (rebuild-macro-output503 (car x504) m505) (rebuild-macro-output503 (cdr x504) m505))) ((syntax-object?85 x504) (let ((w506 (syntax-object-wrap87 x504))) (let ((ms507 (wrap-marks104 w506)) (s508 (wrap-subst105 w506))) (if (and (pair? ms507) (eq? (car ms507) #f)) (make-syntax-object84 (syntax-object-expression86 x504) (make-wrap103 (cdr ms507) (if rib501 (cons rib501 (cdr s508)) (cdr s508))) (syntax-object-module88 x504)) (make-syntax-object84 (syntax-object-expression86 x504) (make-wrap103 (cons m505 ms507) (if rib501 (cons rib501 (cons (quote shift) s508)) (cons (quote shift) s508))) (let ((pmod509 (procedure-module p497))) (if pmod509 (cons (quote hygiene) (module-name pmod509)) (quote (hygiene guile))))))))) ((vector? x504) (let ((n510 (vector-length x504))) (let ((v511 (make-vector n510))) (let doloop512 ((i513 0)) (if (fx=72 i513 n510) v511 (begin (vector-set! v511 i513 (rebuild-macro-output503 (vector-ref x504 i513) m505)) (doloop512 (fx+70 i513 1)))))))) ((symbol? x504) (syntax-violation #f "encountered raw symbol in macro output" (source-wrap130 e498 w500 s mod502) x504)) (else x504))))) (rebuild-macro-output503 (p497 (wrap129 e498 (anti-mark116 w500) mod502)) (string #\m))))) (chi-application139 (lambda (x514 e515 r516 w517 s518 mod519) ((lambda (tmp520) ((lambda (tmp521) (if tmp521 (apply (lambda (e0522 e1523) (build-annotated78 s518 (cons x514 (map (lambda (e524) (chi137 e524 r516 w517 mod519)) e1523)))) tmp521) (syntax-violation #f "source expression failed to match any pattern" tmp520))) ($sc-dispatch tmp520 (quote (any . each-any))))) e515))) (chi-expr138 (lambda (type526 value527 e528 r529 w530 s531 mod532) (let ((t533 type526)) (if (memv t533 (quote (lexical))) (build-annotated78 s531 value527) (if (memv t533 (quote (core external-macro))) (value527 e528 r529 w530 s531 mod532) (if (memv t533 (quote (module-ref))) (call-with-values (lambda () (value527 e528)) (lambda (id534 mod535) (build-annotated78 s531 (if mod535 (make-module-ref (cdr mod535) id534 (car mod535)) (make-module-ref mod535 id534 (quote bare)))))) (if (memv t533 (quote (lexical-call))) (chi-application139 (build-annotated78 (source-annotation92 (car e528)) value527) e528 r529 w530 s531 mod532) (if (memv t533 (quote (global-call))) (chi-application139 (build-annotated78 (source-annotation92 (car e528)) (if (if (syntax-object?85 (car e528)) (syntax-object-module88 (car e528)) mod532) (make-module-ref (cdr (if (syntax-object?85 (car e528)) (syntax-object-module88 (car e528)) mod532)) value527 (car (if (syntax-object?85 (car e528)) (syntax-object-module88 (car e528)) mod532))) (make-module-ref (if (syntax-object?85 (car e528)) (syntax-object-module88 (car e528)) mod532) value527 (quote bare)))) e528 r529 w530 s531 mod532) (if (memv t533 (quote (constant))) (build-data79 s531 (strip148 (source-wrap130 e528 w530 s531 mod532) (quote (())))) (if (memv t533 (quote (global))) (build-annotated78 s531 (if mod532 (make-module-ref (cdr mod532) value527 (car mod532)) (make-module-ref mod532 value527 (quote bare)))) (if (memv t533 (quote (call))) (chi-application139 (chi137 (car e528) r529 w530 mod532) e528 r529 w530 s531 mod532) (if (memv t533 (quote (begin-form))) ((lambda (tmp536) ((lambda (tmp537) (if tmp537 (apply (lambda (_538 e1539 e2540) (chi-sequence131 (cons e1539 e2540) r529 w530 s531 mod532)) tmp537) (syntax-violation #f "source expression failed to match any pattern" tmp536))) ($sc-dispatch tmp536 (quote (any any . each-any))))) e528) (if (memv t533 (quote (local-syntax-form))) (chi-local-syntax143 value527 e528 r529 w530 s531 mod532 chi-sequence131) (if (memv t533 (quote (eval-when-form))) ((lambda (tmp542) ((lambda (tmp543) (if tmp543 (apply (lambda (_544 x545 e1546 e2547) (let ((when-list548 (chi-when-list134 e528 x545 w530))) (if (memq (quote eval) when-list548) (chi-sequence131 (cons e1546 e2547) r529 w530 s531 mod532) (chi-void145)))) tmp543) (syntax-violation #f "source expression failed to match any pattern" tmp542))) ($sc-dispatch tmp542 (quote (any each-any any . each-any))))) e528) (if (memv t533 (quote (define-form define-syntax-form))) (syntax-violation #f "definition in expression context" e528 (wrap129 value527 w530 mod532)) (if (memv t533 (quote (syntax))) (syntax-violation #f "reference to pattern variable outside syntax form" (source-wrap130 e528 w530 s531 mod532)) (if (memv t533 (quote (displaced-lexical))) (syntax-violation #f "reference to identifier outside its scope" (source-wrap130 e528 w530 s531 mod532)) (syntax-violation #f "unexpected syntax" (source-wrap130 e528 w530 s531 mod532))))))))))))))))))) (chi137 (lambda (e551 r552 w553 mod554) (call-with-values (lambda () (syntax-type135 e551 r552 w553 #f #f mod554)) (lambda (type555 value556 e557 w558 s559 mod560) (chi-expr138 type555 value556 e557 r552 w558 s559 mod560))))) (chi-top136 (lambda (e561 r562 w563 m564 esew565 mod566) (call-with-values (lambda () (syntax-type135 e561 r562 w563 #f #f mod566)) (lambda (type574 value575 e576 w577 s578 mod579) (let ((t580 type574)) (if (memv t580 (quote (begin-form))) ((lambda (tmp581) ((lambda (tmp582) (if tmp582 (apply (lambda (_583) (chi-void145)) tmp582) ((lambda (tmp584) (if tmp584 (apply (lambda (_585 e1586 e2587) (chi-top-sequence132 (cons e1586 e2587) r562 w577 s578 m564 esew565 mod579)) tmp584) (syntax-violation #f "source expression failed to match any pattern" tmp581))) ($sc-dispatch tmp581 (quote (any any . each-any)))))) ($sc-dispatch tmp581 (quote (any))))) e576) (if (memv t580 (quote (local-syntax-form))) (chi-local-syntax143 value575 e576 r562 w577 s578 mod579 (lambda (body589 r590 w591 s592 mod593) (chi-top-sequence132 body589 r590 w591 s592 m564 esew565 mod593))) (if (memv t580 (quote (eval-when-form))) ((lambda (tmp594) ((lambda (tmp595) (if tmp595 (apply (lambda (_596 x597 e1598 e2599) (let ((when-list600 (chi-when-list134 e576 x597 w577)) (body601 (cons e1598 e2599))) (cond ((eq? m564 (quote e)) (if (memq (quote eval) when-list600) (chi-top-sequence132 body601 r562 w577 s578 (quote e) (quote (eval)) mod579) (chi-void145))) ((memq (quote load) when-list600) (if (or (memq (quote compile) when-list600) (and (eq? m564 (quote c&e)) (memq (quote eval) when-list600))) (chi-top-sequence132 body601 r562 w577 s578 (quote c&e) (quote (compile load)) mod579) (if (memq m564 (quote (c c&e))) (chi-top-sequence132 body601 r562 w577 s578 (quote c) (quote (load)) mod579) (chi-void145)))) ((or (memq (quote compile) when-list600) (and (eq? m564 (quote c&e)) (memq (quote eval) when-list600))) (top-level-eval-hook74 (chi-top-sequence132 body601 r562 w577 s578 (quote e) (quote (eval)) mod579) mod579) (chi-void145)) (else (chi-void145))))) tmp595) (syntax-violation #f "source expression failed to match any pattern" tmp594))) ($sc-dispatch tmp594 (quote (any each-any any . each-any))))) e576) (if (memv t580 (quote (define-syntax-form))) (let ((n604 (id-var-name123 value575 w577)) (r605 (macros-only-env97 r562))) (let ((t606 m564)) (if (memv t606 (quote (c))) (if (memq (quote compile) esew565) (let ((e607 (chi-install-global133 n604 (chi137 e576 r605 w577 mod579)))) (begin (top-level-eval-hook74 e607 mod579) (if (memq (quote load) esew565) e607 (chi-void145)))) (if (memq (quote load) esew565) (chi-install-global133 n604 (chi137 e576 r605 w577 mod579)) (chi-void145))) (if (memv t606 (quote (c&e))) (let ((e608 (chi-install-global133 n604 (chi137 e576 r605 w577 mod579)))) (begin (top-level-eval-hook74 e608 mod579) e608)) (begin (if (memq (quote eval) esew565) (top-level-eval-hook74 (chi-install-global133 n604 (chi137 e576 r605 w577 mod579)) mod579)) (chi-void145)))))) (if (memv t580 (quote (define-form))) (let ((n609 (id-var-name123 value575 w577))) (let ((type610 (binding-type93 (lookup98 n609 r562 mod579)))) (let ((t611 type610)) (if (memv t611 (quote (global core macro module-ref))) (let ((x612 (build-annotated78 s578 (list (quote define) n609 (chi137 e576 r562 w577 mod579))))) (begin (if (eq? m564 (quote c&e)) (top-level-eval-hook74 x612 mod579)) x612)) (if (memv t611 (quote (displaced-lexical))) (syntax-violation #f "identifier out of context" e576 (wrap129 value575 w577 mod579)) (syntax-violation #f "cannot define keyword at top level" e576 (wrap129 value575 w577 mod579))))))) (let ((x613 (chi-expr138 type574 value575 e576 r562 w577 s578 mod579))) (begin (if (eq? m564 (quote c&e)) (top-level-eval-hook74 x613 mod579)) x613)))))))))))) (syntax-type135 (lambda (e614 r615 w616 s617 rib618 mod619) (cond ((symbol? e614) (let ((n620 (id-var-name123 e614 w616))) (let ((b621 (lookup98 n620 r615 mod619))) (let ((type622 (binding-type93 b621))) (let ((t623 type622)) (if (memv t623 (quote (lexical))) (values type622 (binding-value94 b621) e614 w616 s617 mod619) (if (memv t623 (quote (global))) (values type622 n620 e614 w616 s617 mod619) (if (memv t623 (quote (macro))) (syntax-type135 (chi-macro140 (binding-value94 b621) e614 r615 w616 rib618 mod619) r615 (quote (())) s617 rib618 mod619) (values type622 (binding-value94 b621) e614 w616 s617 mod619))))))))) ((pair? e614) (let ((first624 (car e614))) (if (id?101 first624) (let ((n625 (id-var-name123 first624 w616))) (let ((b626 (lookup98 n625 r615 (or (and (syntax-object?85 first624) (syntax-object-module88 first624)) mod619)))) (let ((type627 (binding-type93 b626))) (let ((t628 type627)) (if (memv t628 (quote (lexical))) (values (quote lexical-call) (binding-value94 b626) e614 w616 s617 mod619) (if (memv t628 (quote (global))) (values (quote global-call) n625 e614 w616 s617 mod619) (if (memv t628 (quote (macro))) (syntax-type135 (chi-macro140 (binding-value94 b626) e614 r615 w616 rib618 mod619) r615 (quote (())) s617 rib618 mod619) (if (memv t628 (quote (core external-macro module-ref))) (values type627 (binding-value94 b626) e614 w616 s617 mod619) (if (memv t628 (quote (local-syntax))) (values (quote local-syntax-form) (binding-value94 b626) e614 w616 s617 mod619) (if (memv t628 (quote (begin))) (values (quote begin-form) #f e614 w616 s617 mod619) (if (memv t628 (quote (eval-when))) (values (quote eval-when-form) #f e614 w616 s617 mod619) (if (memv t628 (quote (define))) ((lambda (tmp629) ((lambda (tmp630) (if (if tmp630 (apply (lambda (_631 name632 val633) (id?101 name632)) tmp630) #f) (apply (lambda (_634 name635 val636) (values (quote define-form) name635 val636 w616 s617 mod619)) tmp630) ((lambda (tmp637) (if (if tmp637 (apply (lambda (_638 name639 args640 e1641 e2642) (and (id?101 name639) (valid-bound-ids?126 (lambda-var-list150 args640)))) tmp637) #f) (apply (lambda (_643 name644 args645 e1646 e2647) (values (quote define-form) (wrap129 name644 w616 mod619) (cons (quote #(syntax-object lambda ((top) #(ribcage #(_ name args e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) (wrap129 (cons args645 (cons e1646 e2647)) w616 mod619)) (quote (())) s617 mod619)) tmp637) ((lambda (tmp649) (if (if tmp649 (apply (lambda (_650 name651) (id?101 name651)) tmp649) #f) (apply (lambda (_652 name653) (values (quote define-form) (wrap129 name653 w616 mod619) (quote (#(syntax-object void ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote (())) s617 mod619)) tmp649) (syntax-violation #f "source expression failed to match any pattern" tmp629))) ($sc-dispatch tmp629 (quote (any any)))))) ($sc-dispatch tmp629 (quote (any (any . any) any . each-any)))))) ($sc-dispatch tmp629 (quote (any any any))))) e614) (if (memv t628 (quote (define-syntax))) ((lambda (tmp654) ((lambda (tmp655) (if (if tmp655 (apply (lambda (_656 name657 val658) (id?101 name657)) tmp655) #f) (apply (lambda (_659 name660 val661) (values (quote define-syntax-form) name660 val661 w616 s617 mod619)) tmp655) (syntax-violation #f "source expression failed to match any pattern" tmp654))) ($sc-dispatch tmp654 (quote (any any any))))) e614) (values (quote call) #f e614 w616 s617 mod619)))))))))))))) (values (quote call) #f e614 w616 s617 mod619)))) ((syntax-object?85 e614) (syntax-type135 (syntax-object-expression86 e614) r615 (join-wraps120 w616 (syntax-object-wrap87 e614)) #f rib618 (or (syntax-object-module88 e614) mod619))) ((annotation? e614) (syntax-type135 (annotation-expression e614) r615 w616 (annotation-source e614) rib618 mod619)) ((self-evaluating? e614) (values (quote constant) #f e614 w616 s617 mod619)) (else (values (quote other) #f e614 w616 s617 mod619))))) (chi-when-list134 (lambda (e662 when-list663 w664) (let f665 ((when-list666 when-list663) (situations667 (quote ()))) (if (null? when-list666) situations667 (f665 (cdr when-list666) (cons (let ((x668 (car when-list666))) (cond ((free-id=?124 x668 (quote #(syntax-object compile ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote compile)) ((free-id=?124 x668 (quote #(syntax-object load ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote load)) ((free-id=?124 x668 (quote #(syntax-object eval ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote eval)) (else (syntax-violation (quote eval-when) "invalid situation" e662 (wrap129 x668 w664 #f))))) situations667)))))) (chi-install-global133 (lambda (name669 e670) (build-annotated78 #f (list (build-annotated78 #f (quote define)) name669 (if (let ((v671 (module-variable (current-module) name669))) (and v671 (variable-bound? v671) (macro? (variable-ref v671)) (not (eq? (macro-type (variable-ref v671)) (quote syncase-macro))))) (build-annotated78 #f (list (build-annotated78 #f (quote make-extended-syncase-macro)) (build-annotated78 #f (list (build-annotated78 #f (quote module-ref)) (build-annotated78 #f (quote (current-module))) (build-data79 #f name669))) (build-data79 #f (quote macro)) e670)) (build-annotated78 #f (list (build-annotated78 #f (quote make-syncase-macro)) (build-data79 #f (quote macro)) e670))))))) (chi-top-sequence132 (lambda (body672 r673 w674 s675 m676 esew677 mod678) (build-sequence80 s675 (let dobody679 ((body680 body672) (r681 r673) (w682 w674) (m683 m676) (esew684 esew677) (mod685 mod678)) (if (null? body680) (quote ()) (let ((first686 (chi-top136 (car body680) r681 w682 m683 esew684 mod685))) (cons first686 (dobody679 (cdr body680) r681 w682 m683 esew684 mod685)))))))) (chi-sequence131 (lambda (body687 r688 w689 s690 mod691) (build-sequence80 s690 (let dobody692 ((body693 body687) (r694 r688) (w695 w689) (mod696 mod691)) (if (null? body693) (quote ()) (let ((first697 (chi137 (car body693) r694 w695 mod696))) (cons first697 (dobody692 (cdr body693) r694 w695 mod696)))))))) (source-wrap130 (lambda (x698 w699 s700 defmod701) (wrap129 (if s700 (make-annotation x698 s700 #f) x698) w699 defmod701))) (wrap129 (lambda (x702 w703 defmod704) (cond ((and (null? (wrap-marks104 w703)) (null? (wrap-subst105 w703))) x702) ((syntax-object?85 x702) (make-syntax-object84 (syntax-object-expression86 x702) (join-wraps120 w703 (syntax-object-wrap87 x702)) (syntax-object-module88 x702))) ((null? x702) x702) (else (make-syntax-object84 x702 w703 defmod704))))) (bound-id-member?128 (lambda (x705 list706) (and (not (null? list706)) (or (bound-id=?125 x705 (car list706)) (bound-id-member?128 x705 (cdr list706)))))) (distinct-bound-ids?127 (lambda (ids707) (let distinct?708 ((ids709 ids707)) (or (null? ids709) (and (not (bound-id-member?128 (car ids709) (cdr ids709))) (distinct?708 (cdr ids709))))))) (valid-bound-ids?126 (lambda (ids710) (and (let all-ids?711 ((ids712 ids710)) (or (null? ids712) (and (id?101 (car ids712)) (all-ids?711 (cdr ids712))))) (distinct-bound-ids?127 ids710)))) (bound-id=?125 (lambda (i713 j714) (if (and (syntax-object?85 i713) (syntax-object?85 j714)) (and (eq? (let ((e715 (syntax-object-expression86 i713))) (if (annotation? e715) (annotation-expression e715) e715)) (let ((e716 (syntax-object-expression86 j714))) (if (annotation? e716) (annotation-expression e716) e716))) (same-marks?122 (wrap-marks104 (syntax-object-wrap87 i713)) (wrap-marks104 (syntax-object-wrap87 j714)))) (eq? (let ((e717 i713)) (if (annotation? e717) (annotation-expression e717) e717)) (let ((e718 j714)) (if (annotation? e718) (annotation-expression e718) e718)))))) (free-id=?124 (lambda (i719 j720) (and (eq? (let ((x721 i719)) (let ((e722 (if (syntax-object?85 x721) (syntax-object-expression86 x721) x721))) (if (annotation? e722) (annotation-expression e722) e722))) (let ((x723 j720)) (let ((e724 (if (syntax-object?85 x723) (syntax-object-expression86 x723) x723))) (if (annotation? e724) (annotation-expression e724) e724)))) (eq? (id-var-name123 i719 (quote (()))) (id-var-name123 j720 (quote (()))))))) (id-var-name123 (lambda (id725 w726) (letrec ((search-vector-rib729 (lambda (sym735 subst736 marks737 symnames738 ribcage739) (let ((n740 (vector-length symnames738))) (let f741 ((i742 0)) (cond ((fx=72 i742 n740) (search727 sym735 (cdr subst736) marks737)) ((and (eq? (vector-ref symnames738 i742) sym735) (same-marks?122 marks737 (vector-ref (ribcage-marks111 ribcage739) i742))) (values (vector-ref (ribcage-labels112 ribcage739) i742) marks737)) (else (f741 (fx+70 i742 1)))))))) (search-list-rib728 (lambda (sym743 subst744 marks745 symnames746 ribcage747) (let f748 ((symnames749 symnames746) (i750 0)) (cond ((null? symnames749) (search727 sym743 (cdr subst744) marks745)) ((and (eq? (car symnames749) sym743) (same-marks?122 marks745 (list-ref (ribcage-marks111 ribcage747) i750))) (values (list-ref (ribcage-labels112 ribcage747) i750) marks745)) (else (f748 (cdr symnames749) (fx+70 i750 1))))))) (search727 (lambda (sym751 subst752 marks753) (if (null? subst752) (values #f marks753) (let ((fst754 (car subst752))) (if (eq? fst754 (quote shift)) (search727 sym751 (cdr subst752) (cdr marks753)) (let ((symnames755 (ribcage-symnames110 fst754))) (if (vector? symnames755) (search-vector-rib729 sym751 subst752 marks753 symnames755 fst754) (search-list-rib728 sym751 subst752 marks753 symnames755 fst754))))))))) (cond ((symbol? id725) (or (call-with-values (lambda () (search727 id725 (wrap-subst105 w726) (wrap-marks104 w726))) (lambda (x757 . ignore756) x757)) id725)) ((syntax-object?85 id725) (let ((id758 (let ((e760 (syntax-object-expression86 id725))) (if (annotation? e760) (annotation-expression e760) e760))) (w1759 (syntax-object-wrap87 id725))) (let ((marks761 (join-marks121 (wrap-marks104 w726) (wrap-marks104 w1759)))) (call-with-values (lambda () (search727 id758 (wrap-subst105 w726) marks761)) (lambda (new-id762 marks763) (or new-id762 (call-with-values (lambda () (search727 id758 (wrap-subst105 w1759) marks763)) (lambda (x765 . ignore764) x765)) id758)))))) ((annotation? id725) (let ((id766 (let ((e767 id725)) (if (annotation? e767) (annotation-expression e767) e767)))) (or (call-with-values (lambda () (search727 id766 (wrap-subst105 w726) (wrap-marks104 w726))) (lambda (x769 . ignore768) x769)) id766))) (else (syntax-violation (quote id-var-name) "invalid id" id725)))))) (same-marks?122 (lambda (x770 y771) (or (eq? x770 y771) (and (not (null? x770)) (not (null? y771)) (eq? (car x770) (car y771)) (same-marks?122 (cdr x770) (cdr y771)))))) (join-marks121 (lambda (m1772 m2773) (smart-append119 m1772 m2773))) (join-wraps120 (lambda (w1774 w2775) (let ((m1776 (wrap-marks104 w1774)) (s1777 (wrap-subst105 w1774))) (if (null? m1776) (if (null? s1777) w2775 (make-wrap103 (wrap-marks104 w2775) (smart-append119 s1777 (wrap-subst105 w2775)))) (make-wrap103 (smart-append119 m1776 (wrap-marks104 w2775)) (smart-append119 s1777 (wrap-subst105 w2775))))))) (smart-append119 (lambda (m1778 m2779) (if (null? m2779) m1778 (append m1778 m2779)))) (make-binding-wrap118 (lambda (ids780 labels781 w782) (if (null? ids780) w782 (make-wrap103 (wrap-marks104 w782) (cons (let ((labelvec783 (list->vector labels781))) (let ((n784 (vector-length labelvec783))) (let ((symnamevec785 (make-vector n784)) (marksvec786 (make-vector n784))) (begin (let f787 ((ids788 ids780) (i789 0)) (if (not (null? ids788)) (call-with-values (lambda () (id-sym-name&marks102 (car ids788) w782)) (lambda (symname790 marks791) (begin (vector-set! symnamevec785 i789 symname790) (vector-set! marksvec786 i789 marks791) (f787 (cdr ids788) (fx+70 i789 1))))))) (make-ribcage108 symnamevec785 marksvec786 labelvec783))))) (wrap-subst105 w782)))))) (extend-ribcage!117 (lambda (ribcage792 id793 label794) (begin (set-ribcage-symnames!113 ribcage792 (cons (let ((e795 (syntax-object-expression86 id793))) (if (annotation? e795) (annotation-expression e795) e795)) (ribcage-symnames110 ribcage792))) (set-ribcage-marks!114 ribcage792 (cons (wrap-marks104 (syntax-object-wrap87 id793)) (ribcage-marks111 ribcage792))) (set-ribcage-labels!115 ribcage792 (cons label794 (ribcage-labels112 ribcage792)))))) (anti-mark116 (lambda (w796) (make-wrap103 (cons #f (wrap-marks104 w796)) (cons (quote shift) (wrap-subst105 w796))))) (set-ribcage-labels!115 (lambda (x797 update798) (vector-set! x797 3 update798))) (set-ribcage-marks!114 (lambda (x799 update800) (vector-set! x799 2 update800))) (set-ribcage-symnames!113 (lambda (x801 update802) (vector-set! x801 1 update802))) (ribcage-labels112 (lambda (x803) (vector-ref x803 3))) (ribcage-marks111 (lambda (x804) (vector-ref x804 2))) (ribcage-symnames110 (lambda (x805) (vector-ref x805 1))) (ribcage?109 (lambda (x806) (and (vector? x806) (= (vector-length x806) 4) (eq? (vector-ref x806 0) (quote ribcage))))) (make-ribcage108 (lambda (symnames807 marks808 labels809) (vector (quote ribcage) symnames807 marks808 labels809))) (gen-labels107 (lambda (ls810) (if (null? ls810) (quote ()) (cons (gen-label106) (gen-labels107 (cdr ls810)))))) (gen-label106 (lambda () (string #\i))) (wrap-subst105 cdr) (wrap-marks104 car) (make-wrap103 cons) (id-sym-name&marks102 (lambda (x811 w812) (if (syntax-object?85 x811) (values (let ((e813 (syntax-object-expression86 x811))) (if (annotation? e813) (annotation-expression e813) e813)) (join-marks121 (wrap-marks104 w812) (wrap-marks104 (syntax-object-wrap87 x811)))) (values (let ((e814 x811)) (if (annotation? e814) (annotation-expression e814) e814)) (wrap-marks104 w812))))) (id?101 (lambda (x815) (cond ((symbol? x815) #t) ((syntax-object?85 x815) (symbol? (let ((e816 (syntax-object-expression86 x815))) (if (annotation? e816) (annotation-expression e816) e816)))) ((annotation? x815) (symbol? (annotation-expression x815))) (else #f)))) (nonsymbol-id?100 (lambda (x817) (and (syntax-object?85 x817) (symbol? (let ((e818 (syntax-object-expression86 x817))) (if (annotation? e818) (annotation-expression e818) e818)))))) (global-extend99 (lambda (type819 sym820 val821) (put-global-definition-hook76 sym820 type819 val821))) (lookup98 (lambda (x822 r823 mod824) (cond ((assq x822 r823) => cdr) ((symbol? x822) (or (get-global-definition-hook77 x822 mod824) (quote (global)))) (else (quote (displaced-lexical)))))) (macros-only-env97 (lambda (r825) (if (null? r825) (quote ()) (let ((a826 (car r825))) (if (eq? (cadr a826) (quote macro)) (cons a826 (macros-only-env97 (cdr r825))) (macros-only-env97 (cdr r825))))))) (extend-var-env96 (lambda (labels827 vars828 r829) (if (null? labels827) r829 (extend-var-env96 (cdr labels827) (cdr vars828) (cons (cons (car labels827) (cons (quote lexical) (car vars828))) r829))))) (extend-env95 (lambda (labels830 bindings831 r832) (if (null? labels830) r832 (extend-env95 (cdr labels830) (cdr bindings831) (cons (cons (car labels830) (car bindings831)) r832))))) (binding-value94 cdr) (binding-type93 car) (source-annotation92 (lambda (x833) (cond ((annotation? x833) (annotation-source x833)) ((syntax-object?85 x833) (source-annotation92 (syntax-object-expression86 x833))) (else #f)))) (set-syntax-object-module!91 (lambda (x834 update835) (vector-set! x834 3 update835))) (set-syntax-object-wrap!90 (lambda (x836 update837) (vector-set! x836 2 update837))) (set-syntax-object-expression!89 (lambda (x838 update839) (vector-set! x838 1 update839))) (syntax-object-module88 (lambda (x840) (vector-ref x840 3))) (syntax-object-wrap87 (lambda (x841) (vector-ref x841 2))) (syntax-object-expression86 (lambda (x842) (vector-ref x842 1))) (syntax-object?85 (lambda (x843) (and (vector? x843) (= (vector-length x843) 4) (eq? (vector-ref x843 0) (quote syntax-object))))) (make-syntax-object84 (lambda (expression844 wrap845 module846) (vector (quote syntax-object) expression844 wrap845 module846))) (build-letrec83 (lambda (src847 vars848 val-exps849 body-exp850) (if (null? vars848) (build-annotated78 src847 body-exp850) (build-annotated78 src847 (list (quote letrec) (map list vars848 val-exps849) body-exp850))))) (build-named-let82 (lambda (src851 vars852 val-exps853 body-exp854) (if (null? vars852) (build-annotated78 src851 body-exp854) (build-annotated78 src851 (list (quote let) (car vars852) (map list (cdr vars852) val-exps853) body-exp854))))) (build-let81 (lambda (src855 vars856 val-exps857 body-exp858) (if (null? vars856) (build-annotated78 src855 body-exp858) (build-annotated78 src855 (list (quote let) (map list vars856 val-exps857) body-exp858))))) (build-sequence80 (lambda (src859 exps860) (if (null? (cdr exps860)) (build-annotated78 src859 (car exps860)) (build-annotated78 src859 (cons (quote begin) exps860))))) (build-data79 (lambda (src861 exp862) (if (and (self-evaluating? exp862) (not (vector? exp862))) (build-annotated78 src861 exp862) (build-annotated78 src861 (list (quote quote) exp862))))) (build-annotated78 (lambda (src863 exp864) (if (and src863 (not (annotation? exp864))) (make-annotation exp864 src863 #t) exp864))) (get-global-definition-hook77 (lambda (symbol865 module866) (begin (if (and (not module866) (current-module)) (warn "module system is booted, we should have a module" symbol865)) (let ((v867 (module-variable (if module866 (resolve-module (cdr module866)) (current-module)) symbol865))) (and v867 (variable-bound? v867) (let ((val868 (variable-ref v867))) (and (macro? val868) (syncase-macro-type val868) (cons (syncase-macro-type val868) (syncase-macro-binding val868))))))))) (put-global-definition-hook76 (lambda (symbol869 type870 val871) (let ((existing872 (let ((v873 (module-variable (current-module) symbol869))) (and v873 (variable-bound? v873) (let ((val874 (variable-ref v873))) (and (macro? val874) (not (syncase-macro-type val874)) val874)))))) (module-define! (current-module) symbol869 (if existing872 (make-extended-syncase-macro existing872 type870 val871) (make-syncase-macro type870 val871)))))) (local-eval-hook75 (lambda (x875 mod876) (primitive-eval (list noexpand69 x875)))) (top-level-eval-hook74 (lambda (x877 mod878) (primitive-eval (list noexpand69 x877)))) (fx<73 <) (fx=72 =) (fx-71 -) (fx+70 +) (noexpand69 "noexpand")) (begin (global-extend99 (quote local-syntax) (quote letrec-syntax) #t) (global-extend99 (quote local-syntax) (quote let-syntax) #f) (global-extend99 (quote core) (quote fluid-let-syntax) (lambda (e879 r880 w881 s882 mod883) ((lambda (tmp884) ((lambda (tmp885) (if (if tmp885 (apply (lambda (_886 var887 val888 e1889 e2890) (valid-bound-ids?126 var887)) tmp885) #f) (apply (lambda (_892 var893 val894 e1895 e2896) (let ((names897 (map (lambda (x898) (id-var-name123 x898 w881)) var893))) (begin (for-each (lambda (id900 n901) (let ((t902 (binding-type93 (lookup98 n901 r880 mod883)))) (if (memv t902 (quote (displaced-lexical))) (syntax-violation (quote fluid-let-syntax) "identifier out of context" e879 (source-wrap130 id900 w881 s882 mod883))))) var893 names897) (chi-body141 (cons e1895 e2896) (source-wrap130 e879 w881 s882 mod883) (extend-env95 names897 (let ((trans-r905 (macros-only-env97 r880))) (map (lambda (x906) (cons (quote macro) (eval-local-transformer144 (chi137 x906 trans-r905 w881 mod883) mod883))) val894)) r880) w881 mod883)))) tmp885) ((lambda (_908) (syntax-violation (quote fluid-let-syntax) "bad syntax" (source-wrap130 e879 w881 s882 mod883))) tmp884))) ($sc-dispatch tmp884 (quote (any #(each (any any)) any . each-any))))) e879))) (global-extend99 (quote core) (quote quote) (lambda (e909 r910 w911 s912 mod913) ((lambda (tmp914) ((lambda (tmp915) (if tmp915 (apply (lambda (_916 e917) (build-data79 s912 (strip148 e917 w911))) tmp915) ((lambda (_918) (syntax-violation (quote quote) "bad syntax" (source-wrap130 e909 w911 s912 mod913))) tmp914))) ($sc-dispatch tmp914 (quote (any any))))) e909))) (global-extend99 (quote core) (quote syntax) (letrec ((regen926 (lambda (x927) (let ((t928 (car x927))) (if (memv t928 (quote (ref))) (build-annotated78 #f (cadr x927)) (if (memv t928 (quote (primitive))) (build-annotated78 #f (cadr x927)) (if (memv t928 (quote (quote))) (build-data79 #f (cadr x927)) (if (memv t928 (quote (lambda))) (build-annotated78 #f (list (quote lambda) (cadr x927) (regen926 (caddr x927)))) (if (memv t928 (quote (map))) (let ((ls929 (map regen926 (cdr x927)))) (build-annotated78 #f (cons (if (fx=72 (length ls929) 2) (build-annotated78 #f (quote map)) (build-annotated78 #f (quote map))) ls929))) (build-annotated78 #f (cons (build-annotated78 #f (car x927)) (map regen926 (cdr x927)))))))))))) (gen-vector925 (lambda (x930) (cond ((eq? (car x930) (quote list)) (cons (quote vector) (cdr x930))) ((eq? (car x930) (quote quote)) (list (quote quote) (list->vector (cadr x930)))) (else (list (quote list->vector) x930))))) (gen-append924 (lambda (x931 y932) (if (equal? y932 (quote (quote ()))) x931 (list (quote append) x931 y932)))) (gen-cons923 (lambda (x933 y934) (let ((t935 (car y934))) (if (memv t935 (quote (quote))) (if (eq? (car x933) (quote quote)) (list (quote quote) (cons (cadr x933) (cadr y934))) (if (eq? (cadr y934) (quote ())) (list (quote list) x933) (list (quote cons) x933 y934))) (if (memv t935 (quote (list))) (cons (quote list) (cons x933 (cdr y934))) (list (quote cons) x933 y934)))))) (gen-map922 (lambda (e936 map-env937) (let ((formals938 (map cdr map-env937)) (actuals939 (map (lambda (x940) (list (quote ref) (car x940))) map-env937))) (cond ((eq? (car e936) (quote ref)) (car actuals939)) ((and-map (lambda (x941) (and (eq? (car x941) (quote ref)) (memq (cadr x941) formals938))) (cdr e936)) (cons (quote map) (cons (list (quote primitive) (car e936)) (map (let ((r942 (map cons formals938 actuals939))) (lambda (x943) (cdr (assq (cadr x943) r942)))) (cdr e936))))) (else (cons (quote map) (cons (list (quote lambda) formals938 e936) actuals939))))))) (gen-mappend921 (lambda (e944 map-env945) (list (quote apply) (quote (primitive append)) (gen-map922 e944 map-env945)))) (gen-ref920 (lambda (src946 var947 level948 maps949) (if (fx=72 level948 0) (values var947 maps949) (if (null? maps949) (syntax-violation (quote syntax) "missing ellipsis" src946) (call-with-values (lambda () (gen-ref920 src946 var947 (fx-71 level948 1) (cdr maps949))) (lambda (outer-var950 outer-maps951) (let ((b952 (assq outer-var950 (car maps949)))) (if b952 (values (cdr b952) maps949) (let ((inner-var953 (gen-var149 (quote tmp)))) (values inner-var953 (cons (cons (cons outer-var950 inner-var953) (car maps949)) outer-maps951))))))))))) (gen-syntax919 (lambda (src954 e955 r956 maps957 ellipsis?958 mod959) (if (id?101 e955) (let ((label960 (id-var-name123 e955 (quote (()))))) (let ((b961 (lookup98 label960 r956 mod959))) (if (eq? (binding-type93 b961) (quote syntax)) (call-with-values (lambda () (let ((var.lev962 (binding-value94 b961))) (gen-ref920 src954 (car var.lev962) (cdr var.lev962) maps957))) (lambda (var963 maps964) (values (list (quote ref) var963) maps964))) (if (ellipsis?958 e955) (syntax-violation (quote syntax) "misplaced ellipsis" src954) (values (list (quote quote) e955) maps957))))) ((lambda (tmp965) ((lambda (tmp966) (if (if tmp966 (apply (lambda (dots967 e968) (ellipsis?958 dots967)) tmp966) #f) (apply (lambda (dots969 e970) (gen-syntax919 src954 e970 r956 maps957 (lambda (x971) #f) mod959)) tmp966) ((lambda (tmp972) (if (if tmp972 (apply (lambda (x973 dots974 y975) (ellipsis?958 dots974)) tmp972) #f) (apply (lambda (x976 dots977 y978) (let f979 ((y980 y978) (k981 (lambda (maps982) (call-with-values (lambda () (gen-syntax919 src954 x976 r956 (cons (quote ()) maps982) ellipsis?958 mod959)) (lambda (x983 maps984) (if (null? (car maps984)) (syntax-violation (quote syntax) "extra ellipsis" src954) (values (gen-map922 x983 (car maps984)) (cdr maps984)))))))) ((lambda (tmp985) ((lambda (tmp986) (if (if tmp986 (apply (lambda (dots987 y988) (ellipsis?958 dots987)) tmp986) #f) (apply (lambda (dots989 y990) (f979 y990 (lambda (maps991) (call-with-values (lambda () (k981 (cons (quote ()) maps991))) (lambda (x992 maps993) (if (null? (car maps993)) (syntax-violation (quote syntax) "extra ellipsis" src954) (values (gen-mappend921 x992 (car maps993)) (cdr maps993)))))))) tmp986) ((lambda (_994) (call-with-values (lambda () (gen-syntax919 src954 y980 r956 maps957 ellipsis?958 mod959)) (lambda (y995 maps996) (call-with-values (lambda () (k981 maps996)) (lambda (x997 maps998) (values (gen-append924 x997 y995) maps998)))))) tmp985))) ($sc-dispatch tmp985 (quote (any . any))))) y980))) tmp972) ((lambda (tmp999) (if tmp999 (apply (lambda (x1000 y1001) (call-with-values (lambda () (gen-syntax919 src954 x1000 r956 maps957 ellipsis?958 mod959)) (lambda (x1002 maps1003) (call-with-values (lambda () (gen-syntax919 src954 y1001 r956 maps1003 ellipsis?958 mod959)) (lambda (y1004 maps1005) (values (gen-cons923 x1002 y1004) maps1005)))))) tmp999) ((lambda (tmp1006) (if tmp1006 (apply (lambda (e11007 e21008) (call-with-values (lambda () (gen-syntax919 src954 (cons e11007 e21008) r956 maps957 ellipsis?958 mod959)) (lambda (e1010 maps1011) (values (gen-vector925 e1010) maps1011)))) tmp1006) ((lambda (_1012) (values (list (quote quote) e955) maps957)) tmp965))) ($sc-dispatch tmp965 (quote #(vector (any . each-any))))))) ($sc-dispatch tmp965 (quote (any . any)))))) ($sc-dispatch tmp965 (quote (any any . any)))))) ($sc-dispatch tmp965 (quote (any any))))) e955))))) (lambda (e1013 r1014 w1015 s1016 mod1017) (let ((e1018 (source-wrap130 e1013 w1015 s1016 mod1017))) ((lambda (tmp1019) ((lambda (tmp1020) (if tmp1020 (apply (lambda (_1021 x1022) (call-with-values (lambda () (gen-syntax919 e1018 x1022 r1014 (quote ()) ellipsis?146 mod1017)) (lambda (e1023 maps1024) (regen926 e1023)))) tmp1020) ((lambda (_1025) (syntax-violation (quote syntax) "bad `syntax' form" e1018)) tmp1019))) ($sc-dispatch tmp1019 (quote (any any))))) e1018))))) (global-extend99 (quote core) (quote lambda) (lambda (e1026 r1027 w1028 s1029 mod1030) ((lambda (tmp1031) ((lambda (tmp1032) (if tmp1032 (apply (lambda (_1033 c1034) (chi-lambda-clause142 (source-wrap130 e1026 w1028 s1029 mod1030) #f c1034 r1027 w1028 mod1030 (lambda (vars1035 docstring1036 body1037) (build-annotated78 s1029 (cons (quote lambda) (cons vars1035 (append (if docstring1036 (list docstring1036) (quote ())) (list body1037)))))))) tmp1032) (syntax-violation #f "source expression failed to match any pattern" tmp1031))) ($sc-dispatch tmp1031 (quote (any . any))))) e1026))) (global-extend99 (quote core) (quote let) (letrec ((chi-let1038 (lambda (e1039 r1040 w1041 s1042 mod1043 constructor1044 ids1045 vals1046 exps1047) (if (not (valid-bound-ids?126 ids1045)) (syntax-violation (quote let) "duplicate bound variable" e1039) (let ((labels1048 (gen-labels107 ids1045)) (new-vars1049 (map gen-var149 ids1045))) (let ((nw1050 (make-binding-wrap118 ids1045 labels1048 w1041)) (nr1051 (extend-var-env96 labels1048 new-vars1049 r1040))) (constructor1044 s1042 new-vars1049 (map (lambda (x1052) (chi137 x1052 r1040 w1041 mod1043)) vals1046) (chi-body141 exps1047 (source-wrap130 e1039 nw1050 s1042 mod1043) nr1051 nw1050 mod1043)))))))) (lambda (e1053 r1054 w1055 s1056 mod1057) ((lambda (tmp1058) ((lambda (tmp1059) (if tmp1059 (apply (lambda (_1060 id1061 val1062 e11063 e21064) (chi-let1038 e1053 r1054 w1055 s1056 mod1057 build-let81 id1061 val1062 (cons e11063 e21064))) tmp1059) ((lambda (tmp1068) (if (if tmp1068 (apply (lambda (_1069 f1070 id1071 val1072 e11073 e21074) (id?101 f1070)) tmp1068) #f) (apply (lambda (_1075 f1076 id1077 val1078 e11079 e21080) (chi-let1038 e1053 r1054 w1055 s1056 mod1057 build-named-let82 (cons f1076 id1077) val1078 (cons e11079 e21080))) tmp1068) ((lambda (_1084) (syntax-violation (quote let) "bad let" (source-wrap130 e1053 w1055 s1056 mod1057))) tmp1058))) ($sc-dispatch tmp1058 (quote (any any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp1058 (quote (any #(each (any any)) any . each-any))))) e1053)))) (global-extend99 (quote core) (quote letrec) (lambda (e1085 r1086 w1087 s1088 mod1089) ((lambda (tmp1090) ((lambda (tmp1091) (if tmp1091 (apply (lambda (_1092 id1093 val1094 e11095 e21096) (let ((ids1097 id1093)) (if (not (valid-bound-ids?126 ids1097)) (syntax-violation (quote letrec) "duplicate bound variable" e1085) (let ((labels1099 (gen-labels107 ids1097)) (new-vars1100 (map gen-var149 ids1097))) (let ((w1101 (make-binding-wrap118 ids1097 labels1099 w1087)) (r1102 (extend-var-env96 labels1099 new-vars1100 r1086))) (build-letrec83 s1088 new-vars1100 (map (lambda (x1103) (chi137 x1103 r1102 w1101 mod1089)) val1094) (chi-body141 (cons e11095 e21096) (source-wrap130 e1085 w1101 s1088 mod1089) r1102 w1101 mod1089))))))) tmp1091) ((lambda (_1106) (syntax-violation (quote letrec) "bad letrec" (source-wrap130 e1085 w1087 s1088 mod1089))) tmp1090))) ($sc-dispatch tmp1090 (quote (any #(each (any any)) any . each-any))))) e1085))) (global-extend99 (quote core) (quote set!) (lambda (e1107 r1108 w1109 s1110 mod1111) ((lambda (tmp1112) ((lambda (tmp1113) (if (if tmp1113 (apply (lambda (_1114 id1115 val1116) (id?101 id1115)) tmp1113) #f) (apply (lambda (_1117 id1118 val1119) (let ((val1120 (chi137 val1119 r1108 w1109 mod1111)) (n1121 (id-var-name123 id1118 w1109))) (let ((b1122 (lookup98 n1121 r1108 mod1111))) (let ((t1123 (binding-type93 b1122))) (if (memv t1123 (quote (lexical))) (build-annotated78 s1110 (list (quote set!) (binding-value94 b1122) val1120)) (if (memv t1123 (quote (global))) (build-annotated78 s1110 (list (quote set!) (if mod1111 (make-module-ref (cdr mod1111) n1121 (car mod1111)) (make-module-ref mod1111 n1121 (quote bare))) val1120)) (if (memv t1123 (quote (displaced-lexical))) (syntax-violation (quote set!) "identifier out of context" (wrap129 id1118 w1109 mod1111)) (syntax-violation (quote set!) "bad set!" (source-wrap130 e1107 w1109 s1110 mod1111))))))))) tmp1113) ((lambda (tmp1124) (if tmp1124 (apply (lambda (_1125 head1126 tail1127 val1128) (call-with-values (lambda () (syntax-type135 head1126 r1108 (quote (())) #f #f mod1111)) (lambda (type1129 value1130 ee1131 ww1132 ss1133 modmod1134) (let ((t1135 type1129)) (if (memv t1135 (quote (module-ref))) (let ((val1136 (chi137 val1128 r1108 w1109 mod1111))) (call-with-values (lambda () (value1130 (cons head1126 tail1127))) (lambda (id1138 mod1139) (build-annotated78 s1110 (list (quote set!) (if mod1139 (make-module-ref (cdr mod1139) id1138 (car mod1139)) (make-module-ref mod1139 id1138 (quote bare))) val1136))))) (build-annotated78 s1110 (cons (chi137 (list (quote #(syntax-object setter ((top) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type value ee ww ss modmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage #(_ head tail val) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(e r w s mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) head1126) r1108 w1109 mod1111) (map (lambda (e1140) (chi137 e1140 r1108 w1109 mod1111)) (append tail1127 (list val1128)))))))))) tmp1124) ((lambda (_1142) (syntax-violation (quote set!) "bad set!" (source-wrap130 e1107 w1109 s1110 mod1111))) tmp1112))) ($sc-dispatch tmp1112 (quote (any (any . each-any) any)))))) ($sc-dispatch tmp1112 (quote (any any any))))) e1107))) (global-extend99 (quote module-ref) (quote @) (lambda (e1143) ((lambda (tmp1144) ((lambda (tmp1145) (if (if tmp1145 (apply (lambda (_1146 mod1147 id1148) (and (and-map id?101 mod1147) (id?101 id1148))) tmp1145) #f) (apply (lambda (_1150 mod1151 id1152) (values (syntax->datum id1152) (syntax->datum (cons (quote #(syntax-object public ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod1151)))) tmp1145) (syntax-violation #f "source expression failed to match any pattern" tmp1144))) ($sc-dispatch tmp1144 (quote (any each-any any))))) e1143))) (global-extend99 (quote module-ref) (quote @@) (lambda (e1154) ((lambda (tmp1155) ((lambda (tmp1156) (if (if tmp1156 (apply (lambda (_1157 mod1158 id1159) (and (and-map id?101 mod1158) (id?101 id1159))) tmp1156) #f) (apply (lambda (_1161 mod1162 id1163) (values (syntax->datum id1163) (syntax->datum (cons (quote #(syntax-object private ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod1162)))) tmp1156) (syntax-violation #f "source expression failed to match any pattern" tmp1155))) ($sc-dispatch tmp1155 (quote (any each-any any))))) e1154))) (global-extend99 (quote begin) (quote begin) (quote ())) (global-extend99 (quote define) (quote define) (quote ())) (global-extend99 (quote define-syntax) (quote define-syntax) (quote ())) (global-extend99 (quote eval-when) (quote eval-when) (quote ())) (global-extend99 (quote core) (quote syntax-case) (letrec ((gen-syntax-case1168 (lambda (x1169 keys1170 clauses1171 r1172 mod1173) (if (null? clauses1171) (build-annotated78 #f (list (build-annotated78 #f (quote syntax-violation)) #f "source expression failed to match any pattern" x1169)) ((lambda (tmp1174) ((lambda (tmp1175) (if tmp1175 (apply (lambda (pat1176 exp1177) (if (and (id?101 pat1176) (and-map (lambda (x1178) (not (free-id=?124 pat1176 x1178))) (cons (quote #(syntax-object ... ((top) #(ribcage #(pat exp) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x keys clauses r mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (gen-syntax-case gen-clause build-dispatch-call convert-pattern) ((top) (top) (top) (top)) ("i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) keys1170))) (let ((labels1179 (list (gen-label106))) (var1180 (gen-var149 pat1176))) (build-annotated78 #f (list (build-annotated78 #f (list (quote lambda) (list var1180) (chi137 exp1177 (extend-env95 labels1179 (list (cons (quote syntax) (cons var1180 0))) r1172) (make-binding-wrap118 (list pat1176) labels1179 (quote (()))) mod1173))) x1169))) (gen-clause1167 x1169 keys1170 (cdr clauses1171) r1172 pat1176 #t exp1177 mod1173))) tmp1175) ((lambda (tmp1181) (if tmp1181 (apply (lambda (pat1182 fender1183 exp1184) (gen-clause1167 x1169 keys1170 (cdr clauses1171) r1172 pat1182 fender1183 exp1184 mod1173)) tmp1181) ((lambda (_1185) (syntax-violation (quote syntax-case) "invalid clause" (car clauses1171))) tmp1174))) ($sc-dispatch tmp1174 (quote (any any any)))))) ($sc-dispatch tmp1174 (quote (any any))))) (car clauses1171))))) (gen-clause1167 (lambda (x1186 keys1187 clauses1188 r1189 pat1190 fender1191 exp1192 mod1193) (call-with-values (lambda () (convert-pattern1165 pat1190 keys1187)) (lambda (p1194 pvars1195) (cond ((not (distinct-bound-ids?127 (map car pvars1195))) (syntax-violation (quote syntax-case) "duplicate pattern variable" pat1190)) ((not (and-map (lambda (x1196) (not (ellipsis?146 (car x1196)))) pvars1195)) (syntax-violation (quote syntax-case) "misplaced ellipsis" pat1190)) (else (let ((y1197 (gen-var149 (quote tmp)))) (build-annotated78 #f (list (build-annotated78 #f (list (quote lambda) (list y1197) (let ((y1198 (build-annotated78 #f y1197))) (build-annotated78 #f (list (quote if) ((lambda (tmp1199) ((lambda (tmp1200) (if tmp1200 (apply (lambda () y1198) tmp1200) ((lambda (_1201) (build-annotated78 #f (list (quote if) y1198 (build-dispatch-call1166 pvars1195 fender1191 y1198 r1189 mod1193) (build-data79 #f #f)))) tmp1199))) ($sc-dispatch tmp1199 (quote #(atom #t))))) fender1191) (build-dispatch-call1166 pvars1195 exp1192 y1198 r1189 mod1193) (gen-syntax-case1168 x1186 keys1187 clauses1188 r1189 mod1193)))))) (if (eq? p1194 (quote any)) (build-annotated78 #f (list (build-annotated78 #f (quote list)) x1186)) (build-annotated78 #f (list (build-annotated78 #f (quote $sc-dispatch)) x1186 (build-data79 #f p1194))))))))))))) (build-dispatch-call1166 (lambda (pvars1202 exp1203 y1204 r1205 mod1206) (let ((ids1207 (map car pvars1202)) (levels1208 (map cdr pvars1202))) (let ((labels1209 (gen-labels107 ids1207)) (new-vars1210 (map gen-var149 ids1207))) (build-annotated78 #f (list (build-annotated78 #f (quote apply)) (build-annotated78 #f (list (quote lambda) new-vars1210 (chi137 exp1203 (extend-env95 labels1209 (map (lambda (var1211 level1212) (cons (quote syntax) (cons var1211 level1212))) new-vars1210 (map cdr pvars1202)) r1205) (make-binding-wrap118 ids1207 labels1209 (quote (()))) mod1206))) y1204)))))) (convert-pattern1165 (lambda (pattern1213 keys1214) (let cvt1215 ((p1216 pattern1213) (n1217 0) (ids1218 (quote ()))) (if (id?101 p1216) (if (bound-id-member?128 p1216 keys1214) (values (vector (quote free-id) p1216) ids1218) (values (quote any) (cons (cons p1216 n1217) ids1218))) ((lambda (tmp1219) ((lambda (tmp1220) (if (if tmp1220 (apply (lambda (x1221 dots1222) (ellipsis?146 dots1222)) tmp1220) #f) (apply (lambda (x1223 dots1224) (call-with-values (lambda () (cvt1215 x1223 (fx+70 n1217 1) ids1218)) (lambda (p1225 ids1226) (values (if (eq? p1225 (quote any)) (quote each-any) (vector (quote each) p1225)) ids1226)))) tmp1220) ((lambda (tmp1227) (if tmp1227 (apply (lambda (x1228 y1229) (call-with-values (lambda () (cvt1215 y1229 n1217 ids1218)) (lambda (y1230 ids1231) (call-with-values (lambda () (cvt1215 x1228 n1217 ids1231)) (lambda (x1232 ids1233) (values (cons x1232 y1230) ids1233)))))) tmp1227) ((lambda (tmp1234) (if tmp1234 (apply (lambda () (values (quote ()) ids1218)) tmp1234) ((lambda (tmp1235) (if tmp1235 (apply (lambda (x1236) (call-with-values (lambda () (cvt1215 x1236 n1217 ids1218)) (lambda (p1238 ids1239) (values (vector (quote vector) p1238) ids1239)))) tmp1235) ((lambda (x1240) (values (vector (quote atom) (strip148 p1216 (quote (())))) ids1218)) tmp1219))) ($sc-dispatch tmp1219 (quote #(vector each-any)))))) ($sc-dispatch tmp1219 (quote ()))))) ($sc-dispatch tmp1219 (quote (any . any)))))) ($sc-dispatch tmp1219 (quote (any any))))) p1216)))))) (lambda (e1241 r1242 w1243 s1244 mod1245) (let ((e1246 (source-wrap130 e1241 w1243 s1244 mod1245))) ((lambda (tmp1247) ((lambda (tmp1248) (if tmp1248 (apply (lambda (_1249 val1250 key1251 m1252) (if (and-map (lambda (x1253) (and (id?101 x1253) (not (ellipsis?146 x1253)))) key1251) (let ((x1255 (gen-var149 (quote tmp)))) (build-annotated78 s1244 (list (build-annotated78 #f (list (quote lambda) (list x1255) (gen-syntax-case1168 (build-annotated78 #f x1255) key1251 m1252 r1242 mod1245))) (chi137 val1250 r1242 (quote (())) mod1245)))) (syntax-violation (quote syntax-case) "invalid literals list" e1246))) tmp1248) (syntax-violation #f "source expression failed to match any pattern" tmp1247))) ($sc-dispatch tmp1247 (quote (any any each-any . each-any))))) e1246))))) (set! sc-expand (let ((m1258 (quote e)) (esew1259 (quote (eval)))) (lambda (x1260) (if (and (pair? x1260) (equal? (car x1260) noexpand69)) (cadr x1260) (chi-top136 x1260 (quote ()) (quote ((top))) m1258 esew1259 (cons (quote hygiene) (module-name (current-module)))))))) (set! sc-expand3 (let ((m1261 (quote e)) (esew1262 (quote (eval)))) (lambda (x1264 . rest1263) (if (and (pair? x1264) (equal? (car x1264) noexpand69)) (cadr x1264) (chi-top136 x1264 (quote ()) (quote ((top))) (if (null? rest1263) m1261 (car rest1263)) (if (or (null? rest1263) (null? (cdr rest1263))) esew1262 (cadr rest1263)) (cons (quote hygiene) (module-name (current-module)))))))) (set! identifier? (lambda (x1265) (nonsymbol-id?100 x1265))) (set! datum->syntax (lambda (id1266 datum1267) (make-syntax-object84 datum1267 (syntax-object-wrap87 id1266) #f))) (set! syntax->datum (lambda (x1268) (strip148 x1268 (quote (()))))) (set! generate-temporaries (lambda (ls1269) (begin (let ((x1270 ls1269)) (if (not (list? x1270)) (syntax-violation (quote generate-temporaries) "invalid argument" x1270))) (map (lambda (x1271) (wrap129 (gensym) (quote ((top))) #f)) ls1269)))) (set! free-identifier=? (lambda (x1272 y1273) (begin (let ((x1274 x1272)) (if (not (nonsymbol-id?100 x1274)) (syntax-violation (quote free-identifier=?) "invalid argument" x1274))) (let ((x1275 y1273)) (if (not (nonsymbol-id?100 x1275)) (syntax-violation (quote free-identifier=?) "invalid argument" x1275))) (free-id=?124 x1272 y1273)))) (set! bound-identifier=? (lambda (x1276 y1277) (begin (let ((x1278 x1276)) (if (not (nonsymbol-id?100 x1278)) (syntax-violation (quote bound-identifier=?) "invalid argument" x1278))) (let ((x1279 y1277)) (if (not (nonsymbol-id?100 x1279)) (syntax-violation (quote bound-identifier=?) "invalid argument" x1279))) (bound-id=?125 x1276 y1277)))) (set! syntax-violation (lambda (who1283 message1282 form1281 . subform1280) (begin (let ((x1284 who1283)) (if (not ((lambda (x1285) (or (not x1285) (string? x1285) (symbol? x1285))) x1284)) (syntax-violation (quote syntax-violation) "invalid argument" x1284))) (let ((x1286 message1282)) (if (not (string? x1286)) (syntax-violation (quote syntax-violation) "invalid argument" x1286))) (scm-error (quote syntax-error) (quote sc-expand) (string-append (if who1283 "~a: " "") "~a " (if (null? subform1280) "in ~a" "in subform `~s' of `~s'")) (let ((tail1287 (cons message1282 (map (lambda (x1288) (strip148 x1288 (quote (())))) (append subform1280 (list form1281)))))) (if who1283 (cons who1283 tail1287) tail1287)) #f)))) (letrec ((match1293 (lambda (e1294 p1295 w1296 r1297 mod1298) (cond ((not r1297) #f) ((eq? p1295 (quote any)) (cons (wrap129 e1294 w1296 mod1298) r1297)) ((syntax-object?85 e1294) (match*1292 (let ((e1299 (syntax-object-expression86 e1294))) (if (annotation? e1299) (annotation-expression e1299) e1299)) p1295 (join-wraps120 w1296 (syntax-object-wrap87 e1294)) r1297 (syntax-object-module88 e1294))) (else (match*1292 (let ((e1300 e1294)) (if (annotation? e1300) (annotation-expression e1300) e1300)) p1295 w1296 r1297 mod1298))))) (match*1292 (lambda (e1301 p1302 w1303 r1304 mod1305) (cond ((null? p1302) (and (null? e1301) r1304)) ((pair? p1302) (and (pair? e1301) (match1293 (car e1301) (car p1302) w1303 (match1293 (cdr e1301) (cdr p1302) w1303 r1304 mod1305) mod1305))) ((eq? p1302 (quote each-any)) (let ((l1306 (match-each-any1290 e1301 w1303 mod1305))) (and l1306 (cons l1306 r1304)))) (else (let ((t1307 (vector-ref p1302 0))) (if (memv t1307 (quote (each))) (if (null? e1301) (match-empty1291 (vector-ref p1302 1) r1304) (let ((l1308 (match-each1289 e1301 (vector-ref p1302 1) w1303 mod1305))) (and l1308 (let collect1309 ((l1310 l1308)) (if (null? (car l1310)) r1304 (cons (map car l1310) (collect1309 (map cdr l1310)))))))) (if (memv t1307 (quote (free-id))) (and (id?101 e1301) (free-id=?124 (wrap129 e1301 w1303 mod1305) (vector-ref p1302 1)) r1304) (if (memv t1307 (quote (atom))) (and (equal? (vector-ref p1302 1) (strip148 e1301 w1303)) r1304) (if (memv t1307 (quote (vector))) (and (vector? e1301) (match1293 (vector->list e1301) (vector-ref p1302 1) w1303 r1304 mod1305))))))))))) (match-empty1291 (lambda (p1311 r1312) (cond ((null? p1311) r1312) ((eq? p1311 (quote any)) (cons (quote ()) r1312)) ((pair? p1311) (match-empty1291 (car p1311) (match-empty1291 (cdr p1311) r1312))) ((eq? p1311 (quote each-any)) (cons (quote ()) r1312)) (else (let ((t1313 (vector-ref p1311 0))) (if (memv t1313 (quote (each))) (match-empty1291 (vector-ref p1311 1) r1312) (if (memv t1313 (quote (free-id atom))) r1312 (if (memv t1313 (quote (vector))) (match-empty1291 (vector-ref p1311 1) r1312))))))))) (match-each-any1290 (lambda (e1314 w1315 mod1316) (cond ((annotation? e1314) (match-each-any1290 (annotation-expression e1314) w1315 mod1316)) ((pair? e1314) (let ((l1317 (match-each-any1290 (cdr e1314) w1315 mod1316))) (and l1317 (cons (wrap129 (car e1314) w1315 mod1316) l1317)))) ((null? e1314) (quote ())) ((syntax-object?85 e1314) (match-each-any1290 (syntax-object-expression86 e1314) (join-wraps120 w1315 (syntax-object-wrap87 e1314)) mod1316)) (else #f)))) (match-each1289 (lambda (e1318 p1319 w1320 mod1321) (cond ((annotation? e1318) (match-each1289 (annotation-expression e1318) p1319 w1320 mod1321)) ((pair? e1318) (let ((first1322 (match1293 (car e1318) p1319 w1320 (quote ()) mod1321))) (and first1322 (let ((rest1323 (match-each1289 (cdr e1318) p1319 w1320 mod1321))) (and rest1323 (cons first1322 rest1323)))))) ((null? e1318) (quote ())) ((syntax-object?85 e1318) (match-each1289 (syntax-object-expression86 e1318) p1319 (join-wraps120 w1320 (syntax-object-wrap87 e1318)) (syntax-object-module88 e1318))) (else #f))))) (set! $sc-dispatch (lambda (e1324 p1325) (cond ((eq? p1325 (quote any)) (list e1324)) ((syntax-object?85 e1324) (match*1292 (let ((e1326 (syntax-object-expression86 e1324))) (if (annotation? e1326) (annotation-expression e1326) e1326)) p1325 (syntax-object-wrap87 e1324) (quote ()) (syntax-object-module88 e1324))) (else (match*1292 (let ((e1327 e1324)) (if (annotation? e1327) (annotation-expression e1327) e1327)) p1325 (quote (())) (quote ()) #f)))))))))
(define with-syntax (make-syncase-macro (quote macro) (lambda (x1328) ((lambda (tmp1329) ((lambda (tmp1330) (if tmp1330 (apply (lambda (_1331 e11332 e21333) (cons (quote #(syntax-object begin ((top) #(ribcage #(_ e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11332 e21333))) tmp1330) ((lambda (tmp1335) (if tmp1335 (apply (lambda (_1336 out1337 in1338 e11339 e21340) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in1338 (quote ()) (list out1337 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11339 e21340))))) tmp1335) ((lambda (tmp1342) (if tmp1342 (apply (lambda (_1343 out1344 in1345 e11346 e21347) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object list ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in1345) (quote ()) (list out1344 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11346 e21347))))) tmp1342) (syntax-violation #f "source expression failed to match any pattern" tmp1329))) ($sc-dispatch tmp1329 (quote (any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp1329 (quote (any ((any any)) any . each-any)))))) ($sc-dispatch tmp1329 (quote (any () any . each-any))))) x1328))))
(define syntax-rules (make-syncase-macro (quote macro) (lambda (x1351) ((lambda (tmp1352) ((lambda (tmp1353) (if tmp1353 (apply (lambda (_1354 k1355 keyword1356 pattern1357 template1358) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (cons (quote #(syntax-object syntax-case ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons k1355 (map (lambda (tmp1361 tmp1360) (list (cons (quote #(syntax-object dummy ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp1360) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp1361))) template1358 pattern1357)))))) tmp1353) (syntax-violation #f "source expression failed to match any pattern" tmp1352))) ($sc-dispatch tmp1352 (quote (any each-any . #(each ((any . any) any))))))) x1351))))
(define let* (make-extended-syncase-macro (module-ref (current-module) (quote let*)) (quote macro) (lambda (x1362) ((lambda (tmp1363) ((lambda (tmp1364) (if (if tmp1364 (apply (lambda (let*1365 x1366 v1367 e11368 e21369) (and-map identifier? x1366)) tmp1364) #f) (apply (lambda (let*1371 x1372 v1373 e11374 e21375) (let f1376 ((bindings1377 (map list x1372 v1373))) (if (null? bindings1377) (cons (quote #(syntax-object let ((top) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote ()) (cons e11374 e21375))) ((lambda (tmp1381) ((lambda (tmp1382) (if tmp1382 (apply (lambda (body1383 binding1384) (list (quote #(syntax-object let ((top) #(ribcage #(body binding) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list binding1384) body1383)) tmp1382) (syntax-violation #f "source expression failed to match any pattern" tmp1381))) ($sc-dispatch tmp1381 (quote (any any))))) (list (f1376 (cdr bindings1377)) (car bindings1377)))))) tmp1364) (syntax-violation #f "source expression failed to match any pattern" tmp1363))) ($sc-dispatch tmp1363 (quote (any #(each (any any)) any . each-any))))) x1362))))
(define do (make-extended-syncase-macro (module-ref (current-module) (quote do)) (quote macro) (lambda (orig-x1385) ((lambda (tmp1386) ((lambda (tmp1387) (if tmp1387 (apply (lambda (_1388 var1389 init1390 step1391 e01392 e11393 c1394) ((lambda (tmp1395) ((lambda (tmp1396) (if tmp1396 (apply (lambda (step1397) ((lambda (tmp1398) ((lambda (tmp1399) (if tmp1399 (apply (lambda () (list (quote #(syntax-object let ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var1389 init1390) (list (quote #(syntax-object if ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object not ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e01392) (cons (quote #(syntax-object begin ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c1394 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step1397))))))) tmp1399) ((lambda (tmp1404) (if tmp1404 (apply (lambda (e11405 e21406) (list (quote #(syntax-object let ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var1389 init1390) (list (quote #(syntax-object if ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e01392 (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (cons e11405 e21406)) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c1394 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step1397))))))) tmp1404) (syntax-violation #f "source expression failed to match any pattern" tmp1398))) ($sc-dispatch tmp1398 (quote (any . each-any)))))) ($sc-dispatch tmp1398 (quote ())))) e11393)) tmp1396) (syntax-violation #f "source expression failed to match any pattern" tmp1395))) ($sc-dispatch tmp1395 (quote each-any)))) (map (lambda (v1413 s1414) ((lambda (tmp1415) ((lambda (tmp1416) (if tmp1416 (apply (lambda () v1413) tmp1416) ((lambda (tmp1417) (if tmp1417 (apply (lambda (e1418) e1418) tmp1417) ((lambda (_1419) (syntax-violation (quote do) "bad step expression" orig-x1385 s1414)) tmp1415))) ($sc-dispatch tmp1415 (quote (any)))))) ($sc-dispatch tmp1415 (quote ())))) s1414)) var1389 step1391))) tmp1387) (syntax-violation #f "source expression failed to match any pattern" tmp1386))) ($sc-dispatch tmp1386 (quote (any #(each (any any . any)) (any . each-any) . each-any))))) orig-x1385))))
(define quasiquote (make-extended-syncase-macro (module-ref (current-module) (quote quasiquote)) (quote macro) (letrec ((quasicons1422 (lambda (x1426 y1427) ((lambda (tmp1428) ((lambda (tmp1429) (if tmp1429 (apply (lambda (x1430 y1431) ((lambda (tmp1432) ((lambda (tmp1433) (if tmp1433 (apply (lambda (dy1434) ((lambda (tmp1435) ((lambda (tmp1436) (if tmp1436 (apply (lambda (dx1437) (list (quote #(syntax-object quote ((top) #(ribcage #(dx) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons dx1437 dy1434))) tmp1436) ((lambda (_1438) (if (null? dy1434) (list (quote #(syntax-object list ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1430) (list (quote #(syntax-object cons ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1430 y1431))) tmp1435))) ($sc-dispatch tmp1435 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) x1430)) tmp1433) ((lambda (tmp1439) (if tmp1439 (apply (lambda (stuff1440) (cons (quote #(syntax-object list ((top) #(ribcage #(stuff) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons x1430 stuff1440))) tmp1439) ((lambda (else1441) (list (quote #(syntax-object cons ((top) #(ribcage #(else) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1430 y1431)) tmp1432))) ($sc-dispatch tmp1432 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . any)))))) ($sc-dispatch tmp1432 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) y1431)) tmp1429) (syntax-violation #f "source expression failed to match any pattern" tmp1428))) ($sc-dispatch tmp1428 (quote (any any))))) (list x1426 y1427)))) (quasiappend1423 (lambda (x1442 y1443) ((lambda (tmp1444) ((lambda (tmp1445) (if tmp1445 (apply (lambda (x1446 y1447) ((lambda (tmp1448) ((lambda (tmp1449) (if tmp1449 (apply (lambda () x1446) tmp1449) ((lambda (_1450) (list (quote #(syntax-object append ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1446 y1447)) tmp1448))) ($sc-dispatch tmp1448 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) ()))))) y1447)) tmp1445) (syntax-violation #f "source expression failed to match any pattern" tmp1444))) ($sc-dispatch tmp1444 (quote (any any))))) (list x1442 y1443)))) (quasivector1424 (lambda (x1451) ((lambda (tmp1452) ((lambda (x1453) ((lambda (tmp1454) ((lambda (tmp1455) (if tmp1455 (apply (lambda (x1456) (list (quote #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (list->vector x1456))) tmp1455) ((lambda (tmp1458) (if tmp1458 (apply (lambda (x1459) (cons (quote #(syntax-object vector ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1459)) tmp1458) ((lambda (_1461) (list (quote #(syntax-object list->vector ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1453)) tmp1454))) ($sc-dispatch tmp1454 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . each-any)))))) ($sc-dispatch tmp1454 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) each-any))))) x1453)) tmp1452)) x1451))) (quasi1425 (lambda (p1462 lev1463) ((lambda (tmp1464) ((lambda (tmp1465) (if tmp1465 (apply (lambda (p1466) (if (= lev1463 0) p1466 (quasicons1422 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1425 (list p1466) (- lev1463 1))))) tmp1465) ((lambda (tmp1467) (if tmp1467 (apply (lambda (p1468 q1469) (if (= lev1463 0) (quasiappend1423 p1468 (quasi1425 q1469 lev1463)) (quasicons1422 (quasicons1422 (quote (#(syntax-object quote ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote-splicing ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1425 (list p1468) (- lev1463 1))) (quasi1425 q1469 lev1463)))) tmp1467) ((lambda (tmp1470) (if tmp1470 (apply (lambda (p1471) (quasicons1422 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object quasiquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1425 (list p1471) (+ lev1463 1)))) tmp1470) ((lambda (tmp1472) (if tmp1472 (apply (lambda (p1473 q1474) (quasicons1422 (quasi1425 p1473 lev1463) (quasi1425 q1474 lev1463))) tmp1472) ((lambda (tmp1475) (if tmp1475 (apply (lambda (x1476) (quasivector1424 (quasi1425 x1476 lev1463))) tmp1475) ((lambda (p1478) (list (quote #(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) p1478)) tmp1464))) ($sc-dispatch tmp1464 (quote #(vector each-any)))))) ($sc-dispatch tmp1464 (quote (any . any)))))) ($sc-dispatch tmp1464 (quote (#(free-id #(syntax-object quasiquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any)))))) ($sc-dispatch tmp1464 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any) . any)))))) ($sc-dispatch tmp1464 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) p1462)))) (lambda (x1479) ((lambda (tmp1480) ((lambda (tmp1481) (if tmp1481 (apply (lambda (_1482 e1483) (quasi1425 e1483 0)) tmp1481) (syntax-violation #f "source expression failed to match any pattern" tmp1480))) ($sc-dispatch tmp1480 (quote (any any))))) x1479)))))
(define include (make-syncase-macro (quote macro) (lambda (x1484) (letrec ((read-file1485 (lambda (fn1486 k1487) (let ((p1488 (open-input-file fn1486))) (let f1489 ((x1490 (read p1488))) (if (eof-object? x1490) (begin (close-input-port p1488) (quote ())) (cons (datum->syntax k1487 x1490) (f1489 (read p1488))))))))) ((lambda (tmp1491) ((lambda (tmp1492) (if tmp1492 (apply (lambda (k1493 filename1494) (let ((fn1495 (syntax->datum filename1494))) ((lambda (tmp1496) ((lambda (tmp1497) (if tmp1497 (apply (lambda (exp1498) (cons (quote #(syntax-object begin ((top) #(ribcage #(exp) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(fn) #((top)) #("i")) #(ribcage #(k filename) #((top) (top)) #("i" "i")) #(ribcage (read-file) ((top)) ("i")) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) exp1498)) tmp1497) (syntax-violation #f "source expression failed to match any pattern" tmp1496))) ($sc-dispatch tmp1496 (quote each-any)))) (read-file1485 fn1495 k1493)))) tmp1492) (syntax-violation #f "source expression failed to match any pattern" tmp1491))) ($sc-dispatch tmp1491 (quote (any any))))) x1484)))))
(define unquote (make-syncase-macro (quote macro) (lambda (x1500) ((lambda (tmp1501) ((lambda (tmp1502) (if tmp1502 (apply (lambda (_1503 e1504) (syntax-violation (quote unquote) "expression not valid outside of quasiquote" x1500)) tmp1502) (syntax-violation #f "source expression failed to match any pattern" tmp1501))) ($sc-dispatch tmp1501 (quote (any any))))) x1500))))
(define unquote-splicing (make-syncase-macro (quote macro) (lambda (x1505) ((lambda (tmp1506) ((lambda (tmp1507) (if tmp1507 (apply (lambda (_1508 e1509) (syntax-violation (quote unquote-splicing) "expression not valid outside of quasiquote" x1505)) tmp1507) (syntax-violation #f "source expression failed to match any pattern" tmp1506))) ($sc-dispatch tmp1506 (quote (any any))))) x1505))))
(define case (make-extended-syncase-macro (module-ref (current-module) (quote case)) (quote macro) (lambda (x1510) ((lambda (tmp1511) ((lambda (tmp1512) (if tmp1512 (apply (lambda (_1513 e1514 m11515 m21516) ((lambda (tmp1517) ((lambda (body1518) (list (quote #(syntax-object let ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (list (quote #(syntax-object t ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e1514)) body1518)) tmp1517)) (let f1519 ((clause1520 m11515) (clauses1521 m21516)) (if (null? clauses1521) ((lambda (tmp1523) ((lambda (tmp1524) (if tmp1524 (apply (lambda (e11525 e21526) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11525 e21526))) tmp1524) ((lambda (tmp1528) (if tmp1528 (apply (lambda (k1529 e11530 e21531) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k1529)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11530 e21531)))) tmp1528) ((lambda (_1534) (syntax-violation (quote case) "bad clause" x1510 clause1520)) tmp1523))) ($sc-dispatch tmp1523 (quote (each-any any . each-any)))))) ($sc-dispatch tmp1523 (quote (#(free-id #(syntax-object else ((top) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) any . each-any))))) clause1520) ((lambda (tmp1535) ((lambda (rest1536) ((lambda (tmp1537) ((lambda (tmp1538) (if tmp1538 (apply (lambda (k1539 e11540 e21541) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k1539)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11540 e21541)) rest1536)) tmp1538) ((lambda (_1544) (syntax-violation (quote case) "bad clause" x1510 clause1520)) tmp1537))) ($sc-dispatch tmp1537 (quote (each-any any . each-any))))) clause1520)) tmp1535)) (f1519 (car clauses1521) (cdr clauses1521))))))) tmp1512) (syntax-violation #f "source expression failed to match any pattern" tmp1511))) ($sc-dispatch tmp1511 (quote (any any any . each-any))))) x1510))))
(define identifier-syntax (make-syncase-macro (quote macro) (lambda (x1545) ((lambda (tmp1546) ((lambda (tmp1547) (if tmp1547 (apply (lambda (_1548 e1549) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote ()) (list (quote #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object identifier? ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) (#(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e1549)) (list (cons _1548 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e1549 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))))))))) tmp1547) (syntax-violation #f "source expression failed to match any pattern" tmp1546))) ($sc-dispatch tmp1546 (quote (any any))))) x1545))))
