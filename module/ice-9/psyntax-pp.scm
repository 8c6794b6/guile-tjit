(eval-when (compile) (set-current-module (resolve-module (quote (guile)))))
(if #f #f)
(letrec ((and-map*17 (lambda (f57 first56 . rest55) (or (null? first56) (if (null? rest55) (let andmap58 ((first59 first56)) (let ((x60 (car first59)) (first61 (cdr first59))) (if (null? first61) (f57 x60) (and (f57 x60) (andmap58 first61))))) (let andmap62 ((first63 first56) (rest64 rest55)) (let ((x65 (car first63)) (xr66 (map car rest64)) (first67 (cdr first63)) (rest68 (map cdr rest64))) (if (null? first67) (apply f57 (cons x65 xr66)) (and (apply f57 (cons x65 xr66)) (andmap62 first67 rest68)))))))))) (letrec ((lambda-var-list155 (lambda (vars330) (let lvl331 ((vars332 vars330) (ls333 (quote ())) (w334 (quote (())))) (cond ((pair? vars332) (lvl331 (cdr vars332) (cons (wrap134 (car vars332) w334 #f) ls333) w334)) ((id?106 vars332) (cons (wrap134 vars332 w334 #f) ls333)) ((null? vars332) ls333) ((syntax-object?90 vars332) (lvl331 (syntax-object-expression91 vars332) ls333 (join-wraps125 w334 (syntax-object-wrap92 vars332)))) ((annotation? vars332) (lvl331 (annotation-expression vars332) ls333 w334)) (else (cons vars332 ls333)))))) (gen-var154 (lambda (id335) (let ((id336 (if (syntax-object?90 id335) (syntax-object-expression91 id335) id335))) (if (annotation? id336) (build-annotated79 (annotation-source id336) (gensym (symbol->string (annotation-expression id336)))) (build-annotated79 #f (gensym (symbol->string id336))))))) (strip153 (lambda (x337 w338) (if (memq (quote top) (wrap-marks109 w338)) (if (or (annotation? x337) (and (pair? x337) (annotation? (car x337)))) (strip-annotation152 x337 #f) x337) (let f339 ((x340 x337)) (cond ((syntax-object?90 x340) (strip153 (syntax-object-expression91 x340) (syntax-object-wrap92 x340))) ((pair? x340) (let ((a341 (f339 (car x340))) (d342 (f339 (cdr x340)))) (if (and (eq? a341 (car x340)) (eq? d342 (cdr x340))) x340 (cons a341 d342)))) ((vector? x340) (let ((old343 (vector->list x340))) (let ((new344 (map f339 old343))) (if (and-map*17 eq? old343 new344) x340 (list->vector new344))))) (else x340)))))) (strip-annotation152 (lambda (x345 parent346) (cond ((pair? x345) (let ((new347 (cons #f #f))) (begin (if parent346 (set-annotation-stripped! parent346 new347)) (set-car! new347 (strip-annotation152 (car x345) #f)) (set-cdr! new347 (strip-annotation152 (cdr x345) #f)) new347))) ((annotation? x345) (or (annotation-stripped x345) (strip-annotation152 (annotation-expression x345) x345))) ((vector? x345) (let ((new348 (make-vector (vector-length x345)))) (begin (if parent346 (set-annotation-stripped! parent346 new348)) (let loop349 ((i350 (- (vector-length x345) 1))) (unless (fx<74 i350 0) (vector-set! new348 i350 (strip-annotation152 (vector-ref x345 i350) #f)) (loop349 (fx-72 i350 1)))) new348))) (else x345)))) (ellipsis?151 (lambda (x351) (and (nonsymbol-id?105 x351) (free-id=?129 x351 (quote #(syntax-object ... ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))))))) (chi-void150 (lambda () (build-annotated79 #f (cons (build-annotated79 #f (quote if)) (quote (#f #f)))))) (eval-local-transformer149 (lambda (expanded352 mod353) (let ((p354 (local-eval-hook76 expanded352 mod353))) (if (procedure? p354) p354 (syntax-violation #f "nonprocedure transformer" p354))))) (chi-local-syntax148 (lambda (rec?355 e356 r357 w358 s359 mod360 k361) ((lambda (tmp362) ((lambda (tmp363) (if tmp363 (apply (lambda (_364 id365 val366 e1367 e2368) (let ((ids369 id365)) (if (not (valid-bound-ids?131 ids369)) (syntax-violation #f "duplicate bound keyword" e356) (let ((labels371 (gen-labels112 ids369))) (let ((new-w372 (make-binding-wrap123 ids369 labels371 w358))) (k361 (cons e1367 e2368) (extend-env100 labels371 (let ((w374 (if rec?355 new-w372 w358)) (trans-r375 (macros-only-env102 r357))) (map (lambda (x376) (cons (quote macro) (eval-local-transformer149 (chi142 x376 trans-r375 w374 mod360) mod360))) val366)) r357) new-w372 s359 mod360)))))) tmp363) ((lambda (_378) (syntax-violation #f "bad local syntax definition" (source-wrap135 e356 w358 s359 mod360))) tmp362))) ($sc-dispatch tmp362 (quote (any #(each (any any)) any . each-any))))) e356))) (chi-lambda-clause147 (lambda (e379 docstring380 c381 r382 w383 mod384 k385) ((lambda (tmp386) ((lambda (tmp387) (if (if tmp387 (apply (lambda (args388 doc389 e1390 e2391) (and (string? (syntax->datum doc389)) (not docstring380))) tmp387) #f) (apply (lambda (args392 doc393 e1394 e2395) (chi-lambda-clause147 e379 doc393 (cons args392 (cons e1394 e2395)) r382 w383 mod384 k385)) tmp387) ((lambda (tmp397) (if tmp397 (apply (lambda (id398 e1399 e2400) (let ((ids401 id398)) (if (not (valid-bound-ids?131 ids401)) (syntax-violation (quote lambda) "invalid parameter list" e379) (let ((labels403 (gen-labels112 ids401)) (new-vars404 (map gen-var154 ids401))) (k385 new-vars404 docstring380 (chi-body146 (cons e1399 e2400) e379 (extend-var-env101 labels403 new-vars404 r382) (make-binding-wrap123 ids401 labels403 w383) mod384)))))) tmp397) ((lambda (tmp406) (if tmp406 (apply (lambda (ids407 e1408 e2409) (let ((old-ids410 (lambda-var-list155 ids407))) (if (not (valid-bound-ids?131 old-ids410)) (syntax-violation (quote lambda) "invalid parameter list" e379) (let ((labels411 (gen-labels112 old-ids410)) (new-vars412 (map gen-var154 old-ids410))) (k385 (let f413 ((ls1414 (cdr new-vars412)) (ls2415 (car new-vars412))) (if (null? ls1414) ls2415 (f413 (cdr ls1414) (cons (car ls1414) ls2415)))) docstring380 (chi-body146 (cons e1408 e2409) e379 (extend-var-env101 labels411 new-vars412 r382) (make-binding-wrap123 old-ids410 labels411 w383) mod384)))))) tmp406) ((lambda (_417) (syntax-violation (quote lambda) "bad lambda" e379)) tmp386))) ($sc-dispatch tmp386 (quote (any any . each-any)))))) ($sc-dispatch tmp386 (quote (each-any any . each-any)))))) ($sc-dispatch tmp386 (quote (any any any . each-any))))) c381))) (chi-body146 (lambda (body418 outer-form419 r420 w421 mod422) (let ((r423 (cons (quote ("placeholder" placeholder)) r420))) (let ((ribcage424 (make-ribcage113 (quote ()) (quote ()) (quote ())))) (let ((w425 (make-wrap108 (wrap-marks109 w421) (cons ribcage424 (wrap-subst110 w421))))) (let parse426 ((body427 (map (lambda (x433) (cons r423 (wrap134 x433 w425 mod422))) body418)) (ids428 (quote ())) (labels429 (quote ())) (vars430 (quote ())) (vals431 (quote ())) (bindings432 (quote ()))) (if (null? body427) (syntax-violation #f "no expressions in body" outer-form419) (let ((e434 (cdar body427)) (er435 (caar body427))) (call-with-values (lambda () (syntax-type140 e434 er435 (quote (())) #f ribcage424 mod422)) (lambda (type436 value437 e438 w439 s440 mod441) (let ((t442 type436)) (if (memv t442 (quote (define-form))) (let ((id443 (wrap134 value437 w439 mod441)) (label444 (gen-label111))) (let ((var445 (gen-var154 id443))) (begin (extend-ribcage!122 ribcage424 id443 label444) (parse426 (cdr body427) (cons id443 ids428) (cons label444 labels429) (cons var445 vars430) (cons (cons er435 (wrap134 e438 w439 mod441)) vals431) (cons (cons (quote lexical) var445) bindings432))))) (if (memv t442 (quote (define-syntax-form))) (let ((id446 (wrap134 value437 w439 mod441)) (label447 (gen-label111))) (begin (extend-ribcage!122 ribcage424 id446 label447) (parse426 (cdr body427) (cons id446 ids428) (cons label447 labels429) vars430 vals431 (cons (cons (quote macro) (cons er435 (wrap134 e438 w439 mod441))) bindings432)))) (if (memv t442 (quote (begin-form))) ((lambda (tmp448) ((lambda (tmp449) (if tmp449 (apply (lambda (_450 e1451) (parse426 (let f452 ((forms453 e1451)) (if (null? forms453) (cdr body427) (cons (cons er435 (wrap134 (car forms453) w439 mod441)) (f452 (cdr forms453))))) ids428 labels429 vars430 vals431 bindings432)) tmp449) (syntax-violation #f "source expression failed to match any pattern" tmp448))) ($sc-dispatch tmp448 (quote (any . each-any))))) e438) (if (memv t442 (quote (local-syntax-form))) (chi-local-syntax148 value437 e438 er435 w439 s440 mod441 (lambda (forms455 er456 w457 s458 mod459) (parse426 (let f460 ((forms461 forms455)) (if (null? forms461) (cdr body427) (cons (cons er456 (wrap134 (car forms461) w457 mod459)) (f460 (cdr forms461))))) ids428 labels429 vars430 vals431 bindings432))) (if (null? ids428) (build-sequence85 #f (map (lambda (x462) (chi142 (cdr x462) (car x462) (quote (())) mod441)) (cons (cons er435 (source-wrap135 e438 w439 s440 mod441)) (cdr body427)))) (begin (if (not (valid-bound-ids?131 ids428)) (syntax-violation #f "invalid or duplicate identifier in definition" outer-form419)) (let loop463 ((bs464 bindings432) (er-cache465 #f) (r-cache466 #f)) (if (not (null? bs464)) (let ((b467 (car bs464))) (if (eq? (car b467) (quote macro)) (let ((er468 (cadr b467))) (let ((r-cache469 (if (eq? er468 er-cache465) r-cache466 (macros-only-env102 er468)))) (begin (set-cdr! b467 (eval-local-transformer149 (chi142 (cddr b467) r-cache469 (quote (())) mod441) mod441)) (loop463 (cdr bs464) er468 r-cache469)))) (loop463 (cdr bs464) er-cache465 r-cache466))))) (set-cdr! r423 (extend-env100 labels429 bindings432 (cdr r423))) (build-letrec88 #f vars430 (map (lambda (x470) (chi142 (cdr x470) (car x470) (quote (())) mod441)) vals431) (build-sequence85 #f (map (lambda (x471) (chi142 (cdr x471) (car x471) (quote (())) mod441)) (cons (cons er435 (source-wrap135 e438 w439 s440 mod441)) (cdr body427)))))))))))))))))))))) (chi-macro145 (lambda (p472 e473 r474 w475 rib476 mod477) (letrec ((rebuild-macro-output478 (lambda (x479 m480) (cond ((pair? x479) (cons (rebuild-macro-output478 (car x479) m480) (rebuild-macro-output478 (cdr x479) m480))) ((syntax-object?90 x479) (let ((w481 (syntax-object-wrap92 x479))) (let ((ms482 (wrap-marks109 w481)) (s483 (wrap-subst110 w481))) (if (and (pair? ms482) (eq? (car ms482) #f)) (make-syntax-object89 (syntax-object-expression91 x479) (make-wrap108 (cdr ms482) (if rib476 (cons rib476 (cdr s483)) (cdr s483))) (syntax-object-module93 x479)) (make-syntax-object89 (syntax-object-expression91 x479) (make-wrap108 (cons m480 ms482) (if rib476 (cons rib476 (cons (quote shift) s483)) (cons (quote shift) s483))) (let ((pmod484 (procedure-module p472))) (if pmod484 (cons (quote hygiene) (module-name pmod484)) (quote (hygiene guile))))))))) ((vector? x479) (let ((n485 (vector-length x479))) (let ((v486 (make-vector n485))) (let doloop487 ((i488 0)) (if (fx=73 i488 n485) v486 (begin (vector-set! v486 i488 (rebuild-macro-output478 (vector-ref x479 i488) m480)) (doloop487 (fx+71 i488 1)))))))) ((symbol? x479) (syntax-violation #f "encountered raw symbol in macro output" (source-wrap135 e473 w475 s mod477) x479)) (else x479))))) (rebuild-macro-output478 (p472 (wrap134 e473 (anti-mark121 w475) mod477)) (string #\m))))) (chi-application144 (lambda (x489 e490 r491 w492 s493 mod494) ((lambda (tmp495) ((lambda (tmp496) (if tmp496 (apply (lambda (e0497 e1498) (build-annotated79 s493 (cons x489 (map (lambda (e499) (chi142 e499 r491 w492 mod494)) e1498)))) tmp496) (syntax-violation #f "source expression failed to match any pattern" tmp495))) ($sc-dispatch tmp495 (quote (any . each-any))))) e490))) (chi-expr143 (lambda (type501 value502 e503 r504 w505 s506 mod507) (let ((t508 type501)) (if (memv t508 (quote (lexical))) (build-lexical-reference80 (quote value) s506 e503 value502) (if (memv t508 (quote (core external-macro))) (value502 e503 r504 w505 s506 mod507) (if (memv t508 (quote (module-ref))) (call-with-values (lambda () (value502 e503)) (lambda (id509 mod510) (build-global-reference82 s506 id509 mod510))) (if (memv t508 (quote (lexical-call))) (chi-application144 (build-lexical-reference80 (quote fun) (source-annotation97 (car e503)) (car e503) value502) e503 r504 w505 s506 mod507) (if (memv t508 (quote (global-call))) (chi-application144 (build-global-reference82 (source-annotation97 (car e503)) value502 (if (syntax-object?90 (car e503)) (syntax-object-module93 (car e503)) mod507)) e503 r504 w505 s506 mod507) (if (memv t508 (quote (constant))) (build-data84 s506 (strip153 (source-wrap135 e503 w505 s506 mod507) (quote (())))) (if (memv t508 (quote (global))) (build-global-reference82 s506 value502 mod507) (if (memv t508 (quote (call))) (chi-application144 (chi142 (car e503) r504 w505 mod507) e503 r504 w505 s506 mod507) (if (memv t508 (quote (begin-form))) ((lambda (tmp511) ((lambda (tmp512) (if tmp512 (apply (lambda (_513 e1514 e2515) (chi-sequence136 (cons e1514 e2515) r504 w505 s506 mod507)) tmp512) (syntax-violation #f "source expression failed to match any pattern" tmp511))) ($sc-dispatch tmp511 (quote (any any . each-any))))) e503) (if (memv t508 (quote (local-syntax-form))) (chi-local-syntax148 value502 e503 r504 w505 s506 mod507 chi-sequence136) (if (memv t508 (quote (eval-when-form))) ((lambda (tmp517) ((lambda (tmp518) (if tmp518 (apply (lambda (_519 x520 e1521 e2522) (let ((when-list523 (chi-when-list139 e503 x520 w505))) (if (memq (quote eval) when-list523) (chi-sequence136 (cons e1521 e2522) r504 w505 s506 mod507) (chi-void150)))) tmp518) (syntax-violation #f "source expression failed to match any pattern" tmp517))) ($sc-dispatch tmp517 (quote (any each-any any . each-any))))) e503) (if (memv t508 (quote (define-form define-syntax-form))) (syntax-violation #f "definition in expression context" e503 (wrap134 value502 w505 mod507)) (if (memv t508 (quote (syntax))) (syntax-violation #f "reference to pattern variable outside syntax form" (source-wrap135 e503 w505 s506 mod507)) (if (memv t508 (quote (displaced-lexical))) (syntax-violation #f "reference to identifier outside its scope" (source-wrap135 e503 w505 s506 mod507)) (syntax-violation #f "unexpected syntax" (source-wrap135 e503 w505 s506 mod507))))))))))))))))))) (chi142 (lambda (e526 r527 w528 mod529) (call-with-values (lambda () (syntax-type140 e526 r527 w528 #f #f mod529)) (lambda (type530 value531 e532 w533 s534 mod535) (chi-expr143 type530 value531 e532 r527 w533 s534 mod535))))) (chi-top141 (lambda (e536 r537 w538 m539 esew540 mod541) (call-with-values (lambda () (syntax-type140 e536 r537 w538 #f #f mod541)) (lambda (type549 value550 e551 w552 s553 mod554) (let ((t555 type549)) (if (memv t555 (quote (begin-form))) ((lambda (tmp556) ((lambda (tmp557) (if tmp557 (apply (lambda (_558) (chi-void150)) tmp557) ((lambda (tmp559) (if tmp559 (apply (lambda (_560 e1561 e2562) (chi-top-sequence137 (cons e1561 e2562) r537 w552 s553 m539 esew540 mod554)) tmp559) (syntax-violation #f "source expression failed to match any pattern" tmp556))) ($sc-dispatch tmp556 (quote (any any . each-any)))))) ($sc-dispatch tmp556 (quote (any))))) e551) (if (memv t555 (quote (local-syntax-form))) (chi-local-syntax148 value550 e551 r537 w552 s553 mod554 (lambda (body564 r565 w566 s567 mod568) (chi-top-sequence137 body564 r565 w566 s567 m539 esew540 mod568))) (if (memv t555 (quote (eval-when-form))) ((lambda (tmp569) ((lambda (tmp570) (if tmp570 (apply (lambda (_571 x572 e1573 e2574) (let ((when-list575 (chi-when-list139 e551 x572 w552)) (body576 (cons e1573 e2574))) (cond ((eq? m539 (quote e)) (if (memq (quote eval) when-list575) (chi-top-sequence137 body576 r537 w552 s553 (quote e) (quote (eval)) mod554) (chi-void150))) ((memq (quote load) when-list575) (if (or (memq (quote compile) when-list575) (and (eq? m539 (quote c&e)) (memq (quote eval) when-list575))) (chi-top-sequence137 body576 r537 w552 s553 (quote c&e) (quote (compile load)) mod554) (if (memq m539 (quote (c c&e))) (chi-top-sequence137 body576 r537 w552 s553 (quote c) (quote (load)) mod554) (chi-void150)))) ((or (memq (quote compile) when-list575) (and (eq? m539 (quote c&e)) (memq (quote eval) when-list575))) (top-level-eval-hook75 (chi-top-sequence137 body576 r537 w552 s553 (quote e) (quote (eval)) mod554) mod554) (chi-void150)) (else (chi-void150))))) tmp570) (syntax-violation #f "source expression failed to match any pattern" tmp569))) ($sc-dispatch tmp569 (quote (any each-any any . each-any))))) e551) (if (memv t555 (quote (define-syntax-form))) (let ((n579 (id-var-name128 value550 w552)) (r580 (macros-only-env102 r537))) (let ((t581 m539)) (if (memv t581 (quote (c))) (if (memq (quote compile) esew540) (let ((e582 (chi-install-global138 n579 (chi142 e551 r580 w552 mod554)))) (begin (top-level-eval-hook75 e582 mod554) (if (memq (quote load) esew540) e582 (chi-void150)))) (if (memq (quote load) esew540) (chi-install-global138 n579 (chi142 e551 r580 w552 mod554)) (chi-void150))) (if (memv t581 (quote (c&e))) (let ((e583 (chi-install-global138 n579 (chi142 e551 r580 w552 mod554)))) (begin (top-level-eval-hook75 e583 mod554) e583)) (begin (if (memq (quote eval) esew540) (top-level-eval-hook75 (chi-install-global138 n579 (chi142 e551 r580 w552 mod554)) mod554)) (chi-void150)))))) (if (memv t555 (quote (define-form))) (let ((n584 (id-var-name128 value550 w552))) (let ((type585 (binding-type98 (lookup103 n584 r537 mod554)))) (let ((t586 type585)) (if (memv t586 (quote (global core macro module-ref))) (let ((x587 (build-annotated79 s553 (list (quote define) n584 (chi142 e551 r537 w552 mod554))))) (begin (if (eq? m539 (quote c&e)) (top-level-eval-hook75 x587 mod554)) x587)) (if (memv t586 (quote (displaced-lexical))) (syntax-violation #f "identifier out of context" e551 (wrap134 value550 w552 mod554)) (syntax-violation #f "cannot define keyword at top level" e551 (wrap134 value550 w552 mod554))))))) (let ((x588 (chi-expr143 type549 value550 e551 r537 w552 s553 mod554))) (begin (if (eq? m539 (quote c&e)) (top-level-eval-hook75 x588 mod554)) x588)))))))))))) (syntax-type140 (lambda (e589 r590 w591 s592 rib593 mod594) (cond ((symbol? e589) (let ((n595 (id-var-name128 e589 w591))) (let ((b596 (lookup103 n595 r590 mod594))) (let ((type597 (binding-type98 b596))) (let ((t598 type597)) (if (memv t598 (quote (lexical))) (values type597 (binding-value99 b596) e589 w591 s592 mod594) (if (memv t598 (quote (global))) (values type597 n595 e589 w591 s592 mod594) (if (memv t598 (quote (macro))) (syntax-type140 (chi-macro145 (binding-value99 b596) e589 r590 w591 rib593 mod594) r590 (quote (())) s592 rib593 mod594) (values type597 (binding-value99 b596) e589 w591 s592 mod594))))))))) ((pair? e589) (let ((first599 (car e589))) (if (id?106 first599) (let ((n600 (id-var-name128 first599 w591))) (let ((b601 (lookup103 n600 r590 (or (and (syntax-object?90 first599) (syntax-object-module93 first599)) mod594)))) (let ((type602 (binding-type98 b601))) (let ((t603 type602)) (if (memv t603 (quote (lexical))) (values (quote lexical-call) (binding-value99 b601) e589 w591 s592 mod594) (if (memv t603 (quote (global))) (values (quote global-call) n600 e589 w591 s592 mod594) (if (memv t603 (quote (macro))) (syntax-type140 (chi-macro145 (binding-value99 b601) e589 r590 w591 rib593 mod594) r590 (quote (())) s592 rib593 mod594) (if (memv t603 (quote (core external-macro module-ref))) (values type602 (binding-value99 b601) e589 w591 s592 mod594) (if (memv t603 (quote (local-syntax))) (values (quote local-syntax-form) (binding-value99 b601) e589 w591 s592 mod594) (if (memv t603 (quote (begin))) (values (quote begin-form) #f e589 w591 s592 mod594) (if (memv t603 (quote (eval-when))) (values (quote eval-when-form) #f e589 w591 s592 mod594) (if (memv t603 (quote (define))) ((lambda (tmp604) ((lambda (tmp605) (if (if tmp605 (apply (lambda (_606 name607 val608) (id?106 name607)) tmp605) #f) (apply (lambda (_609 name610 val611) (values (quote define-form) name610 val611 w591 s592 mod594)) tmp605) ((lambda (tmp612) (if (if tmp612 (apply (lambda (_613 name614 args615 e1616 e2617) (and (id?106 name614) (valid-bound-ids?131 (lambda-var-list155 args615)))) tmp612) #f) (apply (lambda (_618 name619 args620 e1621 e2622) (values (quote define-form) (wrap134 name619 w591 mod594) (cons (quote #(syntax-object lambda ((top) #(ribcage #(_ name args e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) (wrap134 (cons args620 (cons e1621 e2622)) w591 mod594)) (quote (())) s592 mod594)) tmp612) ((lambda (tmp624) (if (if tmp624 (apply (lambda (_625 name626) (id?106 name626)) tmp624) #f) (apply (lambda (_627 name628) (values (quote define-form) (wrap134 name628 w591 mod594) (quote (#(syntax-object if ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)) #(syntax-object #f ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)) #(syntax-object #f ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote (())) s592 mod594)) tmp624) (syntax-violation #f "source expression failed to match any pattern" tmp604))) ($sc-dispatch tmp604 (quote (any any)))))) ($sc-dispatch tmp604 (quote (any (any . any) any . each-any)))))) ($sc-dispatch tmp604 (quote (any any any))))) e589) (if (memv t603 (quote (define-syntax))) ((lambda (tmp629) ((lambda (tmp630) (if (if tmp630 (apply (lambda (_631 name632 val633) (id?106 name632)) tmp630) #f) (apply (lambda (_634 name635 val636) (values (quote define-syntax-form) name635 val636 w591 s592 mod594)) tmp630) (syntax-violation #f "source expression failed to match any pattern" tmp629))) ($sc-dispatch tmp629 (quote (any any any))))) e589) (values (quote call) #f e589 w591 s592 mod594)))))))))))))) (values (quote call) #f e589 w591 s592 mod594)))) ((syntax-object?90 e589) (syntax-type140 (syntax-object-expression91 e589) r590 (join-wraps125 w591 (syntax-object-wrap92 e589)) #f rib593 (or (syntax-object-module93 e589) mod594))) ((annotation? e589) (syntax-type140 (annotation-expression e589) r590 w591 (annotation-source e589) rib593 mod594)) ((self-evaluating? e589) (values (quote constant) #f e589 w591 s592 mod594)) (else (values (quote other) #f e589 w591 s592 mod594))))) (chi-when-list139 (lambda (e637 when-list638 w639) (let f640 ((when-list641 when-list638) (situations642 (quote ()))) (if (null? when-list641) situations642 (f640 (cdr when-list641) (cons (let ((x643 (car when-list641))) (cond ((free-id=?129 x643 (quote #(syntax-object compile ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote compile)) ((free-id=?129 x643 (quote #(syntax-object load ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote load)) ((free-id=?129 x643 (quote #(syntax-object eval ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote eval)) (else (syntax-violation (quote eval-when) "invalid situation" e637 (wrap134 x643 w639 #f))))) situations642)))))) (chi-install-global138 (lambda (name644 e645) (build-annotated79 #f (list (quote define) name644 (if (let ((v646 (module-variable (current-module) name644))) (and v646 (variable-bound? v646) (macro? (variable-ref v646)) (not (eq? (macro-type (variable-ref v646)) (quote syncase-macro))))) (build-annotated79 #f (list (build-annotated79 #f (quote make-extended-syncase-macro)) (build-annotated79 #f (list (build-annotated79 #f (quote module-ref)) (build-annotated79 #f (quote (current-module))) (build-data84 #f name644))) (build-data84 #f (quote macro)) e645)) (build-annotated79 #f (list (build-annotated79 #f (quote make-syncase-macro)) (build-data84 #f (quote macro)) e645))))))) (chi-top-sequence137 (lambda (body647 r648 w649 s650 m651 esew652 mod653) (build-sequence85 s650 (let dobody654 ((body655 body647) (r656 r648) (w657 w649) (m658 m651) (esew659 esew652) (mod660 mod653)) (if (null? body655) (quote ()) (let ((first661 (chi-top141 (car body655) r656 w657 m658 esew659 mod660))) (cons first661 (dobody654 (cdr body655) r656 w657 m658 esew659 mod660)))))))) (chi-sequence136 (lambda (body662 r663 w664 s665 mod666) (build-sequence85 s665 (let dobody667 ((body668 body662) (r669 r663) (w670 w664) (mod671 mod666)) (if (null? body668) (quote ()) (let ((first672 (chi142 (car body668) r669 w670 mod671))) (cons first672 (dobody667 (cdr body668) r669 w670 mod671)))))))) (source-wrap135 (lambda (x673 w674 s675 defmod676) (wrap134 (if s675 (make-annotation x673 s675 #f) x673) w674 defmod676))) (wrap134 (lambda (x677 w678 defmod679) (cond ((and (null? (wrap-marks109 w678)) (null? (wrap-subst110 w678))) x677) ((syntax-object?90 x677) (make-syntax-object89 (syntax-object-expression91 x677) (join-wraps125 w678 (syntax-object-wrap92 x677)) (syntax-object-module93 x677))) ((null? x677) x677) (else (make-syntax-object89 x677 w678 defmod679))))) (bound-id-member?133 (lambda (x680 list681) (and (not (null? list681)) (or (bound-id=?130 x680 (car list681)) (bound-id-member?133 x680 (cdr list681)))))) (distinct-bound-ids?132 (lambda (ids682) (let distinct?683 ((ids684 ids682)) (or (null? ids684) (and (not (bound-id-member?133 (car ids684) (cdr ids684))) (distinct?683 (cdr ids684))))))) (valid-bound-ids?131 (lambda (ids685) (and (let all-ids?686 ((ids687 ids685)) (or (null? ids687) (and (id?106 (car ids687)) (all-ids?686 (cdr ids687))))) (distinct-bound-ids?132 ids685)))) (bound-id=?130 (lambda (i688 j689) (if (and (syntax-object?90 i688) (syntax-object?90 j689)) (and (eq? (let ((e690 (syntax-object-expression91 i688))) (if (annotation? e690) (annotation-expression e690) e690)) (let ((e691 (syntax-object-expression91 j689))) (if (annotation? e691) (annotation-expression e691) e691))) (same-marks?127 (wrap-marks109 (syntax-object-wrap92 i688)) (wrap-marks109 (syntax-object-wrap92 j689)))) (eq? (let ((e692 i688)) (if (annotation? e692) (annotation-expression e692) e692)) (let ((e693 j689)) (if (annotation? e693) (annotation-expression e693) e693)))))) (free-id=?129 (lambda (i694 j695) (and (eq? (let ((x696 i694)) (let ((e697 (if (syntax-object?90 x696) (syntax-object-expression91 x696) x696))) (if (annotation? e697) (annotation-expression e697) e697))) (let ((x698 j695)) (let ((e699 (if (syntax-object?90 x698) (syntax-object-expression91 x698) x698))) (if (annotation? e699) (annotation-expression e699) e699)))) (eq? (id-var-name128 i694 (quote (()))) (id-var-name128 j695 (quote (()))))))) (id-var-name128 (lambda (id700 w701) (letrec ((search-vector-rib704 (lambda (sym710 subst711 marks712 symnames713 ribcage714) (let ((n715 (vector-length symnames713))) (let f716 ((i717 0)) (cond ((fx=73 i717 n715) (search702 sym710 (cdr subst711) marks712)) ((and (eq? (vector-ref symnames713 i717) sym710) (same-marks?127 marks712 (vector-ref (ribcage-marks116 ribcage714) i717))) (values (vector-ref (ribcage-labels117 ribcage714) i717) marks712)) (else (f716 (fx+71 i717 1)))))))) (search-list-rib703 (lambda (sym718 subst719 marks720 symnames721 ribcage722) (let f723 ((symnames724 symnames721) (i725 0)) (cond ((null? symnames724) (search702 sym718 (cdr subst719) marks720)) ((and (eq? (car symnames724) sym718) (same-marks?127 marks720 (list-ref (ribcage-marks116 ribcage722) i725))) (values (list-ref (ribcage-labels117 ribcage722) i725) marks720)) (else (f723 (cdr symnames724) (fx+71 i725 1))))))) (search702 (lambda (sym726 subst727 marks728) (if (null? subst727) (values #f marks728) (let ((fst729 (car subst727))) (if (eq? fst729 (quote shift)) (search702 sym726 (cdr subst727) (cdr marks728)) (let ((symnames730 (ribcage-symnames115 fst729))) (if (vector? symnames730) (search-vector-rib704 sym726 subst727 marks728 symnames730 fst729) (search-list-rib703 sym726 subst727 marks728 symnames730 fst729))))))))) (cond ((symbol? id700) (or (call-with-values (lambda () (search702 id700 (wrap-subst110 w701) (wrap-marks109 w701))) (lambda (x732 . ignore731) x732)) id700)) ((syntax-object?90 id700) (let ((id733 (let ((e735 (syntax-object-expression91 id700))) (if (annotation? e735) (annotation-expression e735) e735))) (w1734 (syntax-object-wrap92 id700))) (let ((marks736 (join-marks126 (wrap-marks109 w701) (wrap-marks109 w1734)))) (call-with-values (lambda () (search702 id733 (wrap-subst110 w701) marks736)) (lambda (new-id737 marks738) (or new-id737 (call-with-values (lambda () (search702 id733 (wrap-subst110 w1734) marks738)) (lambda (x740 . ignore739) x740)) id733)))))) ((annotation? id700) (let ((id741 (let ((e742 id700)) (if (annotation? e742) (annotation-expression e742) e742)))) (or (call-with-values (lambda () (search702 id741 (wrap-subst110 w701) (wrap-marks109 w701))) (lambda (x744 . ignore743) x744)) id741))) (else (syntax-violation (quote id-var-name) "invalid id" id700)))))) (same-marks?127 (lambda (x745 y746) (or (eq? x745 y746) (and (not (null? x745)) (not (null? y746)) (eq? (car x745) (car y746)) (same-marks?127 (cdr x745) (cdr y746)))))) (join-marks126 (lambda (m1747 m2748) (smart-append124 m1747 m2748))) (join-wraps125 (lambda (w1749 w2750) (let ((m1751 (wrap-marks109 w1749)) (s1752 (wrap-subst110 w1749))) (if (null? m1751) (if (null? s1752) w2750 (make-wrap108 (wrap-marks109 w2750) (smart-append124 s1752 (wrap-subst110 w2750)))) (make-wrap108 (smart-append124 m1751 (wrap-marks109 w2750)) (smart-append124 s1752 (wrap-subst110 w2750))))))) (smart-append124 (lambda (m1753 m2754) (if (null? m2754) m1753 (append m1753 m2754)))) (make-binding-wrap123 (lambda (ids755 labels756 w757) (if (null? ids755) w757 (make-wrap108 (wrap-marks109 w757) (cons (let ((labelvec758 (list->vector labels756))) (let ((n759 (vector-length labelvec758))) (let ((symnamevec760 (make-vector n759)) (marksvec761 (make-vector n759))) (begin (let f762 ((ids763 ids755) (i764 0)) (if (not (null? ids763)) (call-with-values (lambda () (id-sym-name&marks107 (car ids763) w757)) (lambda (symname765 marks766) (begin (vector-set! symnamevec760 i764 symname765) (vector-set! marksvec761 i764 marks766) (f762 (cdr ids763) (fx+71 i764 1))))))) (make-ribcage113 symnamevec760 marksvec761 labelvec758))))) (wrap-subst110 w757)))))) (extend-ribcage!122 (lambda (ribcage767 id768 label769) (begin (set-ribcage-symnames!118 ribcage767 (cons (let ((e770 (syntax-object-expression91 id768))) (if (annotation? e770) (annotation-expression e770) e770)) (ribcage-symnames115 ribcage767))) (set-ribcage-marks!119 ribcage767 (cons (wrap-marks109 (syntax-object-wrap92 id768)) (ribcage-marks116 ribcage767))) (set-ribcage-labels!120 ribcage767 (cons label769 (ribcage-labels117 ribcage767)))))) (anti-mark121 (lambda (w771) (make-wrap108 (cons #f (wrap-marks109 w771)) (cons (quote shift) (wrap-subst110 w771))))) (set-ribcage-labels!120 (lambda (x772 update773) (vector-set! x772 3 update773))) (set-ribcage-marks!119 (lambda (x774 update775) (vector-set! x774 2 update775))) (set-ribcage-symnames!118 (lambda (x776 update777) (vector-set! x776 1 update777))) (ribcage-labels117 (lambda (x778) (vector-ref x778 3))) (ribcage-marks116 (lambda (x779) (vector-ref x779 2))) (ribcage-symnames115 (lambda (x780) (vector-ref x780 1))) (ribcage?114 (lambda (x781) (and (vector? x781) (= (vector-length x781) 4) (eq? (vector-ref x781 0) (quote ribcage))))) (make-ribcage113 (lambda (symnames782 marks783 labels784) (vector (quote ribcage) symnames782 marks783 labels784))) (gen-labels112 (lambda (ls785) (if (null? ls785) (quote ()) (cons (gen-label111) (gen-labels112 (cdr ls785)))))) (gen-label111 (lambda () (string #\i))) (wrap-subst110 cdr) (wrap-marks109 car) (make-wrap108 cons) (id-sym-name&marks107 (lambda (x786 w787) (if (syntax-object?90 x786) (values (let ((e788 (syntax-object-expression91 x786))) (if (annotation? e788) (annotation-expression e788) e788)) (join-marks126 (wrap-marks109 w787) (wrap-marks109 (syntax-object-wrap92 x786)))) (values (let ((e789 x786)) (if (annotation? e789) (annotation-expression e789) e789)) (wrap-marks109 w787))))) (id?106 (lambda (x790) (cond ((symbol? x790) #t) ((syntax-object?90 x790) (symbol? (let ((e791 (syntax-object-expression91 x790))) (if (annotation? e791) (annotation-expression e791) e791)))) ((annotation? x790) (symbol? (annotation-expression x790))) (else #f)))) (nonsymbol-id?105 (lambda (x792) (and (syntax-object?90 x792) (symbol? (let ((e793 (syntax-object-expression91 x792))) (if (annotation? e793) (annotation-expression e793) e793)))))) (global-extend104 (lambda (type794 sym795 val796) (put-global-definition-hook77 sym795 type794 val796))) (lookup103 (lambda (x797 r798 mod799) (cond ((assq x797 r798) => cdr) ((symbol? x797) (or (get-global-definition-hook78 x797 mod799) (quote (global)))) (else (quote (displaced-lexical)))))) (macros-only-env102 (lambda (r800) (if (null? r800) (quote ()) (let ((a801 (car r800))) (if (eq? (cadr a801) (quote macro)) (cons a801 (macros-only-env102 (cdr r800))) (macros-only-env102 (cdr r800))))))) (extend-var-env101 (lambda (labels802 vars803 r804) (if (null? labels802) r804 (extend-var-env101 (cdr labels802) (cdr vars803) (cons (cons (car labels802) (cons (quote lexical) (car vars803))) r804))))) (extend-env100 (lambda (labels805 bindings806 r807) (if (null? labels805) r807 (extend-env100 (cdr labels805) (cdr bindings806) (cons (cons (car labels805) (car bindings806)) r807))))) (binding-value99 cdr) (binding-type98 car) (source-annotation97 (lambda (x808) (cond ((annotation? x808) (annotation-source x808)) ((syntax-object?90 x808) (source-annotation97 (syntax-object-expression91 x808))) (else #f)))) (set-syntax-object-module!96 (lambda (x809 update810) (vector-set! x809 3 update810))) (set-syntax-object-wrap!95 (lambda (x811 update812) (vector-set! x811 2 update812))) (set-syntax-object-expression!94 (lambda (x813 update814) (vector-set! x813 1 update814))) (syntax-object-module93 (lambda (x815) (vector-ref x815 3))) (syntax-object-wrap92 (lambda (x816) (vector-ref x816 2))) (syntax-object-expression91 (lambda (x817) (vector-ref x817 1))) (syntax-object?90 (lambda (x818) (and (vector? x818) (= (vector-length x818) 4) (eq? (vector-ref x818 0) (quote syntax-object))))) (make-syntax-object89 (lambda (expression819 wrap820 module821) (vector (quote syntax-object) expression819 wrap820 module821))) (build-letrec88 (lambda (src822 vars823 val-exps824 body-exp825) (if (null? vars823) (build-annotated79 src822 body-exp825) (build-annotated79 src822 (list (quote letrec) (map list vars823 val-exps824) body-exp825))))) (build-named-let87 (lambda (src826 vars827 val-exps828 body-exp829) (if (null? vars827) (build-annotated79 src826 body-exp829) (build-annotated79 src826 (list (quote let) (car vars827) (map list (cdr vars827) val-exps828) body-exp829))))) (build-let86 (lambda (src830 vars831 val-exps832 body-exp833) (if (null? vars831) (build-annotated79 src830 body-exp833) (build-annotated79 src830 (list (quote let) (map list vars831 val-exps832) body-exp833))))) (build-sequence85 (lambda (src834 exps835) (if (null? (cdr exps835)) (build-annotated79 src834 (car exps835)) (build-annotated79 src834 (cons (quote begin) exps835))))) (build-data84 (lambda (src836 exp837) (if (and (self-evaluating? exp837) (not (vector? exp837))) (build-annotated79 src836 exp837) (build-annotated79 src836 (list (quote quote) exp837))))) (build-global-assignment83 (lambda (source838 var839 exp840 mod841) (let ((ref842 (build-global-reference82 source838 var839 mod841))) (build-annotated79 source838 (list (quote set!) ref842 exp840))))) (build-global-reference82 (lambda (source843 var844 mod845) (build-annotated79 source843 (if (not mod845) var844 (let ((make-module-ref846 (let ((t849 (fluid-ref *mode*70))) (if (memv t849 (quote (c))) (@ (ice-9 expand-support) make-module-ref) (lambda (s mod850 var851 public?852) (list (if public?852 (quote @) (quote @@)) mod850 var851))))) (kind847 (car mod845)) (mod848 (cdr mod845))) (let ((t853 kind847)) (if (memv t853 (quote (public))) (make-module-ref846 #f mod848 var844 #t) (if (memv t853 (quote (private))) (if (not (equal? mod848 (module-name (current-module)))) (make-module-ref846 #f mod848 var844 #f) var844) (if (memv t853 (quote (bare))) var844 (if (memv t853 (quote (hygiene))) (if (and (not (equal? mod848 (module-name (current-module)))) (module-variable (resolve-module mod848) var844)) (make-module-ref846 #f mod848 var844 #f) var844) (syntax-violation #f "bad module kind" var844 mod848))))))))))) (build-lexical-assignment81 (lambda (source854 name855 var856 exp857) (build-annotated79 source854 (list (quote set!) (build-lexical-reference80 (quote set) #f name855 var856) exp857)))) (build-lexical-reference80 (lambda (type858 source859 name860 var861) (build-annotated79 source859 (let ((t862 (fluid-ref *mode*70))) (if (memv t862 (quote (c))) ((@ (ice-9 expand-support) make-lexical) #f name860 var861) var861))))) (build-annotated79 (lambda (src863 exp864) (if (and src863 (not (annotation? exp864))) (make-annotation exp864 src863 #t) exp864))) (get-global-definition-hook78 (lambda (symbol865 module866) (begin (if (and (not module866) (current-module)) (warn "module system is booted, we should have a module" symbol865)) (let ((v867 (module-variable (if module866 (resolve-module (cdr module866)) (current-module)) symbol865))) (and v867 (variable-bound? v867) (let ((val868 (variable-ref v867))) (and (macro? val868) (syncase-macro-type val868) (cons (syncase-macro-type val868) (syncase-macro-binding val868))))))))) (put-global-definition-hook77 (lambda (symbol869 type870 val871) (let ((existing872 (let ((v873 (module-variable (current-module) symbol869))) (and v873 (variable-bound? v873) (let ((val874 (variable-ref v873))) (and (macro? val874) (not (syncase-macro-type val874)) val874)))))) (module-define! (current-module) symbol869 (if existing872 (make-extended-syncase-macro existing872 type870 val871) (make-syncase-macro type870 val871)))))) (local-eval-hook76 (lambda (x875 mod876) (primitive-eval (list noexpand69 (let ((t877 (fluid-ref *mode*70))) (if (memv t877 (quote (c))) ((@ (ice-9 expand-support) strip-expansion-structures) x875) x875)))))) (top-level-eval-hook75 (lambda (x878 mod879) (primitive-eval (list noexpand69 (let ((t880 (fluid-ref *mode*70))) (if (memv t880 (quote (c))) ((@ (ice-9 expand-support) strip-expansion-structures) x878) x878)))))) (fx<74 <) (fx=73 =) (fx-72 -) (fx+71 +) (*mode*70 (make-fluid)) (noexpand69 "noexpand")) (begin (global-extend104 (quote local-syntax) (quote letrec-syntax) #t) (global-extend104 (quote local-syntax) (quote let-syntax) #f) (global-extend104 (quote core) (quote fluid-let-syntax) (lambda (e881 r882 w883 s884 mod885) ((lambda (tmp886) ((lambda (tmp887) (if (if tmp887 (apply (lambda (_888 var889 val890 e1891 e2892) (valid-bound-ids?131 var889)) tmp887) #f) (apply (lambda (_894 var895 val896 e1897 e2898) (let ((names899 (map (lambda (x900) (id-var-name128 x900 w883)) var895))) (begin (for-each (lambda (id902 n903) (let ((t904 (binding-type98 (lookup103 n903 r882 mod885)))) (if (memv t904 (quote (displaced-lexical))) (syntax-violation (quote fluid-let-syntax) "identifier out of context" e881 (source-wrap135 id902 w883 s884 mod885))))) var895 names899) (chi-body146 (cons e1897 e2898) (source-wrap135 e881 w883 s884 mod885) (extend-env100 names899 (let ((trans-r907 (macros-only-env102 r882))) (map (lambda (x908) (cons (quote macro) (eval-local-transformer149 (chi142 x908 trans-r907 w883 mod885) mod885))) val896)) r882) w883 mod885)))) tmp887) ((lambda (_910) (syntax-violation (quote fluid-let-syntax) "bad syntax" (source-wrap135 e881 w883 s884 mod885))) tmp886))) ($sc-dispatch tmp886 (quote (any #(each (any any)) any . each-any))))) e881))) (global-extend104 (quote core) (quote quote) (lambda (e911 r912 w913 s914 mod915) ((lambda (tmp916) ((lambda (tmp917) (if tmp917 (apply (lambda (_918 e919) (build-data84 s914 (strip153 e919 w913))) tmp917) ((lambda (_920) (syntax-violation (quote quote) "bad syntax" (source-wrap135 e911 w913 s914 mod915))) tmp916))) ($sc-dispatch tmp916 (quote (any any))))) e911))) (global-extend104 (quote core) (quote syntax) (letrec ((regen928 (lambda (x929) (let ((t930 (car x929))) (if (memv t930 (quote (ref))) (build-lexical-reference80 (quote value) #f (cadr x929) (cadr x929)) (if (memv t930 (quote (primitive))) (build-annotated79 #f (cadr x929)) (if (memv t930 (quote (quote))) (build-data84 #f (cadr x929)) (if (memv t930 (quote (lambda))) (build-annotated79 #f (list (quote lambda) (cadr x929) (regen928 (caddr x929)))) (if (memv t930 (quote (map))) (let ((ls931 (map regen928 (cdr x929)))) (build-annotated79 #f (cons (if (fx=73 (length ls931) 2) (build-annotated79 #f (quote map)) (build-annotated79 #f (quote map))) ls931))) (build-annotated79 #f (cons (build-annotated79 #f (car x929)) (map regen928 (cdr x929)))))))))))) (gen-vector927 (lambda (x932) (cond ((eq? (car x932) (quote list)) (cons (quote vector) (cdr x932))) ((eq? (car x932) (quote quote)) (list (quote quote) (list->vector (cadr x932)))) (else (list (quote list->vector) x932))))) (gen-append926 (lambda (x933 y934) (if (equal? y934 (quote (quote ()))) x933 (list (quote append) x933 y934)))) (gen-cons925 (lambda (x935 y936) (let ((t937 (car y936))) (if (memv t937 (quote (quote))) (if (eq? (car x935) (quote quote)) (list (quote quote) (cons (cadr x935) (cadr y936))) (if (eq? (cadr y936) (quote ())) (list (quote list) x935) (list (quote cons) x935 y936))) (if (memv t937 (quote (list))) (cons (quote list) (cons x935 (cdr y936))) (list (quote cons) x935 y936)))))) (gen-map924 (lambda (e938 map-env939) (let ((formals940 (map cdr map-env939)) (actuals941 (map (lambda (x942) (list (quote ref) (car x942))) map-env939))) (cond ((eq? (car e938) (quote ref)) (car actuals941)) ((and-map (lambda (x943) (and (eq? (car x943) (quote ref)) (memq (cadr x943) formals940))) (cdr e938)) (cons (quote map) (cons (list (quote primitive) (car e938)) (map (let ((r944 (map cons formals940 actuals941))) (lambda (x945) (cdr (assq (cadr x945) r944)))) (cdr e938))))) (else (cons (quote map) (cons (list (quote lambda) formals940 e938) actuals941))))))) (gen-mappend923 (lambda (e946 map-env947) (list (quote apply) (quote (primitive append)) (gen-map924 e946 map-env947)))) (gen-ref922 (lambda (src948 var949 level950 maps951) (if (fx=73 level950 0) (values var949 maps951) (if (null? maps951) (syntax-violation (quote syntax) "missing ellipsis" src948) (call-with-values (lambda () (gen-ref922 src948 var949 (fx-72 level950 1) (cdr maps951))) (lambda (outer-var952 outer-maps953) (let ((b954 (assq outer-var952 (car maps951)))) (if b954 (values (cdr b954) maps951) (let ((inner-var955 (gen-var154 (quote tmp)))) (values inner-var955 (cons (cons (cons outer-var952 inner-var955) (car maps951)) outer-maps953))))))))))) (gen-syntax921 (lambda (src956 e957 r958 maps959 ellipsis?960 mod961) (if (id?106 e957) (let ((label962 (id-var-name128 e957 (quote (()))))) (let ((b963 (lookup103 label962 r958 mod961))) (if (eq? (binding-type98 b963) (quote syntax)) (call-with-values (lambda () (let ((var.lev964 (binding-value99 b963))) (gen-ref922 src956 (car var.lev964) (cdr var.lev964) maps959))) (lambda (var965 maps966) (values (list (quote ref) var965) maps966))) (if (ellipsis?960 e957) (syntax-violation (quote syntax) "misplaced ellipsis" src956) (values (list (quote quote) e957) maps959))))) ((lambda (tmp967) ((lambda (tmp968) (if (if tmp968 (apply (lambda (dots969 e970) (ellipsis?960 dots969)) tmp968) #f) (apply (lambda (dots971 e972) (gen-syntax921 src956 e972 r958 maps959 (lambda (x973) #f) mod961)) tmp968) ((lambda (tmp974) (if (if tmp974 (apply (lambda (x975 dots976 y977) (ellipsis?960 dots976)) tmp974) #f) (apply (lambda (x978 dots979 y980) (let f981 ((y982 y980) (k983 (lambda (maps984) (call-with-values (lambda () (gen-syntax921 src956 x978 r958 (cons (quote ()) maps984) ellipsis?960 mod961)) (lambda (x985 maps986) (if (null? (car maps986)) (syntax-violation (quote syntax) "extra ellipsis" src956) (values (gen-map924 x985 (car maps986)) (cdr maps986)))))))) ((lambda (tmp987) ((lambda (tmp988) (if (if tmp988 (apply (lambda (dots989 y990) (ellipsis?960 dots989)) tmp988) #f) (apply (lambda (dots991 y992) (f981 y992 (lambda (maps993) (call-with-values (lambda () (k983 (cons (quote ()) maps993))) (lambda (x994 maps995) (if (null? (car maps995)) (syntax-violation (quote syntax) "extra ellipsis" src956) (values (gen-mappend923 x994 (car maps995)) (cdr maps995)))))))) tmp988) ((lambda (_996) (call-with-values (lambda () (gen-syntax921 src956 y982 r958 maps959 ellipsis?960 mod961)) (lambda (y997 maps998) (call-with-values (lambda () (k983 maps998)) (lambda (x999 maps1000) (values (gen-append926 x999 y997) maps1000)))))) tmp987))) ($sc-dispatch tmp987 (quote (any . any))))) y982))) tmp974) ((lambda (tmp1001) (if tmp1001 (apply (lambda (x1002 y1003) (call-with-values (lambda () (gen-syntax921 src956 x1002 r958 maps959 ellipsis?960 mod961)) (lambda (x1004 maps1005) (call-with-values (lambda () (gen-syntax921 src956 y1003 r958 maps1005 ellipsis?960 mod961)) (lambda (y1006 maps1007) (values (gen-cons925 x1004 y1006) maps1007)))))) tmp1001) ((lambda (tmp1008) (if tmp1008 (apply (lambda (e11009 e21010) (call-with-values (lambda () (gen-syntax921 src956 (cons e11009 e21010) r958 maps959 ellipsis?960 mod961)) (lambda (e1012 maps1013) (values (gen-vector927 e1012) maps1013)))) tmp1008) ((lambda (_1014) (values (list (quote quote) e957) maps959)) tmp967))) ($sc-dispatch tmp967 (quote #(vector (any . each-any))))))) ($sc-dispatch tmp967 (quote (any . any)))))) ($sc-dispatch tmp967 (quote (any any . any)))))) ($sc-dispatch tmp967 (quote (any any))))) e957))))) (lambda (e1015 r1016 w1017 s1018 mod1019) (let ((e1020 (source-wrap135 e1015 w1017 s1018 mod1019))) ((lambda (tmp1021) ((lambda (tmp1022) (if tmp1022 (apply (lambda (_1023 x1024) (call-with-values (lambda () (gen-syntax921 e1020 x1024 r1016 (quote ()) ellipsis?151 mod1019)) (lambda (e1025 maps1026) (regen928 e1025)))) tmp1022) ((lambda (_1027) (syntax-violation (quote syntax) "bad `syntax' form" e1020)) tmp1021))) ($sc-dispatch tmp1021 (quote (any any))))) e1020))))) (global-extend104 (quote core) (quote lambda) (lambda (e1028 r1029 w1030 s1031 mod1032) ((lambda (tmp1033) ((lambda (tmp1034) (if tmp1034 (apply (lambda (_1035 c1036) (chi-lambda-clause147 (source-wrap135 e1028 w1030 s1031 mod1032) #f c1036 r1029 w1030 mod1032 (lambda (vars1037 docstring1038 body1039) (build-annotated79 s1031 (cons (quote lambda) (cons vars1037 (append (if docstring1038 (list docstring1038) (quote ())) (list body1039)))))))) tmp1034) (syntax-violation #f "source expression failed to match any pattern" tmp1033))) ($sc-dispatch tmp1033 (quote (any . any))))) e1028))) (global-extend104 (quote core) (quote let) (letrec ((chi-let1040 (lambda (e1041 r1042 w1043 s1044 mod1045 constructor1046 ids1047 vals1048 exps1049) (if (not (valid-bound-ids?131 ids1047)) (syntax-violation (quote let) "duplicate bound variable" e1041) (let ((labels1050 (gen-labels112 ids1047)) (new-vars1051 (map gen-var154 ids1047))) (let ((nw1052 (make-binding-wrap123 ids1047 labels1050 w1043)) (nr1053 (extend-var-env101 labels1050 new-vars1051 r1042))) (constructor1046 s1044 new-vars1051 (map (lambda (x1054) (chi142 x1054 r1042 w1043 mod1045)) vals1048) (chi-body146 exps1049 (source-wrap135 e1041 nw1052 s1044 mod1045) nr1053 nw1052 mod1045)))))))) (lambda (e1055 r1056 w1057 s1058 mod1059) ((lambda (tmp1060) ((lambda (tmp1061) (if tmp1061 (apply (lambda (_1062 id1063 val1064 e11065 e21066) (chi-let1040 e1055 r1056 w1057 s1058 mod1059 build-let86 id1063 val1064 (cons e11065 e21066))) tmp1061) ((lambda (tmp1070) (if (if tmp1070 (apply (lambda (_1071 f1072 id1073 val1074 e11075 e21076) (id?106 f1072)) tmp1070) #f) (apply (lambda (_1077 f1078 id1079 val1080 e11081 e21082) (chi-let1040 e1055 r1056 w1057 s1058 mod1059 build-named-let87 (cons f1078 id1079) val1080 (cons e11081 e21082))) tmp1070) ((lambda (_1086) (syntax-violation (quote let) "bad let" (source-wrap135 e1055 w1057 s1058 mod1059))) tmp1060))) ($sc-dispatch tmp1060 (quote (any any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp1060 (quote (any #(each (any any)) any . each-any))))) e1055)))) (global-extend104 (quote core) (quote letrec) (lambda (e1087 r1088 w1089 s1090 mod1091) ((lambda (tmp1092) ((lambda (tmp1093) (if tmp1093 (apply (lambda (_1094 id1095 val1096 e11097 e21098) (let ((ids1099 id1095)) (if (not (valid-bound-ids?131 ids1099)) (syntax-violation (quote letrec) "duplicate bound variable" e1087) (let ((labels1101 (gen-labels112 ids1099)) (new-vars1102 (map gen-var154 ids1099))) (let ((w1103 (make-binding-wrap123 ids1099 labels1101 w1089)) (r1104 (extend-var-env101 labels1101 new-vars1102 r1088))) (build-letrec88 s1090 new-vars1102 (map (lambda (x1105) (chi142 x1105 r1104 w1103 mod1091)) val1096) (chi-body146 (cons e11097 e21098) (source-wrap135 e1087 w1103 s1090 mod1091) r1104 w1103 mod1091))))))) tmp1093) ((lambda (_1108) (syntax-violation (quote letrec) "bad letrec" (source-wrap135 e1087 w1089 s1090 mod1091))) tmp1092))) ($sc-dispatch tmp1092 (quote (any #(each (any any)) any . each-any))))) e1087))) (global-extend104 (quote core) (quote set!) (lambda (e1109 r1110 w1111 s1112 mod1113) ((lambda (tmp1114) ((lambda (tmp1115) (if (if tmp1115 (apply (lambda (_1116 id1117 val1118) (id?106 id1117)) tmp1115) #f) (apply (lambda (_1119 id1120 val1121) (let ((val1122 (chi142 val1121 r1110 w1111 mod1113)) (n1123 (id-var-name128 id1120 w1111))) (let ((b1124 (lookup103 n1123 r1110 mod1113))) (let ((t1125 (binding-type98 b1124))) (if (memv t1125 (quote (lexical))) (build-lexical-assignment81 s1112 (syntax->datum id1120) (binding-value99 b1124) val1122) (if (memv t1125 (quote (global))) (build-global-assignment83 s1112 n1123 val1122 mod1113) (if (memv t1125 (quote (displaced-lexical))) (syntax-violation (quote set!) "identifier out of context" (wrap134 id1120 w1111 mod1113)) (syntax-violation (quote set!) "bad set!" (source-wrap135 e1109 w1111 s1112 mod1113))))))))) tmp1115) ((lambda (tmp1126) (if tmp1126 (apply (lambda (_1127 head1128 tail1129 val1130) (call-with-values (lambda () (syntax-type140 head1128 r1110 (quote (())) #f #f mod1113)) (lambda (type1131 value1132 ee1133 ww1134 ss1135 modmod1136) (let ((t1137 type1131)) (if (memv t1137 (quote (module-ref))) (let ((val1138 (chi142 val1130 r1110 w1111 mod1113))) (call-with-values (lambda () (value1132 (cons head1128 tail1129))) (lambda (id1140 mod1141) (build-global-assignment83 s1112 id1140 val1138 mod1141)))) (build-annotated79 s1112 (cons (chi142 (list (quote #(syntax-object setter ((top) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type value ee ww ss modmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage #(_ head tail val) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(e r w s mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) head1128) r1110 w1111 mod1113) (map (lambda (e1142) (chi142 e1142 r1110 w1111 mod1113)) (append tail1129 (list val1130)))))))))) tmp1126) ((lambda (_1144) (syntax-violation (quote set!) "bad set!" (source-wrap135 e1109 w1111 s1112 mod1113))) tmp1114))) ($sc-dispatch tmp1114 (quote (any (any . each-any) any)))))) ($sc-dispatch tmp1114 (quote (any any any))))) e1109))) (global-extend104 (quote module-ref) (quote @) (lambda (e1145) ((lambda (tmp1146) ((lambda (tmp1147) (if (if tmp1147 (apply (lambda (_1148 mod1149 id1150) (and (and-map id?106 mod1149) (id?106 id1150))) tmp1147) #f) (apply (lambda (_1152 mod1153 id1154) (values (syntax->datum id1154) (syntax->datum (cons (quote #(syntax-object public ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod1153)))) tmp1147) (syntax-violation #f "source expression failed to match any pattern" tmp1146))) ($sc-dispatch tmp1146 (quote (any each-any any))))) e1145))) (global-extend104 (quote module-ref) (quote @@) (lambda (e1156) ((lambda (tmp1157) ((lambda (tmp1158) (if (if tmp1158 (apply (lambda (_1159 mod1160 id1161) (and (and-map id?106 mod1160) (id?106 id1161))) tmp1158) #f) (apply (lambda (_1163 mod1164 id1165) (values (syntax->datum id1165) (syntax->datum (cons (quote #(syntax-object private ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod1164)))) tmp1158) (syntax-violation #f "source expression failed to match any pattern" tmp1157))) ($sc-dispatch tmp1157 (quote (any each-any any))))) e1156))) (global-extend104 (quote begin) (quote begin) (quote ())) (global-extend104 (quote define) (quote define) (quote ())) (global-extend104 (quote define-syntax) (quote define-syntax) (quote ())) (global-extend104 (quote eval-when) (quote eval-when) (quote ())) (global-extend104 (quote core) (quote syntax-case) (letrec ((gen-syntax-case1170 (lambda (x1171 keys1172 clauses1173 r1174 mod1175) (if (null? clauses1173) (build-annotated79 #f (list (build-annotated79 #f (quote syntax-violation)) #f "source expression failed to match any pattern" x1171)) ((lambda (tmp1176) ((lambda (tmp1177) (if tmp1177 (apply (lambda (pat1178 exp1179) (if (and (id?106 pat1178) (and-map (lambda (x1180) (not (free-id=?129 pat1178 x1180))) (cons (quote #(syntax-object ... ((top) #(ribcage #(pat exp) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x keys clauses r mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (gen-syntax-case gen-clause build-dispatch-call convert-pattern) ((top) (top) (top) (top)) ("i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) keys1172))) (let ((labels1181 (list (gen-label111))) (var1182 (gen-var154 pat1178))) (build-annotated79 #f (list (build-annotated79 #f (list (quote lambda) (list var1182) (chi142 exp1179 (extend-env100 labels1181 (list (cons (quote syntax) (cons var1182 0))) r1174) (make-binding-wrap123 (list pat1178) labels1181 (quote (()))) mod1175))) x1171))) (gen-clause1169 x1171 keys1172 (cdr clauses1173) r1174 pat1178 #t exp1179 mod1175))) tmp1177) ((lambda (tmp1183) (if tmp1183 (apply (lambda (pat1184 fender1185 exp1186) (gen-clause1169 x1171 keys1172 (cdr clauses1173) r1174 pat1184 fender1185 exp1186 mod1175)) tmp1183) ((lambda (_1187) (syntax-violation (quote syntax-case) "invalid clause" (car clauses1173))) tmp1176))) ($sc-dispatch tmp1176 (quote (any any any)))))) ($sc-dispatch tmp1176 (quote (any any))))) (car clauses1173))))) (gen-clause1169 (lambda (x1188 keys1189 clauses1190 r1191 pat1192 fender1193 exp1194 mod1195) (call-with-values (lambda () (convert-pattern1167 pat1192 keys1189)) (lambda (p1196 pvars1197) (cond ((not (distinct-bound-ids?132 (map car pvars1197))) (syntax-violation (quote syntax-case) "duplicate pattern variable" pat1192)) ((not (and-map (lambda (x1198) (not (ellipsis?151 (car x1198)))) pvars1197)) (syntax-violation (quote syntax-case) "misplaced ellipsis" pat1192)) (else (let ((y1199 (gen-var154 (quote tmp)))) (build-annotated79 #f (list (build-annotated79 #f (list (quote lambda) (list y1199) (let ((y1200 (build-lexical-reference80 (quote value) #f (quote tmp) y1199))) (build-annotated79 #f (list (quote if) ((lambda (tmp1201) ((lambda (tmp1202) (if tmp1202 (apply (lambda () y1200) tmp1202) ((lambda (_1203) (build-annotated79 #f (list (quote if) y1200 (build-dispatch-call1168 pvars1197 fender1193 y1200 r1191 mod1195) (build-data84 #f #f)))) tmp1201))) ($sc-dispatch tmp1201 (quote #(atom #t))))) fender1193) (build-dispatch-call1168 pvars1197 exp1194 y1200 r1191 mod1195) (gen-syntax-case1170 x1188 keys1189 clauses1190 r1191 mod1195)))))) (if (eq? p1196 (quote any)) (build-annotated79 #f (list (build-annotated79 #f (quote list)) x1188)) (build-annotated79 #f (list (build-annotated79 #f (quote $sc-dispatch)) x1188 (build-data84 #f p1196))))))))))))) (build-dispatch-call1168 (lambda (pvars1204 exp1205 y1206 r1207 mod1208) (let ((ids1209 (map car pvars1204)) (levels1210 (map cdr pvars1204))) (let ((labels1211 (gen-labels112 ids1209)) (new-vars1212 (map gen-var154 ids1209))) (build-annotated79 #f (list (build-annotated79 #f (quote apply)) (build-annotated79 #f (list (quote lambda) new-vars1212 (chi142 exp1205 (extend-env100 labels1211 (map (lambda (var1213 level1214) (cons (quote syntax) (cons var1213 level1214))) new-vars1212 (map cdr pvars1204)) r1207) (make-binding-wrap123 ids1209 labels1211 (quote (()))) mod1208))) y1206)))))) (convert-pattern1167 (lambda (pattern1215 keys1216) (let cvt1217 ((p1218 pattern1215) (n1219 0) (ids1220 (quote ()))) (if (id?106 p1218) (if (bound-id-member?133 p1218 keys1216) (values (vector (quote free-id) p1218) ids1220) (values (quote any) (cons (cons p1218 n1219) ids1220))) ((lambda (tmp1221) ((lambda (tmp1222) (if (if tmp1222 (apply (lambda (x1223 dots1224) (ellipsis?151 dots1224)) tmp1222) #f) (apply (lambda (x1225 dots1226) (call-with-values (lambda () (cvt1217 x1225 (fx+71 n1219 1) ids1220)) (lambda (p1227 ids1228) (values (if (eq? p1227 (quote any)) (quote each-any) (vector (quote each) p1227)) ids1228)))) tmp1222) ((lambda (tmp1229) (if tmp1229 (apply (lambda (x1230 y1231) (call-with-values (lambda () (cvt1217 y1231 n1219 ids1220)) (lambda (y1232 ids1233) (call-with-values (lambda () (cvt1217 x1230 n1219 ids1233)) (lambda (x1234 ids1235) (values (cons x1234 y1232) ids1235)))))) tmp1229) ((lambda (tmp1236) (if tmp1236 (apply (lambda () (values (quote ()) ids1220)) tmp1236) ((lambda (tmp1237) (if tmp1237 (apply (lambda (x1238) (call-with-values (lambda () (cvt1217 x1238 n1219 ids1220)) (lambda (p1240 ids1241) (values (vector (quote vector) p1240) ids1241)))) tmp1237) ((lambda (x1242) (values (vector (quote atom) (strip153 p1218 (quote (())))) ids1220)) tmp1221))) ($sc-dispatch tmp1221 (quote #(vector each-any)))))) ($sc-dispatch tmp1221 (quote ()))))) ($sc-dispatch tmp1221 (quote (any . any)))))) ($sc-dispatch tmp1221 (quote (any any))))) p1218)))))) (lambda (e1243 r1244 w1245 s1246 mod1247) (let ((e1248 (source-wrap135 e1243 w1245 s1246 mod1247))) ((lambda (tmp1249) ((lambda (tmp1250) (if tmp1250 (apply (lambda (_1251 val1252 key1253 m1254) (if (and-map (lambda (x1255) (and (id?106 x1255) (not (ellipsis?151 x1255)))) key1253) (let ((x1257 (gen-var154 (quote tmp)))) (build-annotated79 s1246 (list (build-annotated79 #f (list (quote lambda) (list x1257) (gen-syntax-case1170 (build-lexical-reference80 (quote value) #f (quote tmp) x1257) key1253 m1254 r1244 mod1247))) (chi142 val1252 r1244 (quote (())) mod1247)))) (syntax-violation (quote syntax-case) "invalid literals list" e1248))) tmp1250) (syntax-violation #f "source expression failed to match any pattern" tmp1249))) ($sc-dispatch tmp1249 (quote (any any each-any . each-any))))) e1248))))) (set! sc-expand (lambda (x1261 . rest1260) (if (and (pair? x1261) (equal? (car x1261) noexpand69)) (cadr x1261) (let ((m1262 (if (null? rest1260) (quote e) (car rest1260))) (esew1263 (if (or (null? rest1260) (null? (cdr rest1260))) (quote (eval)) (cadr rest1260)))) (with-fluid* *mode*70 m1262 (lambda () (chi-top141 x1261 (quote ()) (quote ((top))) m1262 esew1263 (cons (quote hygiene) (module-name (current-module)))))))))) (set! identifier? (lambda (x1264) (nonsymbol-id?105 x1264))) (set! datum->syntax (lambda (id1265 datum1266) (make-syntax-object89 datum1266 (syntax-object-wrap92 id1265) #f))) (set! syntax->datum (lambda (x1267) (strip153 x1267 (quote (()))))) (set! generate-temporaries (lambda (ls1268) (begin (let ((x1269 ls1268)) (if (not (list? x1269)) (syntax-violation (quote generate-temporaries) "invalid argument" x1269))) (map (lambda (x1270) (wrap134 (gensym) (quote ((top))) #f)) ls1268)))) (set! free-identifier=? (lambda (x1271 y1272) (begin (let ((x1273 x1271)) (if (not (nonsymbol-id?105 x1273)) (syntax-violation (quote free-identifier=?) "invalid argument" x1273))) (let ((x1274 y1272)) (if (not (nonsymbol-id?105 x1274)) (syntax-violation (quote free-identifier=?) "invalid argument" x1274))) (free-id=?129 x1271 y1272)))) (set! bound-identifier=? (lambda (x1275 y1276) (begin (let ((x1277 x1275)) (if (not (nonsymbol-id?105 x1277)) (syntax-violation (quote bound-identifier=?) "invalid argument" x1277))) (let ((x1278 y1276)) (if (not (nonsymbol-id?105 x1278)) (syntax-violation (quote bound-identifier=?) "invalid argument" x1278))) (bound-id=?130 x1275 y1276)))) (set! syntax-violation (lambda (who1282 message1281 form1280 . subform1279) (begin (let ((x1283 who1282)) (if (not ((lambda (x1284) (or (not x1284) (string? x1284) (symbol? x1284))) x1283)) (syntax-violation (quote syntax-violation) "invalid argument" x1283))) (let ((x1285 message1281)) (if (not (string? x1285)) (syntax-violation (quote syntax-violation) "invalid argument" x1285))) (scm-error (quote syntax-error) (quote sc-expand) (string-append (if who1282 "~a: " "") "~a " (if (null? subform1279) "in ~a" "in subform `~s' of `~s'")) (let ((tail1286 (cons message1281 (map (lambda (x1287) (strip153 x1287 (quote (())))) (append subform1279 (list form1280)))))) (if who1282 (cons who1282 tail1286) tail1286)) #f)))) (letrec ((match1292 (lambda (e1293 p1294 w1295 r1296 mod1297) (cond ((not r1296) #f) ((eq? p1294 (quote any)) (cons (wrap134 e1293 w1295 mod1297) r1296)) ((syntax-object?90 e1293) (match*1291 (let ((e1298 (syntax-object-expression91 e1293))) (if (annotation? e1298) (annotation-expression e1298) e1298)) p1294 (join-wraps125 w1295 (syntax-object-wrap92 e1293)) r1296 (syntax-object-module93 e1293))) (else (match*1291 (let ((e1299 e1293)) (if (annotation? e1299) (annotation-expression e1299) e1299)) p1294 w1295 r1296 mod1297))))) (match*1291 (lambda (e1300 p1301 w1302 r1303 mod1304) (cond ((null? p1301) (and (null? e1300) r1303)) ((pair? p1301) (and (pair? e1300) (match1292 (car e1300) (car p1301) w1302 (match1292 (cdr e1300) (cdr p1301) w1302 r1303 mod1304) mod1304))) ((eq? p1301 (quote each-any)) (let ((l1305 (match-each-any1289 e1300 w1302 mod1304))) (and l1305 (cons l1305 r1303)))) (else (let ((t1306 (vector-ref p1301 0))) (if (memv t1306 (quote (each))) (if (null? e1300) (match-empty1290 (vector-ref p1301 1) r1303) (let ((l1307 (match-each1288 e1300 (vector-ref p1301 1) w1302 mod1304))) (and l1307 (let collect1308 ((l1309 l1307)) (if (null? (car l1309)) r1303 (cons (map car l1309) (collect1308 (map cdr l1309)))))))) (if (memv t1306 (quote (free-id))) (and (id?106 e1300) (free-id=?129 (wrap134 e1300 w1302 mod1304) (vector-ref p1301 1)) r1303) (if (memv t1306 (quote (atom))) (and (equal? (vector-ref p1301 1) (strip153 e1300 w1302)) r1303) (if (memv t1306 (quote (vector))) (and (vector? e1300) (match1292 (vector->list e1300) (vector-ref p1301 1) w1302 r1303 mod1304))))))))))) (match-empty1290 (lambda (p1310 r1311) (cond ((null? p1310) r1311) ((eq? p1310 (quote any)) (cons (quote ()) r1311)) ((pair? p1310) (match-empty1290 (car p1310) (match-empty1290 (cdr p1310) r1311))) ((eq? p1310 (quote each-any)) (cons (quote ()) r1311)) (else (let ((t1312 (vector-ref p1310 0))) (if (memv t1312 (quote (each))) (match-empty1290 (vector-ref p1310 1) r1311) (if (memv t1312 (quote (free-id atom))) r1311 (if (memv t1312 (quote (vector))) (match-empty1290 (vector-ref p1310 1) r1311))))))))) (match-each-any1289 (lambda (e1313 w1314 mod1315) (cond ((annotation? e1313) (match-each-any1289 (annotation-expression e1313) w1314 mod1315)) ((pair? e1313) (let ((l1316 (match-each-any1289 (cdr e1313) w1314 mod1315))) (and l1316 (cons (wrap134 (car e1313) w1314 mod1315) l1316)))) ((null? e1313) (quote ())) ((syntax-object?90 e1313) (match-each-any1289 (syntax-object-expression91 e1313) (join-wraps125 w1314 (syntax-object-wrap92 e1313)) mod1315)) (else #f)))) (match-each1288 (lambda (e1317 p1318 w1319 mod1320) (cond ((annotation? e1317) (match-each1288 (annotation-expression e1317) p1318 w1319 mod1320)) ((pair? e1317) (let ((first1321 (match1292 (car e1317) p1318 w1319 (quote ()) mod1320))) (and first1321 (let ((rest1322 (match-each1288 (cdr e1317) p1318 w1319 mod1320))) (and rest1322 (cons first1321 rest1322)))))) ((null? e1317) (quote ())) ((syntax-object?90 e1317) (match-each1288 (syntax-object-expression91 e1317) p1318 (join-wraps125 w1319 (syntax-object-wrap92 e1317)) (syntax-object-module93 e1317))) (else #f))))) (set! $sc-dispatch (lambda (e1323 p1324) (cond ((eq? p1324 (quote any)) (list e1323)) ((syntax-object?90 e1323) (match*1291 (let ((e1325 (syntax-object-expression91 e1323))) (if (annotation? e1325) (annotation-expression e1325) e1325)) p1324 (syntax-object-wrap92 e1323) (quote ()) (syntax-object-module93 e1323))) (else (match*1291 (let ((e1326 e1323)) (if (annotation? e1326) (annotation-expression e1326) e1326)) p1324 (quote (())) (quote ()) #f)))))))))
(define with-syntax (make-syncase-macro (quote macro) (lambda (x1327) ((lambda (tmp1328) ((lambda (tmp1329) (if tmp1329 (apply (lambda (_1330 e11331 e21332) (cons (quote #(syntax-object begin ((top) #(ribcage #(_ e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11331 e21332))) tmp1329) ((lambda (tmp1334) (if tmp1334 (apply (lambda (_1335 out1336 in1337 e11338 e21339) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in1337 (quote ()) (list out1336 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11338 e21339))))) tmp1334) ((lambda (tmp1341) (if tmp1341 (apply (lambda (_1342 out1343 in1344 e11345 e21346) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object list ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in1344) (quote ()) (list out1343 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11345 e21346))))) tmp1341) (syntax-violation #f "source expression failed to match any pattern" tmp1328))) ($sc-dispatch tmp1328 (quote (any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp1328 (quote (any ((any any)) any . each-any)))))) ($sc-dispatch tmp1328 (quote (any () any . each-any))))) x1327))))
(define syntax-rules (make-syncase-macro (quote macro) (lambda (x1350) ((lambda (tmp1351) ((lambda (tmp1352) (if tmp1352 (apply (lambda (_1353 k1354 keyword1355 pattern1356 template1357) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (cons (quote #(syntax-object syntax-case ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons k1354 (map (lambda (tmp1360 tmp1359) (list (cons (quote #(syntax-object dummy ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp1359) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp1360))) template1357 pattern1356)))))) tmp1352) (syntax-violation #f "source expression failed to match any pattern" tmp1351))) ($sc-dispatch tmp1351 (quote (any each-any . #(each ((any . any) any))))))) x1350))))
(define let* (make-extended-syncase-macro (module-ref (current-module) (quote let*)) (quote macro) (lambda (x1361) ((lambda (tmp1362) ((lambda (tmp1363) (if (if tmp1363 (apply (lambda (let*1364 x1365 v1366 e11367 e21368) (and-map identifier? x1365)) tmp1363) #f) (apply (lambda (let*1370 x1371 v1372 e11373 e21374) (let f1375 ((bindings1376 (map list x1371 v1372))) (if (null? bindings1376) (cons (quote #(syntax-object let ((top) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote ()) (cons e11373 e21374))) ((lambda (tmp1380) ((lambda (tmp1381) (if tmp1381 (apply (lambda (body1382 binding1383) (list (quote #(syntax-object let ((top) #(ribcage #(body binding) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list binding1383) body1382)) tmp1381) (syntax-violation #f "source expression failed to match any pattern" tmp1380))) ($sc-dispatch tmp1380 (quote (any any))))) (list (f1375 (cdr bindings1376)) (car bindings1376)))))) tmp1363) (syntax-violation #f "source expression failed to match any pattern" tmp1362))) ($sc-dispatch tmp1362 (quote (any #(each (any any)) any . each-any))))) x1361))))
(define do (make-extended-syncase-macro (module-ref (current-module) (quote do)) (quote macro) (lambda (orig-x1384) ((lambda (tmp1385) ((lambda (tmp1386) (if tmp1386 (apply (lambda (_1387 var1388 init1389 step1390 e01391 e11392 c1393) ((lambda (tmp1394) ((lambda (tmp1395) (if tmp1395 (apply (lambda (step1396) ((lambda (tmp1397) ((lambda (tmp1398) (if tmp1398 (apply (lambda () (list (quote #(syntax-object let ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var1388 init1389) (list (quote #(syntax-object if ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object not ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e01391) (cons (quote #(syntax-object begin ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c1393 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step1396))))))) tmp1398) ((lambda (tmp1403) (if tmp1403 (apply (lambda (e11404 e21405) (list (quote #(syntax-object let ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var1388 init1389) (list (quote #(syntax-object if ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e01391 (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (cons e11404 e21405)) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c1393 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step1396))))))) tmp1403) (syntax-violation #f "source expression failed to match any pattern" tmp1397))) ($sc-dispatch tmp1397 (quote (any . each-any)))))) ($sc-dispatch tmp1397 (quote ())))) e11392)) tmp1395) (syntax-violation #f "source expression failed to match any pattern" tmp1394))) ($sc-dispatch tmp1394 (quote each-any)))) (map (lambda (v1412 s1413) ((lambda (tmp1414) ((lambda (tmp1415) (if tmp1415 (apply (lambda () v1412) tmp1415) ((lambda (tmp1416) (if tmp1416 (apply (lambda (e1417) e1417) tmp1416) ((lambda (_1418) (syntax-violation (quote do) "bad step expression" orig-x1384 s1413)) tmp1414))) ($sc-dispatch tmp1414 (quote (any)))))) ($sc-dispatch tmp1414 (quote ())))) s1413)) var1388 step1390))) tmp1386) (syntax-violation #f "source expression failed to match any pattern" tmp1385))) ($sc-dispatch tmp1385 (quote (any #(each (any any . any)) (any . each-any) . each-any))))) orig-x1384))))
(define quasiquote (make-extended-syncase-macro (module-ref (current-module) (quote quasiquote)) (quote macro) (letrec ((quasicons1421 (lambda (x1425 y1426) ((lambda (tmp1427) ((lambda (tmp1428) (if tmp1428 (apply (lambda (x1429 y1430) ((lambda (tmp1431) ((lambda (tmp1432) (if tmp1432 (apply (lambda (dy1433) ((lambda (tmp1434) ((lambda (tmp1435) (if tmp1435 (apply (lambda (dx1436) (list (quote #(syntax-object quote ((top) #(ribcage #(dx) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons dx1436 dy1433))) tmp1435) ((lambda (_1437) (if (null? dy1433) (list (quote #(syntax-object list ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1429) (list (quote #(syntax-object cons ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1429 y1430))) tmp1434))) ($sc-dispatch tmp1434 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) x1429)) tmp1432) ((lambda (tmp1438) (if tmp1438 (apply (lambda (stuff1439) (cons (quote #(syntax-object list ((top) #(ribcage #(stuff) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons x1429 stuff1439))) tmp1438) ((lambda (else1440) (list (quote #(syntax-object cons ((top) #(ribcage #(else) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1429 y1430)) tmp1431))) ($sc-dispatch tmp1431 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . any)))))) ($sc-dispatch tmp1431 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) y1430)) tmp1428) (syntax-violation #f "source expression failed to match any pattern" tmp1427))) ($sc-dispatch tmp1427 (quote (any any))))) (list x1425 y1426)))) (quasiappend1422 (lambda (x1441 y1442) ((lambda (tmp1443) ((lambda (tmp1444) (if tmp1444 (apply (lambda (x1445 y1446) ((lambda (tmp1447) ((lambda (tmp1448) (if tmp1448 (apply (lambda () x1445) tmp1448) ((lambda (_1449) (list (quote #(syntax-object append ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1445 y1446)) tmp1447))) ($sc-dispatch tmp1447 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) ()))))) y1446)) tmp1444) (syntax-violation #f "source expression failed to match any pattern" tmp1443))) ($sc-dispatch tmp1443 (quote (any any))))) (list x1441 y1442)))) (quasivector1423 (lambda (x1450) ((lambda (tmp1451) ((lambda (x1452) ((lambda (tmp1453) ((lambda (tmp1454) (if tmp1454 (apply (lambda (x1455) (list (quote #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (list->vector x1455))) tmp1454) ((lambda (tmp1457) (if tmp1457 (apply (lambda (x1458) (cons (quote #(syntax-object vector ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1458)) tmp1457) ((lambda (_1460) (list (quote #(syntax-object list->vector ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1452)) tmp1453))) ($sc-dispatch tmp1453 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . each-any)))))) ($sc-dispatch tmp1453 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) each-any))))) x1452)) tmp1451)) x1450))) (quasi1424 (lambda (p1461 lev1462) ((lambda (tmp1463) ((lambda (tmp1464) (if tmp1464 (apply (lambda (p1465) (if (= lev1462 0) p1465 (quasicons1421 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1424 (list p1465) (- lev1462 1))))) tmp1464) ((lambda (tmp1466) (if tmp1466 (apply (lambda (p1467 q1468) (if (= lev1462 0) (quasiappend1422 p1467 (quasi1424 q1468 lev1462)) (quasicons1421 (quasicons1421 (quote (#(syntax-object quote ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote-splicing ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1424 (list p1467) (- lev1462 1))) (quasi1424 q1468 lev1462)))) tmp1466) ((lambda (tmp1469) (if tmp1469 (apply (lambda (p1470) (quasicons1421 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object quasiquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1424 (list p1470) (+ lev1462 1)))) tmp1469) ((lambda (tmp1471) (if tmp1471 (apply (lambda (p1472 q1473) (quasicons1421 (quasi1424 p1472 lev1462) (quasi1424 q1473 lev1462))) tmp1471) ((lambda (tmp1474) (if tmp1474 (apply (lambda (x1475) (quasivector1423 (quasi1424 x1475 lev1462))) tmp1474) ((lambda (p1477) (list (quote #(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) p1477)) tmp1463))) ($sc-dispatch tmp1463 (quote #(vector each-any)))))) ($sc-dispatch tmp1463 (quote (any . any)))))) ($sc-dispatch tmp1463 (quote (#(free-id #(syntax-object quasiquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any)))))) ($sc-dispatch tmp1463 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any) . any)))))) ($sc-dispatch tmp1463 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) p1461)))) (lambda (x1478) ((lambda (tmp1479) ((lambda (tmp1480) (if tmp1480 (apply (lambda (_1481 e1482) (quasi1424 e1482 0)) tmp1480) (syntax-violation #f "source expression failed to match any pattern" tmp1479))) ($sc-dispatch tmp1479 (quote (any any))))) x1478)))))
(define include (make-syncase-macro (quote macro) (lambda (x1483) (letrec ((read-file1484 (lambda (fn1485 k1486) (let ((p1487 (open-input-file fn1485))) (let f1488 ((x1489 (read p1487))) (if (eof-object? x1489) (begin (close-input-port p1487) (quote ())) (cons (datum->syntax k1486 x1489) (f1488 (read p1487))))))))) ((lambda (tmp1490) ((lambda (tmp1491) (if tmp1491 (apply (lambda (k1492 filename1493) (let ((fn1494 (syntax->datum filename1493))) ((lambda (tmp1495) ((lambda (tmp1496) (if tmp1496 (apply (lambda (exp1497) (cons (quote #(syntax-object begin ((top) #(ribcage #(exp) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(fn) #((top)) #("i")) #(ribcage #(k filename) #((top) (top)) #("i" "i")) #(ribcage (read-file) ((top)) ("i")) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) exp1497)) tmp1496) (syntax-violation #f "source expression failed to match any pattern" tmp1495))) ($sc-dispatch tmp1495 (quote each-any)))) (read-file1484 fn1494 k1492)))) tmp1491) (syntax-violation #f "source expression failed to match any pattern" tmp1490))) ($sc-dispatch tmp1490 (quote (any any))))) x1483)))))
(define unquote (make-syncase-macro (quote macro) (lambda (x1499) ((lambda (tmp1500) ((lambda (tmp1501) (if tmp1501 (apply (lambda (_1502 e1503) (syntax-violation (quote unquote) "expression not valid outside of quasiquote" x1499)) tmp1501) (syntax-violation #f "source expression failed to match any pattern" tmp1500))) ($sc-dispatch tmp1500 (quote (any any))))) x1499))))
(define unquote-splicing (make-syncase-macro (quote macro) (lambda (x1504) ((lambda (tmp1505) ((lambda (tmp1506) (if tmp1506 (apply (lambda (_1507 e1508) (syntax-violation (quote unquote-splicing) "expression not valid outside of quasiquote" x1504)) tmp1506) (syntax-violation #f "source expression failed to match any pattern" tmp1505))) ($sc-dispatch tmp1505 (quote (any any))))) x1504))))
(define case (make-extended-syncase-macro (module-ref (current-module) (quote case)) (quote macro) (lambda (x1509) ((lambda (tmp1510) ((lambda (tmp1511) (if tmp1511 (apply (lambda (_1512 e1513 m11514 m21515) ((lambda (tmp1516) ((lambda (body1517) (list (quote #(syntax-object let ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (list (quote #(syntax-object t ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e1513)) body1517)) tmp1516)) (let f1518 ((clause1519 m11514) (clauses1520 m21515)) (if (null? clauses1520) ((lambda (tmp1522) ((lambda (tmp1523) (if tmp1523 (apply (lambda (e11524 e21525) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11524 e21525))) tmp1523) ((lambda (tmp1527) (if tmp1527 (apply (lambda (k1528 e11529 e21530) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k1528)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11529 e21530)))) tmp1527) ((lambda (_1533) (syntax-violation (quote case) "bad clause" x1509 clause1519)) tmp1522))) ($sc-dispatch tmp1522 (quote (each-any any . each-any)))))) ($sc-dispatch tmp1522 (quote (#(free-id #(syntax-object else ((top) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) any . each-any))))) clause1519) ((lambda (tmp1534) ((lambda (rest1535) ((lambda (tmp1536) ((lambda (tmp1537) (if tmp1537 (apply (lambda (k1538 e11539 e21540) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k1538)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11539 e21540)) rest1535)) tmp1537) ((lambda (_1543) (syntax-violation (quote case) "bad clause" x1509 clause1519)) tmp1536))) ($sc-dispatch tmp1536 (quote (each-any any . each-any))))) clause1519)) tmp1534)) (f1518 (car clauses1520) (cdr clauses1520))))))) tmp1511) (syntax-violation #f "source expression failed to match any pattern" tmp1510))) ($sc-dispatch tmp1510 (quote (any any any . each-any))))) x1509))))
(define identifier-syntax (make-syncase-macro (quote macro) (lambda (x1544) ((lambda (tmp1545) ((lambda (tmp1546) (if tmp1546 (apply (lambda (_1547 e1548) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote ()) (list (quote #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object identifier? ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) (#(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e1548)) (list (cons _1547 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e1548 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))))))))) tmp1546) (syntax-violation #f "source expression failed to match any pattern" tmp1545))) ($sc-dispatch tmp1545 (quote (any any))))) x1544))))
