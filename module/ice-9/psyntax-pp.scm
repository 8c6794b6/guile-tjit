(letrec ((lambda-var-list1180 (lambda (vars1379) (let lvl1380 ((vars1381 vars1379) (ls1382 (quote ())) (w1383 (quote (())))) (cond ((pair? vars1381) (lvl1380 (cdr vars1381) (cons (wrap1159 (car vars1381) w1383 #f) ls1382) w1383)) ((id?1131 vars1381) (cons (wrap1159 vars1381 w1383 #f) ls1382)) ((null? vars1381) ls1382) ((syntax-object?1115 vars1381) (lvl1380 (syntax-object-expression1116 vars1381) ls1382 (join-wraps1150 w1383 (syntax-object-wrap1117 vars1381)))) ((annotation? vars1381) (lvl1380 (annotation-expression vars1381) ls1382 w1383)) (else (cons vars1381 ls1382)))))) (gen-var1179 (lambda (id1384) (let ((id1385 (if (syntax-object?1115 id1384) (syntax-object-expression1116 id1384) id1384))) (if (annotation? id1385) (build-annotated1108 (annotation-source id1385) (gensym (symbol->string (annotation-expression id1385)))) (build-annotated1108 #f (gensym (symbol->string id1385))))))) (strip1178 (lambda (x1386 w1387) (if (memq (quote top) (wrap-marks1134 w1387)) (if (or (annotation? x1386) (and (pair? x1386) (annotation? (car x1386)))) (strip-annotation1177 x1386 #f) x1386) (let f1388 ((x1389 x1386)) (cond ((syntax-object?1115 x1389) (strip1178 (syntax-object-expression1116 x1389) (syntax-object-wrap1117 x1389))) ((pair? x1389) (let ((a1390 (f1388 (car x1389))) (d1391 (f1388 (cdr x1389)))) (if (and (eq? a1390 (car x1389)) (eq? d1391 (cdr x1389))) x1389 (cons a1390 d1391)))) ((vector? x1389) (let ((old1392 (vector->list x1389))) (let ((new1393 (map f1388 old1392))) (if (andmap eq? old1392 new1393) x1389 (list->vector new1393))))) (else x1389)))))) (strip-annotation1177 (lambda (x1394 parent1395) (cond ((pair? x1394) (let ((new1396 (cons #f #f))) (begin (if parent1395 (set-annotation-stripped! parent1395 new1396)) (set-car! new1396 (strip-annotation1177 (car x1394) #f)) (set-cdr! new1396 (strip-annotation1177 (cdr x1394) #f)) new1396))) ((annotation? x1394) (or (annotation-stripped x1394) (strip-annotation1177 (annotation-expression x1394) x1394))) ((vector? x1394) (let ((new1397 (make-vector (vector-length x1394)))) (begin (if parent1395 (set-annotation-stripped! parent1395 new1397)) (let loop1398 ((i1399 (- (vector-length x1394) 1))) (unless (fx<1101 i1399 0) (vector-set! new1397 i1399 (strip-annotation1177 (vector-ref x1394 i1399) #f)) (loop1398 (fx-1099 i1399 1)))) new1397))) (else x1394)))) (ellipsis?1176 (lambda (x1400) (and (nonsymbol-id?1130 x1400) (free-id=?1154 x1400 (quote #(syntax-object ... ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (guile))))))) (chi-void1175 (lambda () (build-annotated1108 #f (list (build-annotated1108 #f (quote void)))))) (eval-local-transformer1174 (lambda (expanded1401 mod1402) (let ((p1403 (local-eval-hook1103 expanded1401 mod1402))) (if (procedure? p1403) p1403 (syntax-error p1403 "nonprocedure transformer"))))) (chi-local-syntax1173 (lambda (rec?1404 e1405 r1406 w1407 s1408 mod1409 k1410) ((lambda (tmp1411) ((lambda (tmp1412) (if tmp1412 (apply (lambda (_1413 id1414 val1415 e11416 e21417) (let ((ids1418 id1414)) (if (not (valid-bound-ids?1156 ids1418)) (syntax-error e1405 "duplicate bound keyword in") (let ((labels1420 (gen-labels1137 ids1418))) (let ((new-w1421 (make-binding-wrap1148 ids1418 labels1420 w1407))) (k1410 (cons e11416 e21417) (extend-env1125 labels1420 (let ((w1423 (if rec?1404 new-w1421 w1407)) (trans-r1424 (macros-only-env1127 r1406))) (map (lambda (x1425) (cons (quote macro) (eval-local-transformer1174 (chi1167 x1425 trans-r1424 w1423 mod1409) mod1409))) val1415)) r1406) new-w1421 s1408 mod1409)))))) tmp1412) ((lambda (_1427) (syntax-error (source-wrap1160 e1405 w1407 s1408 mod1409))) tmp1411))) (syntax-dispatch tmp1411 (quote (any #(each (any any)) any . each-any))))) e1405))) (chi-lambda-clause1172 (lambda (e1428 c1429 r1430 w1431 mod1432 k1433) ((lambda (tmp1434) ((lambda (tmp1435) (if tmp1435 (apply (lambda (id1436 e11437 e21438) (let ((ids1439 id1436)) (if (not (valid-bound-ids?1156 ids1439)) (syntax-error e1428 "invalid parameter list in") (let ((labels1441 (gen-labels1137 ids1439)) (new-vars1442 (map gen-var1179 ids1439))) (k1433 new-vars1442 (chi-body1171 (cons e11437 e21438) e1428 (extend-var-env1126 labels1441 new-vars1442 r1430) (make-binding-wrap1148 ids1439 labels1441 w1431) mod1432)))))) tmp1435) ((lambda (tmp1444) (if tmp1444 (apply (lambda (ids1445 e11446 e21447) (let ((old-ids1448 (lambda-var-list1180 ids1445))) (if (not (valid-bound-ids?1156 old-ids1448)) (syntax-error e1428 "invalid parameter list in") (let ((labels1449 (gen-labels1137 old-ids1448)) (new-vars1450 (map gen-var1179 old-ids1448))) (k1433 (let f1451 ((ls11452 (cdr new-vars1450)) (ls21453 (car new-vars1450))) (if (null? ls11452) ls21453 (f1451 (cdr ls11452) (cons (car ls11452) ls21453)))) (chi-body1171 (cons e11446 e21447) e1428 (extend-var-env1126 labels1449 new-vars1450 r1430) (make-binding-wrap1148 old-ids1448 labels1449 w1431) mod1432)))))) tmp1444) ((lambda (_1455) (syntax-error e1428)) tmp1434))) (syntax-dispatch tmp1434 (quote (any any . each-any)))))) (syntax-dispatch tmp1434 (quote (each-any any . each-any))))) c1429))) (chi-body1171 (lambda (body1456 outer-form1457 r1458 w1459 mod1460) (let ((r1461 (cons (quote ("placeholder" placeholder)) r1458))) (let ((ribcage1462 (make-ribcage1138 (quote ()) (quote ()) (quote ())))) (let ((w1463 (make-wrap1133 (wrap-marks1134 w1459) (cons ribcage1462 (wrap-subst1135 w1459))))) (let parse1464 ((body1465 (map (lambda (x1471) (cons r1461 (wrap1159 x1471 w1463 mod1460))) body1456)) (ids1466 (quote ())) (labels1467 (quote ())) (vars1468 (quote ())) (vals1469 (quote ())) (bindings1470 (quote ()))) (if (null? body1465) (syntax-error outer-form1457 "no expressions in body") (let ((e1472 (cdar body1465)) (er1473 (caar body1465))) (call-with-values (lambda () (syntax-type1165 e1472 er1473 (quote (())) #f ribcage1462 mod1460)) (lambda (type1474 value1475 e1476 w1477 s1478 mod1479) (let ((t1480 type1474)) (if (memv t1480 (quote (define-form))) (let ((id1481 (wrap1159 value1475 w1477 mod1479)) (label1482 (gen-label1136))) (let ((var1483 (gen-var1179 id1481))) (begin (extend-ribcage!1147 ribcage1462 id1481 label1482) (parse1464 (cdr body1465) (cons id1481 ids1466) (cons label1482 labels1467) (cons var1483 vars1468) (cons (cons er1473 (wrap1159 e1476 w1477 mod1479)) vals1469) (cons (cons (quote lexical) var1483) bindings1470))))) (if (memv t1480 (quote (define-syntax-form))) (let ((id1484 (wrap1159 value1475 w1477 mod1479)) (label1485 (gen-label1136))) (begin (extend-ribcage!1147 ribcage1462 id1484 label1485) (parse1464 (cdr body1465) (cons id1484 ids1466) (cons label1485 labels1467) vars1468 vals1469 (cons (cons (quote macro) (cons er1473 (wrap1159 e1476 w1477 mod1479))) bindings1470)))) (if (memv t1480 (quote (begin-form))) ((lambda (tmp1486) ((lambda (tmp1487) (if tmp1487 (apply (lambda (_1488 e11489) (parse1464 (let f1490 ((forms1491 e11489)) (if (null? forms1491) (cdr body1465) (cons (cons er1473 (wrap1159 (car forms1491) w1477 mod1479)) (f1490 (cdr forms1491))))) ids1466 labels1467 vars1468 vals1469 bindings1470)) tmp1487) (syntax-error tmp1486))) (syntax-dispatch tmp1486 (quote (any . each-any))))) e1476) (if (memv t1480 (quote (local-syntax-form))) (chi-local-syntax1173 value1475 e1476 er1473 w1477 s1478 mod1479 (lambda (forms1493 er1494 w1495 s1496 mod1497) (parse1464 (let f1498 ((forms1499 forms1493)) (if (null? forms1499) (cdr body1465) (cons (cons er1494 (wrap1159 (car forms1499) w1495 mod1497)) (f1498 (cdr forms1499))))) ids1466 labels1467 vars1468 vals1469 bindings1470))) (if (null? ids1466) (build-sequence1110 #f (map (lambda (x1500) (chi1167 (cdr x1500) (car x1500) (quote (())) mod1479)) (cons (cons er1473 (source-wrap1160 e1476 w1477 s1478 mod1479)) (cdr body1465)))) (begin (if (not (valid-bound-ids?1156 ids1466)) (syntax-error outer-form1457 "invalid or duplicate identifier in definition")) (let loop1501 ((bs1502 bindings1470) (er-cache1503 #f) (r-cache1504 #f)) (if (not (null? bs1502)) (let ((b1505 (car bs1502))) (if (eq? (car b1505) (quote macro)) (let ((er1506 (cadr b1505))) (let ((r-cache1507 (if (eq? er1506 er-cache1503) r-cache1504 (macros-only-env1127 er1506)))) (begin (set-cdr! b1505 (eval-local-transformer1174 (chi1167 (cddr b1505) r-cache1507 (quote (())) mod1479) mod1479)) (loop1501 (cdr bs1502) er1506 r-cache1507)))) (loop1501 (cdr bs1502) er-cache1503 r-cache1504))))) (set-cdr! r1461 (extend-env1125 labels1467 bindings1470 (cdr r1461))) (build-letrec1113 #f vars1468 (map (lambda (x1508) (chi1167 (cdr x1508) (car x1508) (quote (())) mod1479)) vals1469) (build-sequence1110 #f (map (lambda (x1509) (chi1167 (cdr x1509) (car x1509) (quote (())) mod1479)) (cons (cons er1473 (source-wrap1160 e1476 w1477 s1478 mod1479)) (cdr body1465)))))))))))))))))))))) (chi-macro1170 (lambda (p1510 e1511 r1512 w1513 rib1514 mod1515) (letrec ((rebuild-macro-output1516 (lambda (x1517 m1518) (cond ((pair? x1517) (cons (rebuild-macro-output1516 (car x1517) m1518) (rebuild-macro-output1516 (cdr x1517) m1518))) ((syntax-object?1115 x1517) (let ((w1519 (syntax-object-wrap1117 x1517))) (let ((ms1520 (wrap-marks1134 w1519)) (s1521 (wrap-subst1135 w1519))) (if (and (pair? ms1520) (eq? (car ms1520) #f)) (make-syntax-object1114 (syntax-object-expression1116 x1517) (make-wrap1133 (cdr ms1520) (if rib1514 (cons rib1514 (cdr s1521)) (cdr s1521))) (syntax-object-module1118 x1517)) (make-syntax-object1114 (syntax-object-expression1116 x1517) (make-wrap1133 (cons m1518 ms1520) (if rib1514 (cons rib1514 (cons (quote shift) s1521)) (cons (quote shift) s1521))) (module-name (procedure-module p1510))))))) ((vector? x1517) (let ((n1522 (vector-length x1517))) (let ((v1523 (make-vector n1522))) (let doloop1524 ((i1525 0)) (if (fx=1100 i1525 n1522) v1523 (begin (vector-set! v1523 i1525 (rebuild-macro-output1516 (vector-ref x1517 i1525) m1518)) (doloop1524 (fx+1098 i1525 1)))))))) ((symbol? x1517) (syntax-error x1517 "encountered raw symbol in macro output")) (else x1517))))) (rebuild-macro-output1516 (p1510 (wrap1159 e1511 (anti-mark1146 w1513) mod1515)) (string #\m))))) (chi-application1169 (lambda (x1526 e1527 r1528 w1529 s1530 mod1531) ((lambda (tmp1532) ((lambda (tmp1533) (if tmp1533 (apply (lambda (e01534 e11535) (build-annotated1108 s1530 (cons x1526 (map (lambda (e1536) (chi1167 e1536 r1528 w1529 mod1531)) e11535)))) tmp1533) (syntax-error tmp1532))) (syntax-dispatch tmp1532 (quote (any . each-any))))) e1527))) (chi-expr1168 (lambda (type1538 value1539 e1540 r1541 w1542 s1543 mod1544) (let ((t1545 type1538)) (if (memv t1545 (quote (lexical))) (build-annotated1108 s1543 value1539) (if (memv t1545 (quote (core external-macro))) (value1539 e1540 r1541 w1542 s1543 mod1544) (if (memv t1545 (quote (module-ref))) (call-with-values (lambda () (value1539 e1540)) (lambda (id1546 mod1547) (cond ((and mod1547 (not (car mod1547))) (build-annotated1108 s1543 (make-module-ref (cdr mod1547) id1546 #t))) (else (build-annotated1108 s1543 (make-module-ref mod1547 id1546 #f)))))) (if (memv t1545 (quote (lexical-call))) (chi-application1169 (build-annotated1108 (source-annotation1122 (car e1540)) value1539) e1540 r1541 w1542 s1543 mod1544) (if (memv t1545 (quote (global-call))) (chi-application1169 (cond ((and (if (syntax-object?1115 (car e1540)) (syntax-object-module1118 (car e1540)) mod1544) (not (car (if (syntax-object?1115 (car e1540)) (syntax-object-module1118 (car e1540)) mod1544)))) (build-annotated1108 (source-annotation1122 (car e1540)) (make-module-ref (cdr (if (syntax-object?1115 (car e1540)) (syntax-object-module1118 (car e1540)) mod1544)) value1539 #t))) (else (build-annotated1108 (source-annotation1122 (car e1540)) (make-module-ref (if (syntax-object?1115 (car e1540)) (syntax-object-module1118 (car e1540)) mod1544) value1539 #f)))) e1540 r1541 w1542 s1543 mod1544) (if (memv t1545 (quote (constant))) (build-data1109 s1543 (strip1178 (source-wrap1160 e1540 w1542 s1543 mod1544) (quote (())))) (if (memv t1545 (quote (global))) (cond ((and mod1544 (not (car mod1544))) (build-annotated1108 s1543 (make-module-ref (cdr mod1544) value1539 #t))) (else (build-annotated1108 s1543 (make-module-ref mod1544 value1539 #f)))) (if (memv t1545 (quote (call))) (chi-application1169 (chi1167 (car e1540) r1541 w1542 mod1544) e1540 r1541 w1542 s1543 mod1544) (if (memv t1545 (quote (begin-form))) ((lambda (tmp1548) ((lambda (tmp1549) (if tmp1549 (apply (lambda (_1550 e11551 e21552) (chi-sequence1161 (cons e11551 e21552) r1541 w1542 s1543 mod1544)) tmp1549) (syntax-error tmp1548))) (syntax-dispatch tmp1548 (quote (any any . each-any))))) e1540) (if (memv t1545 (quote (local-syntax-form))) (chi-local-syntax1173 value1539 e1540 r1541 w1542 s1543 mod1544 chi-sequence1161) (if (memv t1545 (quote (eval-when-form))) ((lambda (tmp1554) ((lambda (tmp1555) (if tmp1555 (apply (lambda (_1556 x1557 e11558 e21559) (let ((when-list1560 (chi-when-list1164 e1540 x1557 w1542))) (if (memq (quote eval) when-list1560) (chi-sequence1161 (cons e11558 e21559) r1541 w1542 s1543 mod1544) (chi-void1175)))) tmp1555) (syntax-error tmp1554))) (syntax-dispatch tmp1554 (quote (any each-any any . each-any))))) e1540) (if (memv t1545 (quote (define-form define-syntax-form))) (syntax-error (wrap1159 value1539 w1542 mod1544) "invalid context for definition of") (if (memv t1545 (quote (syntax))) (syntax-error (source-wrap1160 e1540 w1542 s1543 mod1544) "reference to pattern variable outside syntax form") (if (memv t1545 (quote (displaced-lexical))) (syntax-error (source-wrap1160 e1540 w1542 s1543 mod1544) "reference to identifier outside its scope") (syntax-error (source-wrap1160 e1540 w1542 s1543 mod1544))))))))))))))))))) (chi1167 (lambda (e1563 r1564 w1565 mod1566) (call-with-values (lambda () (syntax-type1165 e1563 r1564 w1565 #f #f mod1566)) (lambda (type1567 value1568 e1569 w1570 s1571 mod1572) (chi-expr1168 type1567 value1568 e1569 r1564 w1570 s1571 mod1572))))) (chi-top1166 (lambda (e1573 r1574 w1575 m1576 esew1577 mod1578) (call-with-values (lambda () (syntax-type1165 e1573 r1574 w1575 #f #f mod1578)) (lambda (type1586 value1587 e1588 w1589 s1590 mod1591) (let ((t1592 type1586)) (if (memv t1592 (quote (begin-form))) ((lambda (tmp1593) ((lambda (tmp1594) (if tmp1594 (apply (lambda (_1595) (chi-void1175)) tmp1594) ((lambda (tmp1596) (if tmp1596 (apply (lambda (_1597 e11598 e21599) (chi-top-sequence1162 (cons e11598 e21599) r1574 w1589 s1590 m1576 esew1577 mod1591)) tmp1596) (syntax-error tmp1593))) (syntax-dispatch tmp1593 (quote (any any . each-any)))))) (syntax-dispatch tmp1593 (quote (any))))) e1588) (if (memv t1592 (quote (local-syntax-form))) (chi-local-syntax1173 value1587 e1588 r1574 w1589 s1590 mod1591 (lambda (body1601 r1602 w1603 s1604 mod1605) (chi-top-sequence1162 body1601 r1602 w1603 s1604 m1576 esew1577 mod1605))) (if (memv t1592 (quote (eval-when-form))) ((lambda (tmp1606) ((lambda (tmp1607) (if tmp1607 (apply (lambda (_1608 x1609 e11610 e21611) (let ((when-list1612 (chi-when-list1164 e1588 x1609 w1589)) (body1613 (cons e11610 e21611))) (cond ((eq? m1576 (quote e)) (if (memq (quote eval) when-list1612) (chi-top-sequence1162 body1613 r1574 w1589 s1590 (quote e) (quote (eval)) mod1591) (chi-void1175))) ((memq (quote load) when-list1612) (if (or (memq (quote compile) when-list1612) (and (eq? m1576 (quote c&e)) (memq (quote eval) when-list1612))) (chi-top-sequence1162 body1613 r1574 w1589 s1590 (quote c&e) (quote (compile load)) mod1591) (if (memq m1576 (quote (c c&e))) (chi-top-sequence1162 body1613 r1574 w1589 s1590 (quote c) (quote (load)) mod1591) (chi-void1175)))) ((or (memq (quote compile) when-list1612) (and (eq? m1576 (quote c&e)) (memq (quote eval) when-list1612))) (top-level-eval-hook1102 (chi-top-sequence1162 body1613 r1574 w1589 s1590 (quote e) (quote (eval)) mod1591) mod1591) (chi-void1175)) (else (chi-void1175))))) tmp1607) (syntax-error tmp1606))) (syntax-dispatch tmp1606 (quote (any each-any any . each-any))))) e1588) (if (memv t1592 (quote (define-syntax-form))) (let ((n1616 (id-var-name1153 value1587 w1589)) (r1617 (macros-only-env1127 r1574))) (let ((t1618 m1576)) (if (memv t1618 (quote (c))) (if (memq (quote compile) esew1577) (let ((e1619 (chi-install-global1163 n1616 (chi1167 e1588 r1617 w1589 mod1591)))) (begin (top-level-eval-hook1102 e1619 mod1591) (if (memq (quote load) esew1577) e1619 (chi-void1175)))) (if (memq (quote load) esew1577) (chi-install-global1163 n1616 (chi1167 e1588 r1617 w1589 mod1591)) (chi-void1175))) (if (memv t1618 (quote (c&e))) (let ((e1620 (chi-install-global1163 n1616 (chi1167 e1588 r1617 w1589 mod1591)))) (begin (top-level-eval-hook1102 e1620 mod1591) e1620)) (begin (if (memq (quote eval) esew1577) (top-level-eval-hook1102 (chi-install-global1163 n1616 (chi1167 e1588 r1617 w1589 mod1591)) mod1591)) (chi-void1175)))))) (if (memv t1592 (quote (define-form))) (let ((n1621 (id-var-name1153 value1587 w1589))) (let ((type1622 (binding-type1123 (lookup1128 n1621 r1574 mod1591)))) (let ((t1623 type1622)) (if (memv t1623 (quote (global))) (let ((x1624 (build-annotated1108 s1590 (list (quote define) n1621 (chi1167 e1588 r1574 w1589 mod1591))))) (begin (if (eq? m1576 (quote c&e)) (top-level-eval-hook1102 x1624 mod1591)) x1624)) (if (memv t1623 (quote (displaced-lexical))) (syntax-error (wrap1159 value1587 w1589 mod1591) "identifier out of context") (if (memv t1623 (quote (core macro module-ref))) (begin (remove-global-definition-hook1106 n1621 mod1591) (let ((x1625 (build-annotated1108 s1590 (list (quote define) n1621 (chi1167 e1588 r1574 w1589 mod1591))))) (begin (if (eq? m1576 (quote c&e)) (top-level-eval-hook1102 x1625 mod1591)) x1625))) (syntax-error (wrap1159 value1587 w1589 mod1591) "cannot define keyword at top level"))))))) (let ((x1626 (chi-expr1168 type1586 value1587 e1588 r1574 w1589 s1590 mod1591))) (begin (if (eq? m1576 (quote c&e)) (top-level-eval-hook1102 x1626 mod1591)) x1626)))))))))))) (syntax-type1165 (lambda (e1627 r1628 w1629 s1630 rib1631 mod1632) (cond ((symbol? e1627) (let ((n1633 (id-var-name1153 e1627 w1629))) (let ((b1634 (lookup1128 n1633 r1628 mod1632))) (let ((type1635 (binding-type1123 b1634))) (let ((t1636 type1635)) (if (memv t1636 (quote (lexical))) (values type1635 (binding-value1124 b1634) e1627 w1629 s1630 mod1632) (if (memv t1636 (quote (global))) (values type1635 n1633 e1627 w1629 s1630 mod1632) (if (memv t1636 (quote (macro))) (syntax-type1165 (chi-macro1170 (binding-value1124 b1634) e1627 r1628 w1629 rib1631 mod1632) r1628 (quote (())) s1630 rib1631 mod1632) (values type1635 (binding-value1124 b1634) e1627 w1629 s1630 mod1632))))))))) ((pair? e1627) (let ((first1637 (car e1627))) (if (id?1131 first1637) (let ((n1638 (id-var-name1153 first1637 w1629))) (let ((b1639 (lookup1128 n1638 r1628 (or (and (syntax-object?1115 first1637) (syntax-object-module1118 first1637)) mod1632)))) (let ((type1640 (binding-type1123 b1639))) (let ((t1641 type1640)) (if (memv t1641 (quote (lexical))) (values (quote lexical-call) (binding-value1124 b1639) e1627 w1629 s1630 mod1632) (if (memv t1641 (quote (global))) (values (quote global-call) n1638 e1627 w1629 s1630 mod1632) (if (memv t1641 (quote (macro))) (syntax-type1165 (chi-macro1170 (binding-value1124 b1639) e1627 r1628 w1629 rib1631 mod1632) r1628 (quote (())) s1630 rib1631 mod1632) (if (memv t1641 (quote (core external-macro module-ref))) (values type1640 (binding-value1124 b1639) e1627 w1629 s1630 mod1632) (if (memv t1641 (quote (local-syntax))) (values (quote local-syntax-form) (binding-value1124 b1639) e1627 w1629 s1630 mod1632) (if (memv t1641 (quote (begin))) (values (quote begin-form) #f e1627 w1629 s1630 mod1632) (if (memv t1641 (quote (eval-when))) (values (quote eval-when-form) #f e1627 w1629 s1630 mod1632) (if (memv t1641 (quote (define))) ((lambda (tmp1642) ((lambda (tmp1643) (if (if tmp1643 (apply (lambda (_1644 name1645 val1646) (id?1131 name1645)) tmp1643) #f) (apply (lambda (_1647 name1648 val1649) (values (quote define-form) name1648 val1649 w1629 s1630 mod1632)) tmp1643) ((lambda (tmp1650) (if (if tmp1650 (apply (lambda (_1651 name1652 args1653 e11654 e21655) (and (id?1131 name1652) (valid-bound-ids?1156 (lambda-var-list1180 args1653)))) tmp1650) #f) (apply (lambda (_1656 name1657 args1658 e11659 e21660) (values (quote define-form) (wrap1159 name1657 w1629 mod1632) (cons (quote #(syntax-object lambda ((top) #(ribcage #(_ name args e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (guile))) (wrap1159 (cons args1658 (cons e11659 e21660)) w1629 mod1632)) (quote (())) s1630 mod1632)) tmp1650) ((lambda (tmp1662) (if (if tmp1662 (apply (lambda (_1663 name1664) (id?1131 name1664)) tmp1662) #f) (apply (lambda (_1665 name1666) (values (quote define-form) (wrap1159 name1666 w1629 mod1632) (quote (#(syntax-object void ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (guile)))) (quote (())) s1630 mod1632)) tmp1662) (syntax-error tmp1642))) (syntax-dispatch tmp1642 (quote (any any)))))) (syntax-dispatch tmp1642 (quote (any (any . any) any . each-any)))))) (syntax-dispatch tmp1642 (quote (any any any))))) e1627) (if (memv t1641 (quote (define-syntax))) ((lambda (tmp1667) ((lambda (tmp1668) (if (if tmp1668 (apply (lambda (_1669 name1670 val1671) (id?1131 name1670)) tmp1668) #f) (apply (lambda (_1672 name1673 val1674) (values (quote define-syntax-form) name1673 val1674 w1629 s1630 mod1632)) tmp1668) (syntax-error tmp1667))) (syntax-dispatch tmp1667 (quote (any any any))))) e1627) (values (quote call) #f e1627 w1629 s1630 mod1632)))))))))))))) (values (quote call) #f e1627 w1629 s1630 mod1632)))) ((syntax-object?1115 e1627) (syntax-type1165 (syntax-object-expression1116 e1627) r1628 (join-wraps1150 w1629 (syntax-object-wrap1117 e1627)) #f rib1631 (or (syntax-object-module1118 e1627) mod1632))) ((annotation? e1627) (syntax-type1165 (annotation-expression e1627) r1628 w1629 (annotation-source e1627) rib1631 mod1632)) ((self-evaluating? e1627) (values (quote constant) #f e1627 w1629 s1630 mod1632)) (else (values (quote other) #f e1627 w1629 s1630 mod1632))))) (chi-when-list1164 (lambda (e1675 when-list1676 w1677) (let f1678 ((when-list1679 when-list1676) (situations1680 (quote ()))) (if (null? when-list1679) situations1680 (f1678 (cdr when-list1679) (cons (let ((x1681 (car when-list1679))) (cond ((free-id=?1154 x1681 (quote #(syntax-object compile ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (guile)))) (quote compile)) ((free-id=?1154 x1681 (quote #(syntax-object load ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (guile)))) (quote load)) ((free-id=?1154 x1681 (quote #(syntax-object eval ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (guile)))) (quote eval)) (else (syntax-error (wrap1159 x1681 w1677 #f) "invalid eval-when situation")))) situations1680)))))) (chi-install-global1163 (lambda (name1682 e1683) (build-annotated1108 #f (list (build-annotated1108 #f (quote install-global-transformer)) (build-data1109 #f name1682) e1683)))) (chi-top-sequence1162 (lambda (body1684 r1685 w1686 s1687 m1688 esew1689 mod1690) (build-sequence1110 s1687 (let dobody1691 ((body1692 body1684) (r1693 r1685) (w1694 w1686) (m1695 m1688) (esew1696 esew1689) (mod1697 mod1690)) (if (null? body1692) (quote ()) (let ((first1698 (chi-top1166 (car body1692) r1693 w1694 m1695 esew1696 mod1697))) (cons first1698 (dobody1691 (cdr body1692) r1693 w1694 m1695 esew1696 mod1697)))))))) (chi-sequence1161 (lambda (body1699 r1700 w1701 s1702 mod1703) (build-sequence1110 s1702 (let dobody1704 ((body1705 body1699) (r1706 r1700) (w1707 w1701) (mod1708 mod1703)) (if (null? body1705) (quote ()) (let ((first1709 (chi1167 (car body1705) r1706 w1707 mod1708))) (cons first1709 (dobody1704 (cdr body1705) r1706 w1707 mod1708)))))))) (source-wrap1160 (lambda (x1710 w1711 s1712 defmod1713) (wrap1159 (if s1712 (make-annotation x1710 s1712 #f) x1710) w1711 defmod1713))) (wrap1159 (lambda (x1714 w1715 defmod1716) (cond ((and (null? (wrap-marks1134 w1715)) (null? (wrap-subst1135 w1715))) x1714) ((syntax-object?1115 x1714) (make-syntax-object1114 (syntax-object-expression1116 x1714) (join-wraps1150 w1715 (syntax-object-wrap1117 x1714)) (syntax-object-module1118 x1714))) ((null? x1714) x1714) (else (make-syntax-object1114 x1714 w1715 defmod1716))))) (bound-id-member?1158 (lambda (x1717 list1718) (and (not (null? list1718)) (or (bound-id=?1155 x1717 (car list1718)) (bound-id-member?1158 x1717 (cdr list1718)))))) (distinct-bound-ids?1157 (lambda (ids1719) (let distinct?1720 ((ids1721 ids1719)) (or (null? ids1721) (and (not (bound-id-member?1158 (car ids1721) (cdr ids1721))) (distinct?1720 (cdr ids1721))))))) (valid-bound-ids?1156 (lambda (ids1722) (and (let all-ids?1723 ((ids1724 ids1722)) (or (null? ids1724) (and (id?1131 (car ids1724)) (all-ids?1723 (cdr ids1724))))) (distinct-bound-ids?1157 ids1722)))) (bound-id=?1155 (lambda (i1725 j1726) (if (and (syntax-object?1115 i1725) (syntax-object?1115 j1726)) (and (eq? (let ((e1727 (syntax-object-expression1116 i1725))) (if (annotation? e1727) (annotation-expression e1727) e1727)) (let ((e1728 (syntax-object-expression1116 j1726))) (if (annotation? e1728) (annotation-expression e1728) e1728))) (same-marks?1152 (wrap-marks1134 (syntax-object-wrap1117 i1725)) (wrap-marks1134 (syntax-object-wrap1117 j1726)))) (eq? (let ((e1729 i1725)) (if (annotation? e1729) (annotation-expression e1729) e1729)) (let ((e1730 j1726)) (if (annotation? e1730) (annotation-expression e1730) e1730)))))) (free-id=?1154 (lambda (i1731 j1732) (and (eq? (let ((x1733 i1731)) (let ((e1734 (if (syntax-object?1115 x1733) (syntax-object-expression1116 x1733) x1733))) (if (annotation? e1734) (annotation-expression e1734) e1734))) (let ((x1735 j1732)) (let ((e1736 (if (syntax-object?1115 x1735) (syntax-object-expression1116 x1735) x1735))) (if (annotation? e1736) (annotation-expression e1736) e1736)))) (eq? (id-var-name1153 i1731 (quote (()))) (id-var-name1153 j1732 (quote (()))))))) (id-var-name1153 (lambda (id1737 w1738) (letrec ((search-vector-rib1741 (lambda (sym1747 subst1748 marks1749 symnames1750 ribcage1751) (let ((n1752 (vector-length symnames1750))) (let f1753 ((i1754 0)) (cond ((fx=1100 i1754 n1752) (search1739 sym1747 (cdr subst1748) marks1749)) ((and (eq? (vector-ref symnames1750 i1754) sym1747) (same-marks?1152 marks1749 (vector-ref (ribcage-marks1141 ribcage1751) i1754))) (values (vector-ref (ribcage-labels1142 ribcage1751) i1754) marks1749)) (else (f1753 (fx+1098 i1754 1)))))))) (search-list-rib1740 (lambda (sym1755 subst1756 marks1757 symnames1758 ribcage1759) (let f1760 ((symnames1761 symnames1758) (i1762 0)) (cond ((null? symnames1761) (search1739 sym1755 (cdr subst1756) marks1757)) ((and (eq? (car symnames1761) sym1755) (same-marks?1152 marks1757 (list-ref (ribcage-marks1141 ribcage1759) i1762))) (values (list-ref (ribcage-labels1142 ribcage1759) i1762) marks1757)) (else (f1760 (cdr symnames1761) (fx+1098 i1762 1))))))) (search1739 (lambda (sym1763 subst1764 marks1765) (if (null? subst1764) (values #f marks1765) (let ((fst1766 (car subst1764))) (if (eq? fst1766 (quote shift)) (search1739 sym1763 (cdr subst1764) (cdr marks1765)) (let ((symnames1767 (ribcage-symnames1140 fst1766))) (if (vector? symnames1767) (search-vector-rib1741 sym1763 subst1764 marks1765 symnames1767 fst1766) (search-list-rib1740 sym1763 subst1764 marks1765 symnames1767 fst1766))))))))) (cond ((symbol? id1737) (or (call-with-values (lambda () (search1739 id1737 (wrap-subst1135 w1738) (wrap-marks1134 w1738))) (lambda (x1769 . ignore1768) x1769)) id1737)) ((syntax-object?1115 id1737) (let ((id1770 (let ((e1772 (syntax-object-expression1116 id1737))) (if (annotation? e1772) (annotation-expression e1772) e1772))) (w11771 (syntax-object-wrap1117 id1737))) (let ((marks1773 (join-marks1151 (wrap-marks1134 w1738) (wrap-marks1134 w11771)))) (call-with-values (lambda () (search1739 id1770 (wrap-subst1135 w1738) marks1773)) (lambda (new-id1774 marks1775) (or new-id1774 (call-with-values (lambda () (search1739 id1770 (wrap-subst1135 w11771) marks1775)) (lambda (x1777 . ignore1776) x1777)) id1770)))))) ((annotation? id1737) (let ((id1778 (let ((e1779 id1737)) (if (annotation? e1779) (annotation-expression e1779) e1779)))) (or (call-with-values (lambda () (search1739 id1778 (wrap-subst1135 w1738) (wrap-marks1134 w1738))) (lambda (x1781 . ignore1780) x1781)) id1778))) (else (error-hook1104 (quote id-var-name) "invalid id" id1737)))))) (same-marks?1152 (lambda (x1782 y1783) (or (eq? x1782 y1783) (and (not (null? x1782)) (not (null? y1783)) (eq? (car x1782) (car y1783)) (same-marks?1152 (cdr x1782) (cdr y1783)))))) (join-marks1151 (lambda (m11784 m21785) (smart-append1149 m11784 m21785))) (join-wraps1150 (lambda (w11786 w21787) (let ((m11788 (wrap-marks1134 w11786)) (s11789 (wrap-subst1135 w11786))) (if (null? m11788) (if (null? s11789) w21787 (make-wrap1133 (wrap-marks1134 w21787) (smart-append1149 s11789 (wrap-subst1135 w21787)))) (make-wrap1133 (smart-append1149 m11788 (wrap-marks1134 w21787)) (smart-append1149 s11789 (wrap-subst1135 w21787))))))) (smart-append1149 (lambda (m11790 m21791) (if (null? m21791) m11790 (append m11790 m21791)))) (make-binding-wrap1148 (lambda (ids1792 labels1793 w1794) (if (null? ids1792) w1794 (make-wrap1133 (wrap-marks1134 w1794) (cons (let ((labelvec1795 (list->vector labels1793))) (let ((n1796 (vector-length labelvec1795))) (let ((symnamevec1797 (make-vector n1796)) (marksvec1798 (make-vector n1796))) (begin (let f1799 ((ids1800 ids1792) (i1801 0)) (if (not (null? ids1800)) (call-with-values (lambda () (id-sym-name&marks1132 (car ids1800) w1794)) (lambda (symname1802 marks1803) (begin (vector-set! symnamevec1797 i1801 symname1802) (vector-set! marksvec1798 i1801 marks1803) (f1799 (cdr ids1800) (fx+1098 i1801 1))))))) (make-ribcage1138 symnamevec1797 marksvec1798 labelvec1795))))) (wrap-subst1135 w1794)))))) (extend-ribcage!1147 (lambda (ribcage1804 id1805 label1806) (begin (set-ribcage-symnames!1143 ribcage1804 (cons (let ((e1807 (syntax-object-expression1116 id1805))) (if (annotation? e1807) (annotation-expression e1807) e1807)) (ribcage-symnames1140 ribcage1804))) (set-ribcage-marks!1144 ribcage1804 (cons (wrap-marks1134 (syntax-object-wrap1117 id1805)) (ribcage-marks1141 ribcage1804))) (set-ribcage-labels!1145 ribcage1804 (cons label1806 (ribcage-labels1142 ribcage1804)))))) (anti-mark1146 (lambda (w1808) (make-wrap1133 (cons #f (wrap-marks1134 w1808)) (cons (quote shift) (wrap-subst1135 w1808))))) (set-ribcage-labels!1145 (lambda (x1809 update1810) (vector-set! x1809 3 update1810))) (set-ribcage-marks!1144 (lambda (x1811 update1812) (vector-set! x1811 2 update1812))) (set-ribcage-symnames!1143 (lambda (x1813 update1814) (vector-set! x1813 1 update1814))) (ribcage-labels1142 (lambda (x1815) (vector-ref x1815 3))) (ribcage-marks1141 (lambda (x1816) (vector-ref x1816 2))) (ribcage-symnames1140 (lambda (x1817) (vector-ref x1817 1))) (ribcage?1139 (lambda (x1818) (and (vector? x1818) (= (vector-length x1818) 4) (eq? (vector-ref x1818 0) (quote ribcage))))) (make-ribcage1138 (lambda (symnames1819 marks1820 labels1821) (vector (quote ribcage) symnames1819 marks1820 labels1821))) (gen-labels1137 (lambda (ls1822) (if (null? ls1822) (quote ()) (cons (gen-label1136) (gen-labels1137 (cdr ls1822)))))) (gen-label1136 (lambda () (string #\i))) (wrap-subst1135 cdr) (wrap-marks1134 car) (make-wrap1133 cons) (id-sym-name&marks1132 (lambda (x1823 w1824) (if (syntax-object?1115 x1823) (values (let ((e1825 (syntax-object-expression1116 x1823))) (if (annotation? e1825) (annotation-expression e1825) e1825)) (join-marks1151 (wrap-marks1134 w1824) (wrap-marks1134 (syntax-object-wrap1117 x1823)))) (values (let ((e1826 x1823)) (if (annotation? e1826) (annotation-expression e1826) e1826)) (wrap-marks1134 w1824))))) (id?1131 (lambda (x1827) (cond ((symbol? x1827) #t) ((syntax-object?1115 x1827) (symbol? (let ((e1828 (syntax-object-expression1116 x1827))) (if (annotation? e1828) (annotation-expression e1828) e1828)))) ((annotation? x1827) (symbol? (annotation-expression x1827))) (else #f)))) (nonsymbol-id?1130 (lambda (x1829) (and (syntax-object?1115 x1829) (symbol? (let ((e1830 (syntax-object-expression1116 x1829))) (if (annotation? e1830) (annotation-expression e1830) e1830)))))) (global-extend1129 (lambda (type1831 sym1832 val1833) (put-global-definition-hook1105 sym1832 (cons type1831 val1833) (module-name (current-module))))) (lookup1128 (lambda (x1834 r1835 mod1836) (cond ((assq x1834 r1835) => cdr) ((symbol? x1834) (or (get-global-definition-hook1107 x1834 mod1836) (quote (global)))) (else (quote (displaced-lexical)))))) (macros-only-env1127 (lambda (r1837) (if (null? r1837) (quote ()) (let ((a1838 (car r1837))) (if (eq? (cadr a1838) (quote macro)) (cons a1838 (macros-only-env1127 (cdr r1837))) (macros-only-env1127 (cdr r1837))))))) (extend-var-env1126 (lambda (labels1839 vars1840 r1841) (if (null? labels1839) r1841 (extend-var-env1126 (cdr labels1839) (cdr vars1840) (cons (cons (car labels1839) (cons (quote lexical) (car vars1840))) r1841))))) (extend-env1125 (lambda (labels1842 bindings1843 r1844) (if (null? labels1842) r1844 (extend-env1125 (cdr labels1842) (cdr bindings1843) (cons (cons (car labels1842) (car bindings1843)) r1844))))) (binding-value1124 cdr) (binding-type1123 car) (source-annotation1122 (lambda (x1845) (cond ((annotation? x1845) (annotation-source x1845)) ((syntax-object?1115 x1845) (source-annotation1122 (syntax-object-expression1116 x1845))) (else #f)))) (set-syntax-object-module!1121 (lambda (x1846 update1847) (vector-set! x1846 3 update1847))) (set-syntax-object-wrap!1120 (lambda (x1848 update1849) (vector-set! x1848 2 update1849))) (set-syntax-object-expression!1119 (lambda (x1850 update1851) (vector-set! x1850 1 update1851))) (syntax-object-module1118 (lambda (x1852) (vector-ref x1852 3))) (syntax-object-wrap1117 (lambda (x1853) (vector-ref x1853 2))) (syntax-object-expression1116 (lambda (x1854) (vector-ref x1854 1))) (syntax-object?1115 (lambda (x1855) (and (vector? x1855) (= (vector-length x1855) 4) (eq? (vector-ref x1855 0) (quote syntax-object))))) (make-syntax-object1114 (lambda (expression1856 wrap1857 module1858) (vector (quote syntax-object) expression1856 wrap1857 module1858))) (build-letrec1113 (lambda (src1859 vars1860 val-exps1861 body-exp1862) (if (null? vars1860) (build-annotated1108 src1859 body-exp1862) (build-annotated1108 src1859 (list (quote letrec) (map list vars1860 val-exps1861) body-exp1862))))) (build-named-let1112 (lambda (src1863 vars1864 val-exps1865 body-exp1866) (if (null? vars1864) (build-annotated1108 src1863 body-exp1866) (build-annotated1108 src1863 (list (quote let) (car vars1864) (map list (cdr vars1864) val-exps1865) body-exp1866))))) (build-let1111 (lambda (src1867 vars1868 val-exps1869 body-exp1870) (if (null? vars1868) (build-annotated1108 src1867 body-exp1870) (build-annotated1108 src1867 (list (quote let) (map list vars1868 val-exps1869) body-exp1870))))) (build-sequence1110 (lambda (src1871 exps1872) (if (null? (cdr exps1872)) (build-annotated1108 src1871 (car exps1872)) (build-annotated1108 src1871 (cons (quote begin) exps1872))))) (build-data1109 (lambda (src1873 exp1874) (if (and (self-evaluating? exp1874) (not (vector? exp1874))) (build-annotated1108 src1873 exp1874) (build-annotated1108 src1873 (list (quote quote) exp1874))))) (build-annotated1108 (lambda (src1875 exp1876) (if (and src1875 (not (annotation? exp1876))) (make-annotation exp1876 src1875 #t) exp1876))) (get-global-definition-hook1107 (lambda (symbol1877 module1878) (let ((module1879 (if module1878 (resolve-module module1878) (let ((mod1880 (current-module))) (begin (if mod1880 (warn "wha" symbol1877)) mod1880))))) (let ((v1881 (module-variable module1879 symbol1877))) (and v1881 (or (object-property v1881 (quote *sc-expander*)) (and (variable-bound? v1881) (macro? (variable-ref v1881)) (macro-transformer (variable-ref v1881)) guile-macro))))))) (remove-global-definition-hook1106 (lambda (symbol1882 modname1883) (let ((module1884 (if modname1883 (resolve-module modname1883) (current-module)))) (let ((v1885 (module-local-variable module1884 symbol1882))) (if v1885 (let ((p1886 (assq (quote *sc-expander*) (object-properties v1885)))) (set-object-properties! v1885 (delq p1886 (object-properties v1885))))))))) (put-global-definition-hook1105 (lambda (symbol1887 binding1888 modname1889) (let ((module1890 (if modname1889 (resolve-module modname1889) (current-module)))) (let ((v1891 (or (module-variable module1890 symbol1887) (let ((v1892 (make-variable (gensym)))) (begin (module-add! module1890 symbol1887 v1892) v1892))))) (begin (if (not (variable-bound? v1891)) (variable-set! v1891 (gensym))) (set-object-property! v1891 (quote *sc-expander*) binding1888)))))) (error-hook1104 (lambda (who1893 why1894 what1895) (error who1893 "~a ~s" why1894 what1895))) (local-eval-hook1103 (lambda (x1896 mod1897) (eval (list noexpand1097 x1896) (if mod1897 (resolve-module mod1897) (interaction-environment))))) (top-level-eval-hook1102 (lambda (x1898 mod1899) (eval (list noexpand1097 x1898) (if mod1899 (resolve-module mod1899) (interaction-environment))))) (fx<1101 <) (fx=1100 =) (fx-1099 -) (fx+1098 +) (noexpand1097 "noexpand")) (begin (global-extend1129 (quote local-syntax) (quote letrec-syntax) #t) (global-extend1129 (quote local-syntax) (quote let-syntax) #f) (global-extend1129 (quote core) (quote fluid-let-syntax) (lambda (e1900 r1901 w1902 s1903 mod1904) ((lambda (tmp1905) ((lambda (tmp1906) (if (if tmp1906 (apply (lambda (_1907 var1908 val1909 e11910 e21911) (valid-bound-ids?1156 var1908)) tmp1906) #f) (apply (lambda (_1913 var1914 val1915 e11916 e21917) (let ((names1918 (map (lambda (x1919) (id-var-name1153 x1919 w1902)) var1914))) (begin (for-each (lambda (id1921 n1922) (let ((t1923 (binding-type1123 (lookup1128 n1922 r1901 mod1904)))) (if (memv t1923 (quote (displaced-lexical))) (syntax-error (source-wrap1160 id1921 w1902 s1903 mod1904) "identifier out of context")))) var1914 names1918) (chi-body1171 (cons e11916 e21917) (source-wrap1160 e1900 w1902 s1903 mod1904) (extend-env1125 names1918 (let ((trans-r1926 (macros-only-env1127 r1901))) (map (lambda (x1927) (cons (quote macro) (eval-local-transformer1174 (chi1167 x1927 trans-r1926 w1902 mod1904) mod1904))) val1915)) r1901) w1902 mod1904)))) tmp1906) ((lambda (_1929) (syntax-error (source-wrap1160 e1900 w1902 s1903 mod1904))) tmp1905))) (syntax-dispatch tmp1905 (quote (any #(each (any any)) any . each-any))))) e1900))) (global-extend1129 (quote core) (quote quote) (lambda (e1930 r1931 w1932 s1933 mod1934) ((lambda (tmp1935) ((lambda (tmp1936) (if tmp1936 (apply (lambda (_1937 e1938) (build-data1109 s1933 (strip1178 e1938 w1932))) tmp1936) ((lambda (_1939) (syntax-error (source-wrap1160 e1930 w1932 s1933 mod1934))) tmp1935))) (syntax-dispatch tmp1935 (quote (any any))))) e1930))) (global-extend1129 (quote core) (quote syntax) (letrec ((regen1947 (lambda (x1948) (let ((t1949 (car x1948))) (if (memv t1949 (quote (ref))) (build-annotated1108 #f (cadr x1948)) (if (memv t1949 (quote (primitive))) (build-annotated1108 #f (cadr x1948)) (if (memv t1949 (quote (quote))) (build-data1109 #f (cadr x1948)) (if (memv t1949 (quote (lambda))) (build-annotated1108 #f (list (quote lambda) (cadr x1948) (regen1947 (caddr x1948)))) (if (memv t1949 (quote (map))) (let ((ls1950 (map regen1947 (cdr x1948)))) (build-annotated1108 #f (cons (if (fx=1100 (length ls1950) 2) (build-annotated1108 #f (quote map)) (build-annotated1108 #f (quote map))) ls1950))) (build-annotated1108 #f (cons (build-annotated1108 #f (car x1948)) (map regen1947 (cdr x1948)))))))))))) (gen-vector1946 (lambda (x1951) (cond ((eq? (car x1951) (quote list)) (cons (quote vector) (cdr x1951))) ((eq? (car x1951) (quote quote)) (list (quote quote) (list->vector (cadr x1951)))) (else (list (quote list->vector) x1951))))) (gen-append1945 (lambda (x1952 y1953) (if (equal? y1953 (quote (quote ()))) x1952 (list (quote append) x1952 y1953)))) (gen-cons1944 (lambda (x1954 y1955) (let ((t1956 (car y1955))) (if (memv t1956 (quote (quote))) (if (eq? (car x1954) (quote quote)) (list (quote quote) (cons (cadr x1954) (cadr y1955))) (if (eq? (cadr y1955) (quote ())) (list (quote list) x1954) (list (quote cons) x1954 y1955))) (if (memv t1956 (quote (list))) (cons (quote list) (cons x1954 (cdr y1955))) (list (quote cons) x1954 y1955)))))) (gen-map1943 (lambda (e1957 map-env1958) (let ((formals1959 (map cdr map-env1958)) (actuals1960 (map (lambda (x1961) (list (quote ref) (car x1961))) map-env1958))) (cond ((eq? (car e1957) (quote ref)) (car actuals1960)) ((andmap (lambda (x1962) (and (eq? (car x1962) (quote ref)) (memq (cadr x1962) formals1959))) (cdr e1957)) (cons (quote map) (cons (list (quote primitive) (car e1957)) (map (let ((r1963 (map cons formals1959 actuals1960))) (lambda (x1964) (cdr (assq (cadr x1964) r1963)))) (cdr e1957))))) (else (cons (quote map) (cons (list (quote lambda) formals1959 e1957) actuals1960))))))) (gen-mappend1942 (lambda (e1965 map-env1966) (list (quote apply) (quote (primitive append)) (gen-map1943 e1965 map-env1966)))) (gen-ref1941 (lambda (src1967 var1968 level1969 maps1970) (if (fx=1100 level1969 0) (values var1968 maps1970) (if (null? maps1970) (syntax-error src1967 "missing ellipsis in syntax form") (call-with-values (lambda () (gen-ref1941 src1967 var1968 (fx-1099 level1969 1) (cdr maps1970))) (lambda (outer-var1971 outer-maps1972) (let ((b1973 (assq outer-var1971 (car maps1970)))) (if b1973 (values (cdr b1973) maps1970) (let ((inner-var1974 (gen-var1179 (quote tmp)))) (values inner-var1974 (cons (cons (cons outer-var1971 inner-var1974) (car maps1970)) outer-maps1972))))))))))) (gen-syntax1940 (lambda (src1975 e1976 r1977 maps1978 ellipsis?1979 mod1980) (if (id?1131 e1976) (let ((label1981 (id-var-name1153 e1976 (quote (()))))) (let ((b1982 (lookup1128 label1981 r1977 mod1980))) (if (eq? (binding-type1123 b1982) (quote syntax)) (call-with-values (lambda () (let ((var.lev1983 (binding-value1124 b1982))) (gen-ref1941 src1975 (car var.lev1983) (cdr var.lev1983) maps1978))) (lambda (var1984 maps1985) (values (list (quote ref) var1984) maps1985))) (if (ellipsis?1979 e1976) (syntax-error src1975 "misplaced ellipsis in syntax form") (values (list (quote quote) e1976) maps1978))))) ((lambda (tmp1986) ((lambda (tmp1987) (if (if tmp1987 (apply (lambda (dots1988 e1989) (ellipsis?1979 dots1988)) tmp1987) #f) (apply (lambda (dots1990 e1991) (gen-syntax1940 src1975 e1991 r1977 maps1978 (lambda (x1992) #f) mod1980)) tmp1987) ((lambda (tmp1993) (if (if tmp1993 (apply (lambda (x1994 dots1995 y1996) (ellipsis?1979 dots1995)) tmp1993) #f) (apply (lambda (x1997 dots1998 y1999) (let f2000 ((y2001 y1999) (k2002 (lambda (maps2003) (call-with-values (lambda () (gen-syntax1940 src1975 x1997 r1977 (cons (quote ()) maps2003) ellipsis?1979 mod1980)) (lambda (x2004 maps2005) (if (null? (car maps2005)) (syntax-error src1975 "extra ellipsis in syntax form") (values (gen-map1943 x2004 (car maps2005)) (cdr maps2005)))))))) ((lambda (tmp2006) ((lambda (tmp2007) (if (if tmp2007 (apply (lambda (dots2008 y2009) (ellipsis?1979 dots2008)) tmp2007) #f) (apply (lambda (dots2010 y2011) (f2000 y2011 (lambda (maps2012) (call-with-values (lambda () (k2002 (cons (quote ()) maps2012))) (lambda (x2013 maps2014) (if (null? (car maps2014)) (syntax-error src1975 "extra ellipsis in syntax form") (values (gen-mappend1942 x2013 (car maps2014)) (cdr maps2014)))))))) tmp2007) ((lambda (_2015) (call-with-values (lambda () (gen-syntax1940 src1975 y2001 r1977 maps1978 ellipsis?1979 mod1980)) (lambda (y2016 maps2017) (call-with-values (lambda () (k2002 maps2017)) (lambda (x2018 maps2019) (values (gen-append1945 x2018 y2016) maps2019)))))) tmp2006))) (syntax-dispatch tmp2006 (quote (any . any))))) y2001))) tmp1993) ((lambda (tmp2020) (if tmp2020 (apply (lambda (x2021 y2022) (call-with-values (lambda () (gen-syntax1940 src1975 x2021 r1977 maps1978 ellipsis?1979 mod1980)) (lambda (x2023 maps2024) (call-with-values (lambda () (gen-syntax1940 src1975 y2022 r1977 maps2024 ellipsis?1979 mod1980)) (lambda (y2025 maps2026) (values (gen-cons1944 x2023 y2025) maps2026)))))) tmp2020) ((lambda (tmp2027) (if tmp2027 (apply (lambda (e12028 e22029) (call-with-values (lambda () (gen-syntax1940 src1975 (cons e12028 e22029) r1977 maps1978 ellipsis?1979 mod1980)) (lambda (e2031 maps2032) (values (gen-vector1946 e2031) maps2032)))) tmp2027) ((lambda (_2033) (values (list (quote quote) e1976) maps1978)) tmp1986))) (syntax-dispatch tmp1986 (quote #(vector (any . each-any))))))) (syntax-dispatch tmp1986 (quote (any . any)))))) (syntax-dispatch tmp1986 (quote (any any . any)))))) (syntax-dispatch tmp1986 (quote (any any))))) e1976))))) (lambda (e2034 r2035 w2036 s2037 mod2038) (let ((e2039 (source-wrap1160 e2034 w2036 s2037 mod2038))) ((lambda (tmp2040) ((lambda (tmp2041) (if tmp2041 (apply (lambda (_2042 x2043) (call-with-values (lambda () (gen-syntax1940 e2039 x2043 r2035 (quote ()) ellipsis?1176 mod2038)) (lambda (e2044 maps2045) (regen1947 e2044)))) tmp2041) ((lambda (_2046) (syntax-error e2039)) tmp2040))) (syntax-dispatch tmp2040 (quote (any any))))) e2039))))) (global-extend1129 (quote core) (quote lambda) (lambda (e2047 r2048 w2049 s2050 mod2051) ((lambda (tmp2052) ((lambda (tmp2053) (if tmp2053 (apply (lambda (_2054 c2055) (chi-lambda-clause1172 (source-wrap1160 e2047 w2049 s2050 mod2051) c2055 r2048 w2049 mod2051 (lambda (vars2056 body2057) (build-annotated1108 s2050 (list (quote lambda) vars2056 body2057))))) tmp2053) (syntax-error tmp2052))) (syntax-dispatch tmp2052 (quote (any . any))))) e2047))) (global-extend1129 (quote core) (quote let) (letrec ((chi-let2058 (lambda (e2059 r2060 w2061 s2062 mod2063 constructor2064 ids2065 vals2066 exps2067) (if (not (valid-bound-ids?1156 ids2065)) (syntax-error e2059 "duplicate bound variable in") (let ((labels2068 (gen-labels1137 ids2065)) (new-vars2069 (map gen-var1179 ids2065))) (let ((nw2070 (make-binding-wrap1148 ids2065 labels2068 w2061)) (nr2071 (extend-var-env1126 labels2068 new-vars2069 r2060))) (constructor2064 s2062 new-vars2069 (map (lambda (x2072) (chi1167 x2072 r2060 w2061 mod2063)) vals2066) (chi-body1171 exps2067 (source-wrap1160 e2059 nw2070 s2062 mod2063) nr2071 nw2070 mod2063)))))))) (lambda (e2073 r2074 w2075 s2076 mod2077) ((lambda (tmp2078) ((lambda (tmp2079) (if tmp2079 (apply (lambda (_2080 id2081 val2082 e12083 e22084) (chi-let2058 e2073 r2074 w2075 s2076 mod2077 build-let1111 id2081 val2082 (cons e12083 e22084))) tmp2079) ((lambda (tmp2088) (if (if tmp2088 (apply (lambda (_2089 f2090 id2091 val2092 e12093 e22094) (id?1131 f2090)) tmp2088) #f) (apply (lambda (_2095 f2096 id2097 val2098 e12099 e22100) (chi-let2058 e2073 r2074 w2075 s2076 mod2077 build-named-let1112 (cons f2096 id2097) val2098 (cons e12099 e22100))) tmp2088) ((lambda (_2104) (syntax-error (source-wrap1160 e2073 w2075 s2076 mod2077))) tmp2078))) (syntax-dispatch tmp2078 (quote (any any #(each (any any)) any . each-any)))))) (syntax-dispatch tmp2078 (quote (any #(each (any any)) any . each-any))))) e2073)))) (global-extend1129 (quote core) (quote letrec) (lambda (e2105 r2106 w2107 s2108 mod2109) ((lambda (tmp2110) ((lambda (tmp2111) (if tmp2111 (apply (lambda (_2112 id2113 val2114 e12115 e22116) (let ((ids2117 id2113)) (if (not (valid-bound-ids?1156 ids2117)) (syntax-error e2105 "duplicate bound variable in") (let ((labels2119 (gen-labels1137 ids2117)) (new-vars2120 (map gen-var1179 ids2117))) (let ((w2121 (make-binding-wrap1148 ids2117 labels2119 w2107)) (r2122 (extend-var-env1126 labels2119 new-vars2120 r2106))) (build-letrec1113 s2108 new-vars2120 (map (lambda (x2123) (chi1167 x2123 r2122 w2121 mod2109)) val2114) (chi-body1171 (cons e12115 e22116) (source-wrap1160 e2105 w2121 s2108 mod2109) r2122 w2121 mod2109))))))) tmp2111) ((lambda (_2126) (syntax-error (source-wrap1160 e2105 w2107 s2108 mod2109))) tmp2110))) (syntax-dispatch tmp2110 (quote (any #(each (any any)) any . each-any))))) e2105))) (global-extend1129 (quote core) (quote set!) (lambda (e2127 r2128 w2129 s2130 mod2131) ((lambda (tmp2132) ((lambda (tmp2133) (if (if tmp2133 (apply (lambda (_2134 id2135 val2136) (id?1131 id2135)) tmp2133) #f) (apply (lambda (_2137 id2138 val2139) (let ((val2140 (chi1167 val2139 r2128 w2129 mod2131)) (n2141 (id-var-name1153 id2138 w2129))) (let ((b2142 (lookup1128 n2141 r2128 mod2131))) (let ((t2143 (binding-type1123 b2142))) (if (memv t2143 (quote (lexical))) (build-annotated1108 s2130 (list (quote set!) (binding-value1124 b2142) val2140)) (if (memv t2143 (quote (global))) (build-annotated1108 s2130 (list (quote set!) (cond ((and mod2131 (not (car mod2131))) (make-module-ref (cdr mod2131) n2141 #t)) (else (make-module-ref mod2131 n2141 #f))) val2140)) (if (memv t2143 (quote (displaced-lexical))) (syntax-error (wrap1159 id2138 w2129 mod2131) "identifier out of context") (syntax-error (source-wrap1160 e2127 w2129 s2130 mod2131))))))))) tmp2133) ((lambda (tmp2144) (if tmp2144 (apply (lambda (_2145 head2146 tail2147 val2148) (call-with-values (lambda () (syntax-type1165 head2146 r2128 (quote (())) #f #f mod2131)) (lambda (type2149 value2150 ee2151 ww2152 ss2153 modmod2154) (let ((t2155 type2149)) (if (memv t2155 (quote (module-ref))) (let ((val2156 (chi1167 val2148 r2128 w2129 mod2131))) (call-with-values (lambda () (value2150 (cons head2146 tail2147))) (lambda (id2158 mod2159) (build-annotated1108 s2130 (list (quote set!) (cond ((and mod2159 (not (car mod2159))) (make-module-ref (cdr mod2159) id2158 #t)) (else (make-module-ref mod2159 id2158 #f))) val2156))))) (build-annotated1108 s2130 (cons (chi1167 (list (quote #(syntax-object setter ((top) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type value ee ww ss modmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage #(_ head tail val) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(e r w s mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (guile))) head2146) r2128 w2129 mod2131) (map (lambda (e2160) (chi1167 e2160 r2128 w2129 mod2131)) (append tail2147 (list val2148)))))))))) tmp2144) ((lambda (_2162) (syntax-error (source-wrap1160 e2127 w2129 s2130 mod2131))) tmp2132))) (syntax-dispatch tmp2132 (quote (any (any . each-any) any)))))) (syntax-dispatch tmp2132 (quote (any any any))))) e2127))) (global-extend1129 (quote module-ref) (quote @) (lambda (e2163) ((lambda (tmp2164) ((lambda (tmp2165) (if (if tmp2165 (apply (lambda (_2166 mod2167 id2168) (and (andmap id?1131 mod2167) (id?1131 id2168))) tmp2165) #f) (apply (lambda (_2170 mod2171 id2172) (values (syntax-object->datum id2172) (syntax-object->datum (cons (quote #(syntax-object #f ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (guile))) mod2171)))) tmp2165) (syntax-error tmp2164))) (syntax-dispatch tmp2164 (quote (any each-any any))))) e2163))) (global-extend1129 (quote module-ref) (quote @@) (lambda (e2174) ((lambda (tmp2175) ((lambda (tmp2176) (if (if tmp2176 (apply (lambda (_2177 mod2178 id2179) (and (andmap id?1131 mod2178) (id?1131 id2179))) tmp2176) #f) (apply (lambda (_2181 mod2182 id2183) (values (syntax-object->datum id2183) (syntax-object->datum mod2182))) tmp2176) (syntax-error tmp2175))) (syntax-dispatch tmp2175 (quote (any each-any any))))) e2174))) (global-extend1129 (quote begin) (quote begin) (quote ())) (global-extend1129 (quote define) (quote define) (quote ())) (global-extend1129 (quote define-syntax) (quote define-syntax) (quote ())) (global-extend1129 (quote eval-when) (quote eval-when) (quote ())) (global-extend1129 (quote core) (quote syntax-case) (letrec ((gen-syntax-case2188 (lambda (x2189 keys2190 clauses2191 r2192 mod2193) (if (null? clauses2191) (build-annotated1108 #f (list (build-annotated1108 #f (quote syntax-error)) x2189)) ((lambda (tmp2194) ((lambda (tmp2195) (if tmp2195 (apply (lambda (pat2196 exp2197) (if (and (id?1131 pat2196) (andmap (lambda (x2198) (not (free-id=?1154 pat2196 x2198))) (cons (quote #(syntax-object ... ((top) #(ribcage #(pat exp) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x keys clauses r mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (gen-syntax-case gen-clause build-dispatch-call convert-pattern) ((top) (top) (top) (top)) ("i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (guile))) keys2190))) (let ((labels2199 (list (gen-label1136))) (var2200 (gen-var1179 pat2196))) (build-annotated1108 #f (list (build-annotated1108 #f (list (quote lambda) (list var2200) (chi1167 exp2197 (extend-env1125 labels2199 (list (cons (quote syntax) (cons var2200 0))) r2192) (make-binding-wrap1148 (list pat2196) labels2199 (quote (()))) mod2193))) x2189))) (gen-clause2187 x2189 keys2190 (cdr clauses2191) r2192 pat2196 #t exp2197 mod2193))) tmp2195) ((lambda (tmp2201) (if tmp2201 (apply (lambda (pat2202 fender2203 exp2204) (gen-clause2187 x2189 keys2190 (cdr clauses2191) r2192 pat2202 fender2203 exp2204 mod2193)) tmp2201) ((lambda (_2205) (syntax-error (car clauses2191) "invalid syntax-case clause")) tmp2194))) (syntax-dispatch tmp2194 (quote (any any any)))))) (syntax-dispatch tmp2194 (quote (any any))))) (car clauses2191))))) (gen-clause2187 (lambda (x2206 keys2207 clauses2208 r2209 pat2210 fender2211 exp2212 mod2213) (call-with-values (lambda () (convert-pattern2185 pat2210 keys2207)) (lambda (p2214 pvars2215) (cond ((not (distinct-bound-ids?1157 (map car pvars2215))) (syntax-error pat2210 "duplicate pattern variable in syntax-case pattern")) ((not (andmap (lambda (x2216) (not (ellipsis?1176 (car x2216)))) pvars2215)) (syntax-error pat2210 "misplaced ellipsis in syntax-case pattern")) (else (let ((y2217 (gen-var1179 (quote tmp)))) (build-annotated1108 #f (list (build-annotated1108 #f (list (quote lambda) (list y2217) (let ((y2218 (build-annotated1108 #f y2217))) (build-annotated1108 #f (list (quote if) ((lambda (tmp2219) ((lambda (tmp2220) (if tmp2220 (apply (lambda () y2218) tmp2220) ((lambda (_2221) (build-annotated1108 #f (list (quote if) y2218 (build-dispatch-call2186 pvars2215 fender2211 y2218 r2209 mod2213) (build-data1109 #f #f)))) tmp2219))) (syntax-dispatch tmp2219 (quote #(atom #t))))) fender2211) (build-dispatch-call2186 pvars2215 exp2212 y2218 r2209 mod2213) (gen-syntax-case2188 x2206 keys2207 clauses2208 r2209 mod2213)))))) (if (eq? p2214 (quote any)) (build-annotated1108 #f (list (build-annotated1108 #f (quote list)) x2206)) (build-annotated1108 #f (list (build-annotated1108 #f (quote syntax-dispatch)) x2206 (build-data1109 #f p2214))))))))))))) (build-dispatch-call2186 (lambda (pvars2222 exp2223 y2224 r2225 mod2226) (let ((ids2227 (map car pvars2222)) (levels2228 (map cdr pvars2222))) (let ((labels2229 (gen-labels1137 ids2227)) (new-vars2230 (map gen-var1179 ids2227))) (build-annotated1108 #f (list (build-annotated1108 #f (quote apply)) (build-annotated1108 #f (list (quote lambda) new-vars2230 (chi1167 exp2223 (extend-env1125 labels2229 (map (lambda (var2231 level2232) (cons (quote syntax) (cons var2231 level2232))) new-vars2230 (map cdr pvars2222)) r2225) (make-binding-wrap1148 ids2227 labels2229 (quote (()))) mod2226))) y2224)))))) (convert-pattern2185 (lambda (pattern2233 keys2234) (let cvt2235 ((p2236 pattern2233) (n2237 0) (ids2238 (quote ()))) (if (id?1131 p2236) (if (bound-id-member?1158 p2236 keys2234) (values (vector (quote free-id) p2236) ids2238) (values (quote any) (cons (cons p2236 n2237) ids2238))) ((lambda (tmp2239) ((lambda (tmp2240) (if (if tmp2240 (apply (lambda (x2241 dots2242) (ellipsis?1176 dots2242)) tmp2240) #f) (apply (lambda (x2243 dots2244) (call-with-values (lambda () (cvt2235 x2243 (fx+1098 n2237 1) ids2238)) (lambda (p2245 ids2246) (values (if (eq? p2245 (quote any)) (quote each-any) (vector (quote each) p2245)) ids2246)))) tmp2240) ((lambda (tmp2247) (if tmp2247 (apply (lambda (x2248 y2249) (call-with-values (lambda () (cvt2235 y2249 n2237 ids2238)) (lambda (y2250 ids2251) (call-with-values (lambda () (cvt2235 x2248 n2237 ids2251)) (lambda (x2252 ids2253) (values (cons x2252 y2250) ids2253)))))) tmp2247) ((lambda (tmp2254) (if tmp2254 (apply (lambda () (values (quote ()) ids2238)) tmp2254) ((lambda (tmp2255) (if tmp2255 (apply (lambda (x2256) (call-with-values (lambda () (cvt2235 x2256 n2237 ids2238)) (lambda (p2258 ids2259) (values (vector (quote vector) p2258) ids2259)))) tmp2255) ((lambda (x2260) (values (vector (quote atom) (strip1178 p2236 (quote (())))) ids2238)) tmp2239))) (syntax-dispatch tmp2239 (quote #(vector each-any)))))) (syntax-dispatch tmp2239 (quote ()))))) (syntax-dispatch tmp2239 (quote (any . any)))))) (syntax-dispatch tmp2239 (quote (any any))))) p2236)))))) (lambda (e2261 r2262 w2263 s2264 mod2265) (let ((e2266 (source-wrap1160 e2261 w2263 s2264 mod2265))) ((lambda (tmp2267) ((lambda (tmp2268) (if tmp2268 (apply (lambda (_2269 val2270 key2271 m2272) (if (andmap (lambda (x2273) (and (id?1131 x2273) (not (ellipsis?1176 x2273)))) key2271) (let ((x2275 (gen-var1179 (quote tmp)))) (build-annotated1108 s2264 (list (build-annotated1108 #f (list (quote lambda) (list x2275) (gen-syntax-case2188 (build-annotated1108 #f x2275) key2271 m2272 r2262 mod2265))) (chi1167 val2270 r2262 (quote (())) mod2265)))) (syntax-error e2266 "invalid literals list in"))) tmp2268) (syntax-error tmp2267))) (syntax-dispatch tmp2267 (quote (any any each-any . each-any))))) e2266))))) (set! sc-expand (let ((m2278 (quote e)) (esew2279 (quote (eval)))) (lambda (x2280) (if (and (pair? x2280) (equal? (car x2280) noexpand1097)) (cadr x2280) (chi-top1166 x2280 (quote ()) (quote ((top))) m2278 esew2279 (module-name (current-module))))))) (set! sc-expand3 (let ((m2281 (quote e)) (esew2282 (quote (eval)))) (lambda (x2284 . rest2283) (if (and (pair? x2284) (equal? (car x2284) noexpand1097)) (cadr x2284) (chi-top1166 x2284 (quote ()) (quote ((top))) (if (null? rest2283) m2281 (car rest2283)) (if (or (null? rest2283) (null? (cdr rest2283))) esew2282 (cadr rest2283)) (module-name (current-module))))))) (set! identifier? (lambda (x2285) (nonsymbol-id?1130 x2285))) (set! datum->syntax-object (lambda (id2286 datum2287) (make-syntax-object1114 datum2287 (syntax-object-wrap1117 id2286) #f))) (set! syntax-object->datum (lambda (x2288) (strip1178 x2288 (quote (()))))) (set! generate-temporaries (lambda (ls2289) (begin (let ((x2290 ls2289)) (if (not (list? x2290)) (error-hook1104 (quote generate-temporaries) "invalid argument" x2290))) (map (lambda (x2291) (wrap1159 (gensym) (quote ((top))) #f)) ls2289)))) (set! free-identifier=? (lambda (x2292 y2293) (begin (let ((x2294 x2292)) (if (not (nonsymbol-id?1130 x2294)) (error-hook1104 (quote free-identifier=?) "invalid argument" x2294))) (let ((x2295 y2293)) (if (not (nonsymbol-id?1130 x2295)) (error-hook1104 (quote free-identifier=?) "invalid argument" x2295))) (free-id=?1154 x2292 y2293)))) (set! bound-identifier=? (lambda (x2296 y2297) (begin (let ((x2298 x2296)) (if (not (nonsymbol-id?1130 x2298)) (error-hook1104 (quote bound-identifier=?) "invalid argument" x2298))) (let ((x2299 y2297)) (if (not (nonsymbol-id?1130 x2299)) (error-hook1104 (quote bound-identifier=?) "invalid argument" x2299))) (bound-id=?1155 x2296 y2297)))) (set! syntax-error (lambda (object2301 . messages2300) (begin (for-each (lambda (x2302) (let ((x2303 x2302)) (if (not (string? x2303)) (error-hook1104 (quote syntax-error) "invalid argument" x2303)))) messages2300) (let ((message2304 (if (null? messages2300) "invalid syntax" (apply string-append messages2300)))) (error-hook1104 #f message2304 (strip1178 object2301 (quote (())))))))) (set! install-global-transformer (lambda (sym2305 v2306) (begin (let ((x2307 sym2305)) (if (not (symbol? x2307)) (error-hook1104 (quote define-syntax) "invalid argument" x2307))) (let ((x2308 v2306)) (if (not (procedure? x2308)) (error-hook1104 (quote define-syntax) "invalid argument" x2308))) (global-extend1129 (quote macro) sym2305 v2306)))) (letrec ((match2313 (lambda (e2314 p2315 w2316 r2317 mod2318) (cond ((not r2317) #f) ((eq? p2315 (quote any)) (cons (wrap1159 e2314 w2316 mod2318) r2317)) ((syntax-object?1115 e2314) (match*2312 (let ((e2319 (syntax-object-expression1116 e2314))) (if (annotation? e2319) (annotation-expression e2319) e2319)) p2315 (join-wraps1150 w2316 (syntax-object-wrap1117 e2314)) r2317 (syntax-object-module1118 e2314))) (else (match*2312 (let ((e2320 e2314)) (if (annotation? e2320) (annotation-expression e2320) e2320)) p2315 w2316 r2317 mod2318))))) (match*2312 (lambda (e2321 p2322 w2323 r2324 mod2325) (cond ((null? p2322) (and (null? e2321) r2324)) ((pair? p2322) (and (pair? e2321) (match2313 (car e2321) (car p2322) w2323 (match2313 (cdr e2321) (cdr p2322) w2323 r2324 mod2325) mod2325))) ((eq? p2322 (quote each-any)) (let ((l2326 (match-each-any2310 e2321 w2323 mod2325))) (and l2326 (cons l2326 r2324)))) (else (let ((t2327 (vector-ref p2322 0))) (if (memv t2327 (quote (each))) (if (null? e2321) (match-empty2311 (vector-ref p2322 1) r2324) (let ((l2328 (match-each2309 e2321 (vector-ref p2322 1) w2323 mod2325))) (and l2328 (let collect2329 ((l2330 l2328)) (if (null? (car l2330)) r2324 (cons (map car l2330) (collect2329 (map cdr l2330)))))))) (if (memv t2327 (quote (free-id))) (and (id?1131 e2321) (free-id=?1154 (wrap1159 e2321 w2323 mod2325) (vector-ref p2322 1)) r2324) (if (memv t2327 (quote (atom))) (and (equal? (vector-ref p2322 1) (strip1178 e2321 w2323)) r2324) (if (memv t2327 (quote (vector))) (and (vector? e2321) (match2313 (vector->list e2321) (vector-ref p2322 1) w2323 r2324 mod2325))))))))))) (match-empty2311 (lambda (p2331 r2332) (cond ((null? p2331) r2332) ((eq? p2331 (quote any)) (cons (quote ()) r2332)) ((pair? p2331) (match-empty2311 (car p2331) (match-empty2311 (cdr p2331) r2332))) ((eq? p2331 (quote each-any)) (cons (quote ()) r2332)) (else (let ((t2333 (vector-ref p2331 0))) (if (memv t2333 (quote (each))) (match-empty2311 (vector-ref p2331 1) r2332) (if (memv t2333 (quote (free-id atom))) r2332 (if (memv t2333 (quote (vector))) (match-empty2311 (vector-ref p2331 1) r2332))))))))) (match-each-any2310 (lambda (e2334 w2335 mod2336) (cond ((annotation? e2334) (match-each-any2310 (annotation-expression e2334) w2335 mod2336)) ((pair? e2334) (let ((l2337 (match-each-any2310 (cdr e2334) w2335 mod2336))) (and l2337 (cons (wrap1159 (car e2334) w2335 mod2336) l2337)))) ((null? e2334) (quote ())) ((syntax-object?1115 e2334) (match-each-any2310 (syntax-object-expression1116 e2334) (join-wraps1150 w2335 (syntax-object-wrap1117 e2334)) mod2336)) (else #f)))) (match-each2309 (lambda (e2338 p2339 w2340 mod2341) (cond ((annotation? e2338) (match-each2309 (annotation-expression e2338) p2339 w2340 mod2341)) ((pair? e2338) (let ((first2342 (match2313 (car e2338) p2339 w2340 (quote ()) mod2341))) (and first2342 (let ((rest2343 (match-each2309 (cdr e2338) p2339 w2340 mod2341))) (and rest2343 (cons first2342 rest2343)))))) ((null? e2338) (quote ())) ((syntax-object?1115 e2338) (match-each2309 (syntax-object-expression1116 e2338) p2339 (join-wraps1150 w2340 (syntax-object-wrap1117 e2338)) (syntax-object-module1118 e2338))) (else #f))))) (begin (set! syntax-dispatch (lambda (e2344 p2345) (cond ((eq? p2345 (quote any)) (list e2344)) ((syntax-object?1115 e2344) (match*2312 (let ((e2346 (syntax-object-expression1116 e2344))) (if (annotation? e2346) (annotation-expression e2346) e2346)) p2345 (syntax-object-wrap1117 e2344) (quote ()) (syntax-object-module1118 e2344))) (else (match*2312 (let ((e2347 e2344)) (if (annotation? e2347) (annotation-expression e2347) e2347)) p2345 (quote (())) (quote ()) #f))))) (set! sc-chi chi1167)))))
(install-global-transformer (quote with-syntax) (lambda (x2348) ((lambda (tmp2349) ((lambda (tmp2350) (if tmp2350 (apply (lambda (_2351 e12352 e22353) (cons (quote #(syntax-object begin ((top) #(ribcage #(_ e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (cons e12352 e22353))) tmp2350) ((lambda (tmp2355) (if tmp2355 (apply (lambda (_2356 out2357 in2358 e12359 e22360) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) in2358 (quote ()) (list out2357 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (cons e12359 e22360))))) tmp2355) ((lambda (tmp2362) (if tmp2362 (apply (lambda (_2363 out2364 in2365 e12366 e22367) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (cons (quote #(syntax-object list ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) in2365) (quote ()) (list out2364 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (cons e12366 e22367))))) tmp2362) (syntax-error tmp2349))) (syntax-dispatch tmp2349 (quote (any #(each (any any)) any . each-any)))))) (syntax-dispatch tmp2349 (quote (any ((any any)) any . each-any)))))) (syntax-dispatch tmp2349 (quote (any () any . each-any))))) x2348)))
(install-global-transformer (quote syntax-rules) (lambda (x2371) ((lambda (tmp2372) ((lambda (tmp2373) (if tmp2373 (apply (lambda (_2374 k2375 keyword2376 pattern2377 template2378) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile)))) (cons (quote #(syntax-object syntax-case ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (cons (quote #(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (cons k2375 (map (lambda (tmp2381 tmp2380) (list (cons (quote #(syntax-object dummy ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) tmp2380) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) tmp2381))) template2378 pattern2377)))))) tmp2373) (syntax-error tmp2372))) (syntax-dispatch tmp2372 (quote (any each-any . #(each ((any . any) any))))))) x2371)))
(install-global-transformer (quote let*) (lambda (x2382) ((lambda (tmp2383) ((lambda (tmp2384) (if (if tmp2384 (apply (lambda (let*2385 x2386 v2387 e12388 e22389) (andmap identifier? x2386)) tmp2384) #f) (apply (lambda (let*2391 x2392 v2393 e12394 e22395) (let f2396 ((bindings2397 (map list x2392 v2393))) (if (null? bindings2397) (cons (quote #(syntax-object let ((top) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (cons (quote ()) (cons e12394 e22395))) ((lambda (tmp2401) ((lambda (tmp2402) (if tmp2402 (apply (lambda (body2403 binding2404) (list (quote #(syntax-object let ((top) #(ribcage #(body binding) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (list binding2404) body2403)) tmp2402) (syntax-error tmp2401))) (syntax-dispatch tmp2401 (quote (any any))))) (list (f2396 (cdr bindings2397)) (car bindings2397)))))) tmp2384) (syntax-error tmp2383))) (syntax-dispatch tmp2383 (quote (any #(each (any any)) any . each-any))))) x2382)))
(install-global-transformer (quote do) (lambda (orig-x2405) ((lambda (tmp2406) ((lambda (tmp2407) (if tmp2407 (apply (lambda (_2408 var2409 init2410 step2411 e02412 e12413 c2414) ((lambda (tmp2415) ((lambda (tmp2416) (if tmp2416 (apply (lambda (step2417) ((lambda (tmp2418) ((lambda (tmp2419) (if tmp2419 (apply (lambda () (list (quote #(syntax-object let ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (guile))) (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (guile))) (map list var2409 init2410) (list (quote #(syntax-object if ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (guile))) (list (quote #(syntax-object not ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (guile))) e02412) (cons (quote #(syntax-object begin ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (guile))) (append c2414 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (guile))) step2417))))))) tmp2419) ((lambda (tmp2424) (if tmp2424 (apply (lambda (e12425 e22426) (list (quote #(syntax-object let ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (guile))) (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (guile))) (map list var2409 init2410) (list (quote #(syntax-object if ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (guile))) e02412 (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (guile))) (cons e12425 e22426)) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (guile))) (append c2414 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (guile))) step2417))))))) tmp2424) (syntax-error tmp2418))) (syntax-dispatch tmp2418 (quote (any . each-any)))))) (syntax-dispatch tmp2418 (quote ())))) e12413)) tmp2416) (syntax-error tmp2415))) (syntax-dispatch tmp2415 (quote each-any)))) (map (lambda (v2433 s2434) ((lambda (tmp2435) ((lambda (tmp2436) (if tmp2436 (apply (lambda () v2433) tmp2436) ((lambda (tmp2437) (if tmp2437 (apply (lambda (e2438) e2438) tmp2437) ((lambda (_2439) (syntax-error orig-x2405)) tmp2435))) (syntax-dispatch tmp2435 (quote (any)))))) (syntax-dispatch tmp2435 (quote ())))) s2434)) var2409 step2411))) tmp2407) (syntax-error tmp2406))) (syntax-dispatch tmp2406 (quote (any #(each (any any . any)) (any . each-any) . each-any))))) orig-x2405)))
(install-global-transformer (quote quasiquote) (letrec ((quasicons2442 (lambda (x2446 y2447) ((lambda (tmp2448) ((lambda (tmp2449) (if tmp2449 (apply (lambda (x2450 y2451) ((lambda (tmp2452) ((lambda (tmp2453) (if tmp2453 (apply (lambda (dy2454) ((lambda (tmp2455) ((lambda (tmp2456) (if tmp2456 (apply (lambda (dx2457) (list (quote #(syntax-object quote ((top) #(ribcage #(dx) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) (cons dx2457 dy2454))) tmp2456) ((lambda (_2458) (if (null? dy2454) (list (quote #(syntax-object list ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) x2450) (list (quote #(syntax-object cons ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) x2450 y2451))) tmp2455))) (syntax-dispatch tmp2455 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) any))))) x2450)) tmp2453) ((lambda (tmp2459) (if tmp2459 (apply (lambda (stuff2460) (cons (quote #(syntax-object list ((top) #(ribcage #(stuff) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) (cons x2450 stuff2460))) tmp2459) ((lambda (else2461) (list (quote #(syntax-object cons ((top) #(ribcage #(else) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) x2450 y2451)) tmp2452))) (syntax-dispatch tmp2452 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) . any)))))) (syntax-dispatch tmp2452 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) any))))) y2451)) tmp2449) (syntax-error tmp2448))) (syntax-dispatch tmp2448 (quote (any any))))) (list x2446 y2447)))) (quasiappend2443 (lambda (x2462 y2463) ((lambda (tmp2464) ((lambda (tmp2465) (if tmp2465 (apply (lambda (x2466 y2467) ((lambda (tmp2468) ((lambda (tmp2469) (if tmp2469 (apply (lambda () x2466) tmp2469) ((lambda (_2470) (list (quote #(syntax-object append ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) x2466 y2467)) tmp2468))) (syntax-dispatch tmp2468 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) ()))))) y2467)) tmp2465) (syntax-error tmp2464))) (syntax-dispatch tmp2464 (quote (any any))))) (list x2462 y2463)))) (quasivector2444 (lambda (x2471) ((lambda (tmp2472) ((lambda (x2473) ((lambda (tmp2474) ((lambda (tmp2475) (if tmp2475 (apply (lambda (x2476) (list (quote #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) (list->vector x2476))) tmp2475) ((lambda (tmp2478) (if tmp2478 (apply (lambda (x2479) (cons (quote #(syntax-object vector ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) x2479)) tmp2478) ((lambda (_2481) (list (quote #(syntax-object list->vector ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) x2473)) tmp2474))) (syntax-dispatch tmp2474 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) . each-any)))))) (syntax-dispatch tmp2474 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) each-any))))) x2473)) tmp2472)) x2471))) (quasi2445 (lambda (p2482 lev2483) ((lambda (tmp2484) ((lambda (tmp2485) (if tmp2485 (apply (lambda (p2486) (if (= lev2483 0) p2486 (quasicons2442 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile)) #(syntax-object unquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile)))) (quasi2445 (list p2486) (- lev2483 1))))) tmp2485) ((lambda (tmp2487) (if tmp2487 (apply (lambda (p2488 q2489) (if (= lev2483 0) (quasiappend2443 p2488 (quasi2445 q2489 lev2483)) (quasicons2442 (quasicons2442 (quote (#(syntax-object quote ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile)) #(syntax-object unquote-splicing ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile)))) (quasi2445 (list p2488) (- lev2483 1))) (quasi2445 q2489 lev2483)))) tmp2487) ((lambda (tmp2490) (if tmp2490 (apply (lambda (p2491) (quasicons2442 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile)) #(syntax-object quasiquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile)))) (quasi2445 (list p2491) (+ lev2483 1)))) tmp2490) ((lambda (tmp2492) (if tmp2492 (apply (lambda (p2493 q2494) (quasicons2442 (quasi2445 p2493 lev2483) (quasi2445 q2494 lev2483))) tmp2492) ((lambda (tmp2495) (if tmp2495 (apply (lambda (x2496) (quasivector2444 (quasi2445 x2496 lev2483))) tmp2495) ((lambda (p2498) (list (quote #(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) p2498)) tmp2484))) (syntax-dispatch tmp2484 (quote #(vector each-any)))))) (syntax-dispatch tmp2484 (quote (any . any)))))) (syntax-dispatch tmp2484 (quote (#(free-id #(syntax-object quasiquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) any)))))) (syntax-dispatch tmp2484 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) any) . any)))))) (syntax-dispatch tmp2484 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (guile))) any))))) p2482)))) (lambda (x2499) ((lambda (tmp2500) ((lambda (tmp2501) (if tmp2501 (apply (lambda (_2502 e2503) (quasi2445 e2503 0)) tmp2501) (syntax-error tmp2500))) (syntax-dispatch tmp2500 (quote (any any))))) x2499))))
(install-global-transformer (quote include) (lambda (x2504) (letrec ((read-file2505 (lambda (fn2506 k2507) (let ((p2508 (open-input-file fn2506))) (let f2509 ((x2510 (read p2508))) (if (eof-object? x2510) (begin (close-input-port p2508) (quote ())) (cons (datum->syntax-object k2507 x2510) (f2509 (read p2508))))))))) ((lambda (tmp2511) ((lambda (tmp2512) (if tmp2512 (apply (lambda (k2513 filename2514) (let ((fn2515 (syntax-object->datum filename2514))) ((lambda (tmp2516) ((lambda (tmp2517) (if tmp2517 (apply (lambda (exp2518) (cons (quote #(syntax-object begin ((top) #(ribcage #(exp) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(fn) #((top)) #("i")) #(ribcage #(k filename) #((top) (top)) #("i" "i")) #(ribcage (read-file) ((top)) ("i")) #(ribcage #(x) #((top)) #("i"))) (guile))) exp2518)) tmp2517) (syntax-error tmp2516))) (syntax-dispatch tmp2516 (quote each-any)))) (read-file2505 fn2515 k2513)))) tmp2512) (syntax-error tmp2511))) (syntax-dispatch tmp2511 (quote (any any))))) x2504))))
(install-global-transformer (quote unquote) (lambda (x2520) ((lambda (tmp2521) ((lambda (tmp2522) (if tmp2522 (apply (lambda (_2523 e2524) (error (quote unquote) "expression ,~s not valid outside of quasiquote" (syntax-object->datum e2524))) tmp2522) (syntax-error tmp2521))) (syntax-dispatch tmp2521 (quote (any any))))) x2520)))
(install-global-transformer (quote unquote-splicing) (lambda (x2525) ((lambda (tmp2526) ((lambda (tmp2527) (if tmp2527 (apply (lambda (_2528 e2529) (error (quote unquote-splicing) "expression ,@~s not valid outside of quasiquote" (syntax-object->datum e2529))) tmp2527) (syntax-error tmp2526))) (syntax-dispatch tmp2526 (quote (any any))))) x2525)))
(install-global-transformer (quote case) (lambda (x2530) ((lambda (tmp2531) ((lambda (tmp2532) (if tmp2532 (apply (lambda (_2533 e2534 m12535 m22536) ((lambda (tmp2537) ((lambda (body2538) (list (quote #(syntax-object let ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (list (list (quote #(syntax-object t ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) e2534)) body2538)) tmp2537)) (let f2539 ((clause2540 m12535) (clauses2541 m22536)) (if (null? clauses2541) ((lambda (tmp2543) ((lambda (tmp2544) (if tmp2544 (apply (lambda (e12545 e22546) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (cons e12545 e22546))) tmp2544) ((lambda (tmp2548) (if tmp2548 (apply (lambda (k2549 e12550 e22551) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) k2549)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (cons e12550 e22551)))) tmp2548) ((lambda (_2554) (syntax-error x2530)) tmp2543))) (syntax-dispatch tmp2543 (quote (each-any any . each-any)))))) (syntax-dispatch tmp2543 (quote (#(free-id #(syntax-object else ((top) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) any . each-any))))) clause2540) ((lambda (tmp2555) ((lambda (rest2556) ((lambda (tmp2557) ((lambda (tmp2558) (if tmp2558 (apply (lambda (k2559 e12560 e22561) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) k2559)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (cons e12560 e22561)) rest2556)) tmp2558) ((lambda (_2564) (syntax-error x2530)) tmp2557))) (syntax-dispatch tmp2557 (quote (each-any any . each-any))))) clause2540)) tmp2555)) (f2539 (car clauses2541) (cdr clauses2541))))))) tmp2532) (syntax-error tmp2531))) (syntax-dispatch tmp2531 (quote (any any any . each-any))))) x2530)))
(install-global-transformer (quote identifier-syntax) (lambda (x2565) ((lambda (tmp2566) ((lambda (tmp2567) (if tmp2567 (apply (lambda (_2568 e2569) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile)))) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (quote #(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (quote ()) (list (quote #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (quote (#(syntax-object identifier? ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile)) (#(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile)) #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) e2569)) (list (cons _2568 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile))) (cons e2569 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (guile)))))))))) tmp2567) (syntax-error tmp2566))) (syntax-dispatch tmp2566 (quote (any any))))) x2565)))
