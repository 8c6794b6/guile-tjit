(eval-when (compile) (set-current-module (resolve-module (quote (guile)))))
(if #f #f)
(letrec ((and-map*2008 (lambda (f2048 first2047 . rest2046) (let ((t2049 (null? first2047))) (if t2049 t2049 (if (null? rest2046) (letrec ((andmap2050 (lambda (first2051) (let ((x2052 (car first2051)) (first2053 (cdr first2051))) (if (null? first2053) (f2048 x2052) (if (f2048 x2052) (andmap2050 first2053) #f)))))) (andmap2050 first2047)) (letrec ((andmap2054 (lambda (first2055 rest2056) (let ((x2057 (car first2055)) (xr2058 (map car rest2056)) (first2059 (cdr first2055)) (rest2060 (map cdr rest2056))) (if (null? first2059) (apply f2048 (cons x2057 xr2058)) (if (apply f2048 (cons x2057 xr2058)) (andmap2054 first2059 rest2060) #f)))))) (andmap2054 first2047 rest2046)))))))) (letrec ((lambda-var-list2153 (lambda (vars2282) (letrec ((lvl2283 (lambda (vars2284 ls2285 w2286) (if (pair? vars2284) (lvl2283 (cdr vars2284) (cons (wrap2132 (car vars2284) w2286 #f) ls2285) w2286) (if (id?2104 vars2284) (cons (wrap2132 vars2284 w2286 #f) ls2285) (if (null? vars2284) ls2285 (if (syntax-object?2088 vars2284) (lvl2283 (syntax-object-expression2089 vars2284) ls2285 (join-wraps2123 w2286 (syntax-object-wrap2090 vars2284))) (if (annotation? vars2284) (lvl2283 (annotation-expression vars2284) ls2285 w2286) (cons vars2284 ls2285))))))))) (lvl2283 vars2282 (quote ()) (quote (())))))) (gen-var2152 (lambda (id2287) (let ((id2288 (if (syntax-object?2088 id2287) (syntax-object-expression2089 id2287) id2287))) (if (annotation? id2288) (gensym (symbol->string (annotation-expression id2288))) (gensym (symbol->string id2288)))))) (strip2151 (lambda (x2289 w2290) (if (memq (quote top) (wrap-marks2107 w2290)) (if (let ((t2291 (annotation? x2289))) (if t2291 t2291 (if (pair? x2289) (annotation? (car x2289)) #f))) (strip-annotation2150 x2289 #f) x2289) (letrec ((f2292 (lambda (x2293) (if (syntax-object?2088 x2293) (strip2151 (syntax-object-expression2089 x2293) (syntax-object-wrap2090 x2293)) (if (pair? x2293) (let ((a2294 (f2292 (car x2293))) (d2295 (f2292 (cdr x2293)))) (if (if (eq? a2294 (car x2293)) (eq? d2295 (cdr x2293)) #f) x2293 (cons a2294 d2295))) (if (vector? x2293) (let ((old2296 (vector->list x2293))) (let ((new2297 (map f2292 old2296))) (if (and-map*2008 eq? old2296 new2297) x2293 (list->vector new2297)))) x2293)))))) (f2292 x2289))))) (strip-annotation2150 (lambda (x2298 parent2299) (if (pair? x2298) (let ((new2300 (cons #f #f))) (begin (if parent2299 (set-annotation-stripped! parent2299 new2300) (if #f #f)) (set-car! new2300 (strip-annotation2150 (car x2298) #f)) (set-cdr! new2300 (strip-annotation2150 (cdr x2298) #f)) new2300)) (if (annotation? x2298) (let ((t2301 (annotation-stripped x2298))) (if t2301 t2301 (strip-annotation2150 (annotation-expression x2298) x2298))) (if (vector? x2298) (let ((new2302 (make-vector (vector-length x2298)))) (begin (if parent2299 (set-annotation-stripped! parent2299 new2302) (if #f #f)) (letrec ((loop2303 (lambda (i2304) (unless (fx<2066 i2304 0) (vector-set! new2302 i2304 (strip-annotation2150 (vector-ref x2298 i2304) #f)) (loop2303 (fx-2064 i2304 1)))))) (loop2303 (- (vector-length x2298) 1))) new2302)) x2298))))) (ellipsis?2149 (lambda (x2305) (if (nonsymbol-id?2103 x2305) (free-id=?2127 x2305 (quote #(syntax-object ... ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) #f))) (chi-void2148 (lambda () (build-void2071 #f))) (eval-local-transformer2147 (lambda (expanded2306 mod2307) (let ((p2308 (local-eval-hook2068 expanded2306 mod2307))) (if (procedure? p2308) p2308 (syntax-violation #f "nonprocedure transformer" p2308))))) (chi-local-syntax2146 (lambda (rec?2309 e2310 r2311 w2312 s2313 mod2314 k2315) ((lambda (tmp2316) ((lambda (tmp2317) (if tmp2317 (apply (lambda (_2318 id2319 val2320 e12321 e22322) (let ((ids2323 id2319)) (if (not (valid-bound-ids?2129 ids2323)) (syntax-violation #f "duplicate bound keyword" e2310) (let ((labels2325 (gen-labels2110 ids2323))) (let ((new-w2326 (make-binding-wrap2121 ids2323 labels2325 w2312))) (k2315 (cons e12321 e22322) (extend-env2098 labels2325 (let ((w2328 (if rec?2309 new-w2326 w2312)) (trans-r2329 (macros-only-env2100 r2311))) (map (lambda (x2330) (cons (quote macro) (eval-local-transformer2147 (chi2140 x2330 trans-r2329 w2328 mod2314) mod2314))) val2320)) r2311) new-w2326 s2313 mod2314)))))) tmp2317) ((lambda (_2332) (syntax-violation #f "bad local syntax definition" (source-wrap2133 e2310 w2312 s2313 mod2314))) tmp2316))) ($sc-dispatch tmp2316 (quote (any #(each (any any)) any . each-any))))) e2310))) (chi-lambda-clause2145 (lambda (e2333 docstring2334 c2335 r2336 w2337 mod2338 k2339) ((lambda (tmp2340) ((lambda (tmp2341) (if (if tmp2341 (apply (lambda (args2342 doc2343 e12344 e22345) (if (string? (syntax->datum doc2343)) (not docstring2334) #f)) tmp2341) #f) (apply (lambda (args2346 doc2347 e12348 e22349) (chi-lambda-clause2145 e2333 doc2347 (cons args2346 (cons e12348 e22349)) r2336 w2337 mod2338 k2339)) tmp2341) ((lambda (tmp2351) (if tmp2351 (apply (lambda (id2352 e12353 e22354) (let ((ids2355 id2352)) (if (not (valid-bound-ids?2129 ids2355)) (syntax-violation (quote lambda) "invalid parameter list" e2333) (let ((labels2357 (gen-labels2110 ids2355)) (new-vars2358 (map gen-var2152 ids2355))) (k2339 (map syntax->datum ids2355) new-vars2358 docstring2334 (chi-body2144 (cons e12353 e22354) e2333 (extend-var-env2099 labels2357 new-vars2358 r2336) (make-binding-wrap2121 ids2355 labels2357 w2337) mod2338)))))) tmp2351) ((lambda (tmp2360) (if tmp2360 (apply (lambda (ids2361 e12362 e22363) (let ((old-ids2364 (lambda-var-list2153 ids2361))) (if (not (valid-bound-ids?2129 old-ids2364)) (syntax-violation (quote lambda) "invalid parameter list" e2333) (let ((labels2365 (gen-labels2110 old-ids2364)) (new-vars2366 (map gen-var2152 old-ids2364))) (k2339 (letrec ((f2367 (lambda (ls12368 ls22369) (if (null? ls12368) (syntax->datum ls22369) (f2367 (cdr ls12368) (cons (syntax->datum (car ls12368)) ls22369)))))) (f2367 (cdr old-ids2364) (car old-ids2364))) (letrec ((f2370 (lambda (ls12371 ls22372) (if (null? ls12371) ls22372 (f2370 (cdr ls12371) (cons (car ls12371) ls22372)))))) (f2370 (cdr new-vars2366) (car new-vars2366))) docstring2334 (chi-body2144 (cons e12362 e22363) e2333 (extend-var-env2099 labels2365 new-vars2366 r2336) (make-binding-wrap2121 old-ids2364 labels2365 w2337) mod2338)))))) tmp2360) ((lambda (_2374) (syntax-violation (quote lambda) "bad lambda" e2333)) tmp2340))) ($sc-dispatch tmp2340 (quote (any any . each-any)))))) ($sc-dispatch tmp2340 (quote (each-any any . each-any)))))) ($sc-dispatch tmp2340 (quote (any any any . each-any))))) c2335))) (chi-body2144 (lambda (body2375 outer-form2376 r2377 w2378 mod2379) (let ((r2380 (cons (quote ("placeholder" placeholder)) r2377))) (let ((ribcage2381 (make-ribcage2111 (quote ()) (quote ()) (quote ())))) (let ((w2382 (make-wrap2106 (wrap-marks2107 w2378) (cons ribcage2381 (wrap-subst2108 w2378))))) (letrec ((parse2383 (lambda (body2384 ids2385 labels2386 vars2387 vals2388 bindings2389) (if (null? body2384) (syntax-violation #f "no expressions in body" outer-form2376) (let ((e2391 (cdar body2384)) (er2392 (caar body2384))) (call-with-values (lambda () (syntax-type2138 e2391 er2392 (quote (())) #f ribcage2381 mod2379)) (lambda (type2393 value2394 e2395 w2396 s2397 mod2398) (if (memv type2393 (quote (define-form))) (let ((id2399 (wrap2132 value2394 w2396 mod2398)) (label2400 (gen-label2109))) (let ((var2401 (gen-var2152 id2399))) (begin (extend-ribcage!2120 ribcage2381 id2399 label2400) (parse2383 (cdr body2384) (cons id2399 ids2385) (cons label2400 labels2386) (cons var2401 vars2387) (cons (cons er2392 (wrap2132 e2395 w2396 mod2398)) vals2388) (cons (cons (quote lexical) var2401) bindings2389))))) (if (memv type2393 (quote (define-syntax-form))) (let ((id2402 (wrap2132 value2394 w2396 mod2398)) (label2403 (gen-label2109))) (begin (extend-ribcage!2120 ribcage2381 id2402 label2403) (parse2383 (cdr body2384) (cons id2402 ids2385) (cons label2403 labels2386) vars2387 vals2388 (cons (cons (quote macro) (cons er2392 (wrap2132 e2395 w2396 mod2398))) bindings2389)))) (if (memv type2393 (quote (begin-form))) ((lambda (tmp2404) ((lambda (tmp2405) (if tmp2405 (apply (lambda (_2406 e12407) (parse2383 (letrec ((f2408 (lambda (forms2409) (if (null? forms2409) (cdr body2384) (cons (cons er2392 (wrap2132 (car forms2409) w2396 mod2398)) (f2408 (cdr forms2409))))))) (f2408 e12407)) ids2385 labels2386 vars2387 vals2388 bindings2389)) tmp2405) (syntax-violation #f "source expression failed to match any pattern" tmp2404))) ($sc-dispatch tmp2404 (quote (any . each-any))))) e2395) (if (memv type2393 (quote (local-syntax-form))) (chi-local-syntax2146 value2394 e2395 er2392 w2396 s2397 mod2398 (lambda (forms2411 er2412 w2413 s2414 mod2415) (parse2383 (letrec ((f2416 (lambda (forms2417) (if (null? forms2417) (cdr body2384) (cons (cons er2412 (wrap2132 (car forms2417) w2413 mod2415)) (f2416 (cdr forms2417))))))) (f2416 forms2411)) ids2385 labels2386 vars2387 vals2388 bindings2389))) (if (null? ids2385) (build-sequence2083 #f (map (lambda (x2418) (chi2140 (cdr x2418) (car x2418) (quote (())) mod2398)) (cons (cons er2392 (source-wrap2133 e2395 w2396 s2397 mod2398)) (cdr body2384)))) (begin (if (not (valid-bound-ids?2129 ids2385)) (syntax-violation #f "invalid or duplicate identifier in definition" outer-form2376) (if #f #f)) (letrec ((loop2419 (lambda (bs2420 er-cache2421 r-cache2422) (if (not (null? bs2420)) (let ((b2423 (car bs2420))) (if (eq? (car b2423) (quote macro)) (let ((er2424 (cadr b2423))) (let ((r-cache2425 (if (eq? er2424 er-cache2421) r-cache2422 (macros-only-env2100 er2424)))) (begin (set-cdr! b2423 (eval-local-transformer2147 (chi2140 (cddr b2423) r-cache2425 (quote (())) mod2398) mod2398)) (loop2419 (cdr bs2420) er2424 r-cache2425)))) (loop2419 (cdr bs2420) er-cache2421 r-cache2422))) (if #f #f))))) (loop2419 bindings2389 #f #f)) (set-cdr! r2380 (extend-env2098 labels2386 bindings2389 (cdr r2380))) (build-letrec2086 #f (map syntax->datum ids2385) vars2387 (map (lambda (x2426) (chi2140 (cdr x2426) (car x2426) (quote (())) mod2398)) vals2388) (build-sequence2083 #f (map (lambda (x2427) (chi2140 (cdr x2427) (car x2427) (quote (())) mod2398)) (cons (cons er2392 (source-wrap2133 e2395 w2396 s2397 mod2398)) (cdr body2384)))))))))))))))))) (parse2383 (map (lambda (x2390) (cons r2380 (wrap2132 x2390 w2382 mod2379))) body2375) (quote ()) (quote ()) (quote ()) (quote ()) (quote ())))))))) (chi-macro2143 (lambda (p2428 e2429 r2430 w2431 rib2432 mod2433) (letrec ((rebuild-macro-output2434 (lambda (x2435 m2436) (if (pair? x2435) (cons (rebuild-macro-output2434 (car x2435) m2436) (rebuild-macro-output2434 (cdr x2435) m2436)) (if (syntax-object?2088 x2435) (let ((w2437 (syntax-object-wrap2090 x2435))) (let ((ms2438 (wrap-marks2107 w2437)) (s2439 (wrap-subst2108 w2437))) (if (if (pair? ms2438) (eq? (car ms2438) #f) #f) (make-syntax-object2087 (syntax-object-expression2089 x2435) (make-wrap2106 (cdr ms2438) (if rib2432 (cons rib2432 (cdr s2439)) (cdr s2439))) (syntax-object-module2091 x2435)) (make-syntax-object2087 (syntax-object-expression2089 x2435) (make-wrap2106 (cons m2436 ms2438) (if rib2432 (cons rib2432 (cons (quote shift) s2439)) (cons (quote shift) s2439))) (let ((pmod2440 (procedure-module p2428))) (if pmod2440 (cons (quote hygiene) (module-name pmod2440)) (quote (hygiene guile)))))))) (if (vector? x2435) (let ((n2441 (vector-length x2435))) (let ((v2442 (make-vector n2441))) (letrec ((loop2443 (lambda (i2444) (if (fx=2065 i2444 n2441) (begin (if #f #f (if #f #f)) v2442) (begin (vector-set! v2442 i2444 (rebuild-macro-output2434 (vector-ref x2435 i2444) m2436)) (loop2443 (fx+2063 i2444 1))))))) (loop2443 0)))) (if (symbol? x2435) (syntax-violation #f "encountered raw symbol in macro output" (source-wrap2133 e2429 w2431 s mod2433) x2435) x2435))))))) (rebuild-macro-output2434 (p2428 (wrap2132 e2429 (anti-mark2119 w2431) mod2433)) (string #\m))))) (chi-application2142 (lambda (x2445 e2446 r2447 w2448 s2449 mod2450) ((lambda (tmp2451) ((lambda (tmp2452) (if tmp2452 (apply (lambda (e02453 e12454) (build-application2072 s2449 x2445 (map (lambda (e2455) (chi2140 e2455 r2447 w2448 mod2450)) e12454))) tmp2452) (syntax-violation #f "source expression failed to match any pattern" tmp2451))) ($sc-dispatch tmp2451 (quote (any . each-any))))) e2446))) (chi-expr2141 (lambda (type2457 value2458 e2459 r2460 w2461 s2462 mod2463) (if (memv type2457 (quote (lexical))) (build-lexical-reference2074 (quote value) s2462 e2459 value2458) (if (memv type2457 (quote (core external-macro))) (value2458 e2459 r2460 w2461 s2462 mod2463) (if (memv type2457 (quote (module-ref))) (call-with-values (lambda () (value2458 e2459)) (lambda (id2464 mod2465) (build-global-reference2077 s2462 id2464 mod2465))) (if (memv type2457 (quote (lexical-call))) (chi-application2142 (build-lexical-reference2074 (quote fun) (source-annotation2095 (car e2459)) (car e2459) value2458) e2459 r2460 w2461 s2462 mod2463) (if (memv type2457 (quote (global-call))) (chi-application2142 (build-global-reference2077 (source-annotation2095 (car e2459)) value2458 (if (syntax-object?2088 (car e2459)) (syntax-object-module2091 (car e2459)) mod2463)) e2459 r2460 w2461 s2462 mod2463) (if (memv type2457 (quote (constant))) (build-data2082 s2462 (strip2151 (source-wrap2133 e2459 w2461 s2462 mod2463) (quote (())))) (if (memv type2457 (quote (global))) (build-global-reference2077 s2462 value2458 mod2463) (if (memv type2457 (quote (call))) (chi-application2142 (chi2140 (car e2459) r2460 w2461 mod2463) e2459 r2460 w2461 s2462 mod2463) (if (memv type2457 (quote (begin-form))) ((lambda (tmp2466) ((lambda (tmp2467) (if tmp2467 (apply (lambda (_2468 e12469 e22470) (chi-sequence2134 (cons e12469 e22470) r2460 w2461 s2462 mod2463)) tmp2467) (syntax-violation #f "source expression failed to match any pattern" tmp2466))) ($sc-dispatch tmp2466 (quote (any any . each-any))))) e2459) (if (memv type2457 (quote (local-syntax-form))) (chi-local-syntax2146 value2458 e2459 r2460 w2461 s2462 mod2463 chi-sequence2134) (if (memv type2457 (quote (eval-when-form))) ((lambda (tmp2472) ((lambda (tmp2473) (if tmp2473 (apply (lambda (_2474 x2475 e12476 e22477) (let ((when-list2478 (chi-when-list2137 e2459 x2475 w2461))) (if (memq (quote eval) when-list2478) (chi-sequence2134 (cons e12476 e22477) r2460 w2461 s2462 mod2463) (chi-void2148)))) tmp2473) (syntax-violation #f "source expression failed to match any pattern" tmp2472))) ($sc-dispatch tmp2472 (quote (any each-any any . each-any))))) e2459) (if (memv type2457 (quote (define-form define-syntax-form))) (syntax-violation #f "definition in expression context" e2459 (wrap2132 value2458 w2461 mod2463)) (if (memv type2457 (quote (syntax))) (syntax-violation #f "reference to pattern variable outside syntax form" (source-wrap2133 e2459 w2461 s2462 mod2463)) (if (memv type2457 (quote (displaced-lexical))) (syntax-violation #f "reference to identifier outside its scope" (source-wrap2133 e2459 w2461 s2462 mod2463)) (syntax-violation #f "unexpected syntax" (source-wrap2133 e2459 w2461 s2462 mod2463)))))))))))))))))) (chi2140 (lambda (e2481 r2482 w2483 mod2484) (call-with-values (lambda () (syntax-type2138 e2481 r2482 w2483 #f #f mod2484)) (lambda (type2485 value2486 e2487 w2488 s2489 mod2490) (chi-expr2141 type2485 value2486 e2487 r2482 w2488 s2489 mod2490))))) (chi-top2139 (lambda (e2491 r2492 w2493 m2494 esew2495 mod2496) (call-with-values (lambda () (syntax-type2138 e2491 r2492 w2493 #f #f mod2496)) (lambda (type2504 value2505 e2506 w2507 s2508 mod2509) (if (memv type2504 (quote (begin-form))) ((lambda (tmp2510) ((lambda (tmp2511) (if tmp2511 (apply (lambda (_2512) (chi-void2148)) tmp2511) ((lambda (tmp2513) (if tmp2513 (apply (lambda (_2514 e12515 e22516) (chi-top-sequence2135 (cons e12515 e22516) r2492 w2507 s2508 m2494 esew2495 mod2509)) tmp2513) (syntax-violation #f "source expression failed to match any pattern" tmp2510))) ($sc-dispatch tmp2510 (quote (any any . each-any)))))) ($sc-dispatch tmp2510 (quote (any))))) e2506) (if (memv type2504 (quote (local-syntax-form))) (chi-local-syntax2146 value2505 e2506 r2492 w2507 s2508 mod2509 (lambda (body2518 r2519 w2520 s2521 mod2522) (chi-top-sequence2135 body2518 r2519 w2520 s2521 m2494 esew2495 mod2522))) (if (memv type2504 (quote (eval-when-form))) ((lambda (tmp2523) ((lambda (tmp2524) (if tmp2524 (apply (lambda (_2525 x2526 e12527 e22528) (let ((when-list2529 (chi-when-list2137 e2506 x2526 w2507)) (body2530 (cons e12527 e22528))) (if (eq? m2494 (quote e)) (if (memq (quote eval) when-list2529) (chi-top-sequence2135 body2530 r2492 w2507 s2508 (quote e) (quote (eval)) mod2509) (chi-void2148)) (if (memq (quote load) when-list2529) (if (let ((t2533 (memq (quote compile) when-list2529))) (if t2533 t2533 (if (eq? m2494 (quote c&e)) (memq (quote eval) when-list2529) #f))) (chi-top-sequence2135 body2530 r2492 w2507 s2508 (quote c&e) (quote (compile load)) mod2509) (if (memq m2494 (quote (c c&e))) (chi-top-sequence2135 body2530 r2492 w2507 s2508 (quote c) (quote (load)) mod2509) (chi-void2148))) (if (let ((t2534 (memq (quote compile) when-list2529))) (if t2534 t2534 (if (eq? m2494 (quote c&e)) (memq (quote eval) when-list2529) #f))) (begin (top-level-eval-hook2067 (chi-top-sequence2135 body2530 r2492 w2507 s2508 (quote e) (quote (eval)) mod2509) mod2509) (chi-void2148)) (chi-void2148)))))) tmp2524) (syntax-violation #f "source expression failed to match any pattern" tmp2523))) ($sc-dispatch tmp2523 (quote (any each-any any . each-any))))) e2506) (if (memv type2504 (quote (define-syntax-form))) (let ((n2535 (id-var-name2126 value2505 w2507)) (r2536 (macros-only-env2100 r2492))) (if (memv m2494 (quote (c))) (if (memq (quote compile) esew2495) (let ((e2537 (chi-install-global2136 n2535 (chi2140 e2506 r2536 w2507 mod2509)))) (begin (top-level-eval-hook2067 e2537 mod2509) (if (memq (quote load) esew2495) e2537 (chi-void2148)))) (if (memq (quote load) esew2495) (chi-install-global2136 n2535 (chi2140 e2506 r2536 w2507 mod2509)) (chi-void2148))) (if (memv m2494 (quote (c&e))) (let ((e2538 (chi-install-global2136 n2535 (chi2140 e2506 r2536 w2507 mod2509)))) (begin (top-level-eval-hook2067 e2538 mod2509) e2538)) (begin (if (memq (quote eval) esew2495) (top-level-eval-hook2067 (chi-install-global2136 n2535 (chi2140 e2506 r2536 w2507 mod2509)) mod2509) (if #f #f)) (chi-void2148))))) (if (memv type2504 (quote (define-form))) (let ((n2539 (id-var-name2126 value2505 w2507))) (let ((type2540 (binding-type2096 (lookup2101 n2539 r2492 mod2509)))) (if (memv type2540 (quote (global core macro module-ref))) (let ((x2541 (build-global-definition2079 s2508 n2539 (chi2140 e2506 r2492 w2507 mod2509)))) (begin (if (eq? m2494 (quote c&e)) (top-level-eval-hook2067 x2541 mod2509) (if #f #f)) x2541)) (if (memv type2540 (quote (displaced-lexical))) (syntax-violation #f "identifier out of context" e2506 (wrap2132 value2505 w2507 mod2509)) (syntax-violation #f "cannot define keyword at top level" e2506 (wrap2132 value2505 w2507 mod2509)))))) (let ((x2542 (chi-expr2141 type2504 value2505 e2506 r2492 w2507 s2508 mod2509))) (begin (if (eq? m2494 (quote c&e)) (top-level-eval-hook2067 x2542 mod2509) (if #f #f)) x2542))))))))))) (syntax-type2138 (lambda (e2543 r2544 w2545 s2546 rib2547 mod2548) (if (symbol? e2543) (let ((n2549 (id-var-name2126 e2543 w2545))) (let ((b2550 (lookup2101 n2549 r2544 mod2548))) (let ((type2551 (binding-type2096 b2550))) (if (memv type2551 (quote (lexical))) (values type2551 (binding-value2097 b2550) e2543 w2545 s2546 mod2548) (if (memv type2551 (quote (global))) (values type2551 n2549 e2543 w2545 s2546 mod2548) (if (memv type2551 (quote (macro))) (syntax-type2138 (chi-macro2143 (binding-value2097 b2550) e2543 r2544 w2545 rib2547 mod2548) r2544 (quote (())) s2546 rib2547 mod2548) (values type2551 (binding-value2097 b2550) e2543 w2545 s2546 mod2548))))))) (if (pair? e2543) (let ((first2552 (car e2543))) (if (id?2104 first2552) (let ((n2553 (id-var-name2126 first2552 w2545))) (let ((b2554 (lookup2101 n2553 r2544 (let ((t2555 (if (syntax-object?2088 first2552) (syntax-object-module2091 first2552) #f))) (if t2555 t2555 mod2548))))) (let ((type2556 (binding-type2096 b2554))) (if (memv type2556 (quote (lexical))) (values (quote lexical-call) (binding-value2097 b2554) e2543 w2545 s2546 mod2548) (if (memv type2556 (quote (global))) (values (quote global-call) n2553 e2543 w2545 s2546 mod2548) (if (memv type2556 (quote (macro))) (syntax-type2138 (chi-macro2143 (binding-value2097 b2554) e2543 r2544 w2545 rib2547 mod2548) r2544 (quote (())) s2546 rib2547 mod2548) (if (memv type2556 (quote (core external-macro module-ref))) (values type2556 (binding-value2097 b2554) e2543 w2545 s2546 mod2548) (if (memv type2556 (quote (local-syntax))) (values (quote local-syntax-form) (binding-value2097 b2554) e2543 w2545 s2546 mod2548) (if (memv type2556 (quote (begin))) (values (quote begin-form) #f e2543 w2545 s2546 mod2548) (if (memv type2556 (quote (eval-when))) (values (quote eval-when-form) #f e2543 w2545 s2546 mod2548) (if (memv type2556 (quote (define))) ((lambda (tmp2557) ((lambda (tmp2558) (if (if tmp2558 (apply (lambda (_2559 name2560 val2561) (id?2104 name2560)) tmp2558) #f) (apply (lambda (_2562 name2563 val2564) (values (quote define-form) name2563 val2564 w2545 s2546 mod2548)) tmp2558) ((lambda (tmp2565) (if (if tmp2565 (apply (lambda (_2566 name2567 args2568 e12569 e22570) (if (id?2104 name2567) (valid-bound-ids?2129 (lambda-var-list2153 args2568)) #f)) tmp2565) #f) (apply (lambda (_2571 name2572 args2573 e12574 e22575) (values (quote define-form) (wrap2132 name2572 w2545 mod2548) (cons (quote #(syntax-object lambda ((top) #(ribcage #(_ name args e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) (wrap2132 (cons args2573 (cons e12574 e22575)) w2545 mod2548)) (quote (())) s2546 mod2548)) tmp2565) ((lambda (tmp2577) (if (if tmp2577 (apply (lambda (_2578 name2579) (id?2104 name2579)) tmp2577) #f) (apply (lambda (_2580 name2581) (values (quote define-form) (wrap2132 name2581 w2545 mod2548) (quote (#(syntax-object if ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)) #(syntax-object #f ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)) #(syntax-object #f ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote (())) s2546 mod2548)) tmp2577) (syntax-violation #f "source expression failed to match any pattern" tmp2557))) ($sc-dispatch tmp2557 (quote (any any)))))) ($sc-dispatch tmp2557 (quote (any (any . any) any . each-any)))))) ($sc-dispatch tmp2557 (quote (any any any))))) e2543) (if (memv type2556 (quote (define-syntax))) ((lambda (tmp2582) ((lambda (tmp2583) (if (if tmp2583 (apply (lambda (_2584 name2585 val2586) (id?2104 name2585)) tmp2583) #f) (apply (lambda (_2587 name2588 val2589) (values (quote define-syntax-form) name2588 val2589 w2545 s2546 mod2548)) tmp2583) (syntax-violation #f "source expression failed to match any pattern" tmp2582))) ($sc-dispatch tmp2582 (quote (any any any))))) e2543) (values (quote call) #f e2543 w2545 s2546 mod2548))))))))))))) (values (quote call) #f e2543 w2545 s2546 mod2548))) (if (syntax-object?2088 e2543) (syntax-type2138 (syntax-object-expression2089 e2543) r2544 (join-wraps2123 w2545 (syntax-object-wrap2090 e2543)) #f rib2547 (let ((t2590 (syntax-object-module2091 e2543))) (if t2590 t2590 mod2548))) (if (annotation? e2543) (syntax-type2138 (annotation-expression e2543) r2544 w2545 (annotation-source e2543) rib2547 mod2548) (if (self-evaluating? e2543) (values (quote constant) #f e2543 w2545 s2546 mod2548) (values (quote other) #f e2543 w2545 s2546 mod2548)))))))) (chi-when-list2137 (lambda (e2591 when-list2592 w2593) (letrec ((f2594 (lambda (when-list2595 situations2596) (if (null? when-list2595) situations2596 (f2594 (cdr when-list2595) (cons (let ((x2597 (car when-list2595))) (if (free-id=?2127 x2597 (quote #(syntax-object compile ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote compile) (if (free-id=?2127 x2597 (quote #(syntax-object load ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote load) (if (free-id=?2127 x2597 (quote #(syntax-object eval ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote eval) (syntax-violation (quote eval-when) "invalid situation" e2591 (wrap2132 x2597 w2593 #f)))))) situations2596)))))) (f2594 when-list2592 (quote ()))))) (chi-install-global2136 (lambda (name2598 e2599) (build-global-definition2079 #f name2598 (if (let ((v2600 (module-variable (current-module) name2598))) (if v2600 (if (variable-bound? v2600) (if (macro? (variable-ref v2600)) (not (eq? (macro-type (variable-ref v2600)) (quote syncase-macro))) #f) #f) #f)) (build-application2072 #f (build-primref2081 #f (quote make-extended-syncase-macro)) (list (build-application2072 #f (build-primref2081 #f (quote module-ref)) (list (build-application2072 #f (quote current-module) (quote ())) (build-data2082 #f name2598))) (build-data2082 #f (quote macro)) e2599)) (build-application2072 #f (build-primref2081 #f (quote make-syncase-macro)) (list (build-data2082 #f (quote macro)) e2599)))))) (chi-top-sequence2135 (lambda (body2601 r2602 w2603 s2604 m2605 esew2606 mod2607) (build-sequence2083 s2604 (letrec ((dobody2608 (lambda (body2609 r2610 w2611 m2612 esew2613 mod2614) (if (null? body2609) (quote ()) (let ((first2615 (chi-top2139 (car body2609) r2610 w2611 m2612 esew2613 mod2614))) (cons first2615 (dobody2608 (cdr body2609) r2610 w2611 m2612 esew2613 mod2614))))))) (dobody2608 body2601 r2602 w2603 m2605 esew2606 mod2607))))) (chi-sequence2134 (lambda (body2616 r2617 w2618 s2619 mod2620) (build-sequence2083 s2619 (letrec ((dobody2621 (lambda (body2622 r2623 w2624 mod2625) (if (null? body2622) (quote ()) (let ((first2626 (chi2140 (car body2622) r2623 w2624 mod2625))) (cons first2626 (dobody2621 (cdr body2622) r2623 w2624 mod2625))))))) (dobody2621 body2616 r2617 w2618 mod2620))))) (source-wrap2133 (lambda (x2627 w2628 s2629 defmod2630) (wrap2132 (if s2629 (make-annotation x2627 s2629 #f) x2627) w2628 defmod2630))) (wrap2132 (lambda (x2631 w2632 defmod2633) (if (if (null? (wrap-marks2107 w2632)) (null? (wrap-subst2108 w2632)) #f) x2631 (if (syntax-object?2088 x2631) (make-syntax-object2087 (syntax-object-expression2089 x2631) (join-wraps2123 w2632 (syntax-object-wrap2090 x2631)) (syntax-object-module2091 x2631)) (if (null? x2631) x2631 (make-syntax-object2087 x2631 w2632 defmod2633)))))) (bound-id-member?2131 (lambda (x2634 list2635) (if (not (null? list2635)) (let ((t2636 (bound-id=?2128 x2634 (car list2635)))) (if t2636 t2636 (bound-id-member?2131 x2634 (cdr list2635)))) #f))) (distinct-bound-ids?2130 (lambda (ids2637) (letrec ((distinct?2638 (lambda (ids2639) (let ((t2640 (null? ids2639))) (if t2640 t2640 (if (not (bound-id-member?2131 (car ids2639) (cdr ids2639))) (distinct?2638 (cdr ids2639)) #f)))))) (distinct?2638 ids2637)))) (valid-bound-ids?2129 (lambda (ids2641) (if (letrec ((all-ids?2642 (lambda (ids2643) (let ((t2644 (null? ids2643))) (if t2644 t2644 (if (id?2104 (car ids2643)) (all-ids?2642 (cdr ids2643)) #f)))))) (all-ids?2642 ids2641)) (distinct-bound-ids?2130 ids2641) #f))) (bound-id=?2128 (lambda (i2645 j2646) (if (if (syntax-object?2088 i2645) (syntax-object?2088 j2646) #f) (if (eq? (let ((e2647 (syntax-object-expression2089 i2645))) (if (annotation? e2647) (annotation-expression e2647) e2647)) (let ((e2648 (syntax-object-expression2089 j2646))) (if (annotation? e2648) (annotation-expression e2648) e2648))) (same-marks?2125 (wrap-marks2107 (syntax-object-wrap2090 i2645)) (wrap-marks2107 (syntax-object-wrap2090 j2646))) #f) (eq? (let ((e2649 i2645)) (if (annotation? e2649) (annotation-expression e2649) e2649)) (let ((e2650 j2646)) (if (annotation? e2650) (annotation-expression e2650) e2650)))))) (free-id=?2127 (lambda (i2651 j2652) (if (eq? (let ((x2653 i2651)) (let ((e2654 (if (syntax-object?2088 x2653) (syntax-object-expression2089 x2653) x2653))) (if (annotation? e2654) (annotation-expression e2654) e2654))) (let ((x2655 j2652)) (let ((e2656 (if (syntax-object?2088 x2655) (syntax-object-expression2089 x2655) x2655))) (if (annotation? e2656) (annotation-expression e2656) e2656)))) (eq? (id-var-name2126 i2651 (quote (()))) (id-var-name2126 j2652 (quote (())))) #f))) (id-var-name2126 (lambda (id2657 w2658) (letrec ((search-vector-rib2661 (lambda (sym2667 subst2668 marks2669 symnames2670 ribcage2671) (let ((n2672 (vector-length symnames2670))) (letrec ((f2673 (lambda (i2674) (if (fx=2065 i2674 n2672) (search2659 sym2667 (cdr subst2668) marks2669) (if (if (eq? (vector-ref symnames2670 i2674) sym2667) (same-marks?2125 marks2669 (vector-ref (ribcage-marks2114 ribcage2671) i2674)) #f) (values (vector-ref (ribcage-labels2115 ribcage2671) i2674) marks2669) (f2673 (fx+2063 i2674 1))))))) (f2673 0))))) (search-list-rib2660 (lambda (sym2675 subst2676 marks2677 symnames2678 ribcage2679) (letrec ((f2680 (lambda (symnames2681 i2682) (if (null? symnames2681) (search2659 sym2675 (cdr subst2676) marks2677) (if (if (eq? (car symnames2681) sym2675) (same-marks?2125 marks2677 (list-ref (ribcage-marks2114 ribcage2679) i2682)) #f) (values (list-ref (ribcage-labels2115 ribcage2679) i2682) marks2677) (f2680 (cdr symnames2681) (fx+2063 i2682 1))))))) (f2680 symnames2678 0)))) (search2659 (lambda (sym2683 subst2684 marks2685) (if (null? subst2684) (values #f marks2685) (let ((fst2686 (car subst2684))) (if (eq? fst2686 (quote shift)) (search2659 sym2683 (cdr subst2684) (cdr marks2685)) (let ((symnames2687 (ribcage-symnames2113 fst2686))) (if (vector? symnames2687) (search-vector-rib2661 sym2683 subst2684 marks2685 symnames2687 fst2686) (search-list-rib2660 sym2683 subst2684 marks2685 symnames2687 fst2686))))))))) (if (symbol? id2657) (let ((t2688 (call-with-values (lambda () (search2659 id2657 (wrap-subst2108 w2658) (wrap-marks2107 w2658))) (lambda (x2690 . ignore2689) x2690)))) (if t2688 t2688 id2657)) (if (syntax-object?2088 id2657) (let ((id2691 (let ((e2693 (syntax-object-expression2089 id2657))) (if (annotation? e2693) (annotation-expression e2693) e2693))) (w12692 (syntax-object-wrap2090 id2657))) (let ((marks2694 (join-marks2124 (wrap-marks2107 w2658) (wrap-marks2107 w12692)))) (call-with-values (lambda () (search2659 id2691 (wrap-subst2108 w2658) marks2694)) (lambda (new-id2695 marks2696) (let ((t2697 new-id2695)) (if t2697 t2697 (let ((t2698 (call-with-values (lambda () (search2659 id2691 (wrap-subst2108 w12692) marks2696)) (lambda (x2700 . ignore2699) x2700)))) (if t2698 t2698 id2691)))))))) (if (annotation? id2657) (let ((id2701 (let ((e2702 id2657)) (if (annotation? e2702) (annotation-expression e2702) e2702)))) (let ((t2703 (call-with-values (lambda () (search2659 id2701 (wrap-subst2108 w2658) (wrap-marks2107 w2658))) (lambda (x2705 . ignore2704) x2705)))) (if t2703 t2703 id2701))) (syntax-violation (quote id-var-name) "invalid id" id2657))))))) (same-marks?2125 (lambda (x2706 y2707) (let ((t2708 (eq? x2706 y2707))) (if t2708 t2708 (if (not (null? x2706)) (if (not (null? y2707)) (if (eq? (car x2706) (car y2707)) (same-marks?2125 (cdr x2706) (cdr y2707)) #f) #f) #f))))) (join-marks2124 (lambda (m12709 m22710) (smart-append2122 m12709 m22710))) (join-wraps2123 (lambda (w12711 w22712) (let ((m12713 (wrap-marks2107 w12711)) (s12714 (wrap-subst2108 w12711))) (if (null? m12713) (if (null? s12714) w22712 (make-wrap2106 (wrap-marks2107 w22712) (smart-append2122 s12714 (wrap-subst2108 w22712)))) (make-wrap2106 (smart-append2122 m12713 (wrap-marks2107 w22712)) (smart-append2122 s12714 (wrap-subst2108 w22712))))))) (smart-append2122 (lambda (m12715 m22716) (if (null? m22716) m12715 (append m12715 m22716)))) (make-binding-wrap2121 (lambda (ids2717 labels2718 w2719) (if (null? ids2717) w2719 (make-wrap2106 (wrap-marks2107 w2719) (cons (let ((labelvec2720 (list->vector labels2718))) (let ((n2721 (vector-length labelvec2720))) (let ((symnamevec2722 (make-vector n2721)) (marksvec2723 (make-vector n2721))) (begin (letrec ((f2724 (lambda (ids2725 i2726) (if (not (null? ids2725)) (call-with-values (lambda () (id-sym-name&marks2105 (car ids2725) w2719)) (lambda (symname2727 marks2728) (begin (vector-set! symnamevec2722 i2726 symname2727) (vector-set! marksvec2723 i2726 marks2728) (f2724 (cdr ids2725) (fx+2063 i2726 1))))) (if #f #f))))) (f2724 ids2717 0)) (make-ribcage2111 symnamevec2722 marksvec2723 labelvec2720))))) (wrap-subst2108 w2719)))))) (extend-ribcage!2120 (lambda (ribcage2729 id2730 label2731) (begin (set-ribcage-symnames!2116 ribcage2729 (cons (let ((e2732 (syntax-object-expression2089 id2730))) (if (annotation? e2732) (annotation-expression e2732) e2732)) (ribcage-symnames2113 ribcage2729))) (set-ribcage-marks!2117 ribcage2729 (cons (wrap-marks2107 (syntax-object-wrap2090 id2730)) (ribcage-marks2114 ribcage2729))) (set-ribcage-labels!2118 ribcage2729 (cons label2731 (ribcage-labels2115 ribcage2729)))))) (anti-mark2119 (lambda (w2733) (make-wrap2106 (cons #f (wrap-marks2107 w2733)) (cons (quote shift) (wrap-subst2108 w2733))))) (set-ribcage-labels!2118 (lambda (x2734 update2735) (vector-set! x2734 3 update2735))) (set-ribcage-marks!2117 (lambda (x2736 update2737) (vector-set! x2736 2 update2737))) (set-ribcage-symnames!2116 (lambda (x2738 update2739) (vector-set! x2738 1 update2739))) (ribcage-labels2115 (lambda (x2740) (vector-ref x2740 3))) (ribcage-marks2114 (lambda (x2741) (vector-ref x2741 2))) (ribcage-symnames2113 (lambda (x2742) (vector-ref x2742 1))) (ribcage?2112 (lambda (x2743) (if (vector? x2743) (if (= (vector-length x2743) 4) (eq? (vector-ref x2743 0) (quote ribcage)) #f) #f))) (make-ribcage2111 (lambda (symnames2744 marks2745 labels2746) (vector (quote ribcage) symnames2744 marks2745 labels2746))) (gen-labels2110 (lambda (ls2747) (if (null? ls2747) (quote ()) (cons (gen-label2109) (gen-labels2110 (cdr ls2747)))))) (gen-label2109 (lambda () (string #\i))) (wrap-subst2108 cdr) (wrap-marks2107 car) (make-wrap2106 cons) (id-sym-name&marks2105 (lambda (x2748 w2749) (if (syntax-object?2088 x2748) (values (let ((e2750 (syntax-object-expression2089 x2748))) (if (annotation? e2750) (annotation-expression e2750) e2750)) (join-marks2124 (wrap-marks2107 w2749) (wrap-marks2107 (syntax-object-wrap2090 x2748)))) (values (let ((e2751 x2748)) (if (annotation? e2751) (annotation-expression e2751) e2751)) (wrap-marks2107 w2749))))) (id?2104 (lambda (x2752) (if (symbol? x2752) #t (if (syntax-object?2088 x2752) (symbol? (let ((e2753 (syntax-object-expression2089 x2752))) (if (annotation? e2753) (annotation-expression e2753) e2753))) (if (annotation? x2752) (symbol? (annotation-expression x2752)) #f))))) (nonsymbol-id?2103 (lambda (x2754) (if (syntax-object?2088 x2754) (symbol? (let ((e2755 (syntax-object-expression2089 x2754))) (if (annotation? e2755) (annotation-expression e2755) e2755))) #f))) (global-extend2102 (lambda (type2756 sym2757 val2758) (put-global-definition-hook2069 sym2757 type2756 val2758))) (lookup2101 (lambda (x2759 r2760 mod2761) (let ((temp2762 (assq x2759 r2760))) (if temp2762 (cdr temp2762) (if (symbol? x2759) (let ((t2763 (get-global-definition-hook2070 x2759 mod2761))) (if t2763 t2763 (quote (global)))) (quote (displaced-lexical))))))) (macros-only-env2100 (lambda (r2764) (if (null? r2764) (quote ()) (let ((a2765 (car r2764))) (if (eq? (cadr a2765) (quote macro)) (cons a2765 (macros-only-env2100 (cdr r2764))) (macros-only-env2100 (cdr r2764))))))) (extend-var-env2099 (lambda (labels2766 vars2767 r2768) (if (null? labels2766) r2768 (extend-var-env2099 (cdr labels2766) (cdr vars2767) (cons (cons (car labels2766) (cons (quote lexical) (car vars2767))) r2768))))) (extend-env2098 (lambda (labels2769 bindings2770 r2771) (if (null? labels2769) r2771 (extend-env2098 (cdr labels2769) (cdr bindings2770) (cons (cons (car labels2769) (car bindings2770)) r2771))))) (binding-value2097 cdr) (binding-type2096 car) (source-annotation2095 (lambda (x2772) (if (annotation? x2772) (annotation-source x2772) (if (syntax-object?2088 x2772) (source-annotation2095 (syntax-object-expression2089 x2772)) #f)))) (set-syntax-object-module!2094 (lambda (x2773 update2774) (vector-set! x2773 3 update2774))) (set-syntax-object-wrap!2093 (lambda (x2775 update2776) (vector-set! x2775 2 update2776))) (set-syntax-object-expression!2092 (lambda (x2777 update2778) (vector-set! x2777 1 update2778))) (syntax-object-module2091 (lambda (x2779) (vector-ref x2779 3))) (syntax-object-wrap2090 (lambda (x2780) (vector-ref x2780 2))) (syntax-object-expression2089 (lambda (x2781) (vector-ref x2781 1))) (syntax-object?2088 (lambda (x2782) (if (vector? x2782) (if (= (vector-length x2782) 4) (eq? (vector-ref x2782 0) (quote syntax-object)) #f) #f))) (make-syntax-object2087 (lambda (expression2783 wrap2784 module2785) (vector (quote syntax-object) expression2783 wrap2784 module2785))) (build-letrec2086 (lambda (src2786 ids2787 vars2788 val-exps2789 body-exp2790) (if (null? vars2788) body-exp2790 (let ((atom-key2791 (fluid-ref *mode*2062))) (if (memv atom-key2791 (quote (c))) ((@ (language tree-il) make-letrec) src2786 ids2787 vars2788 val-exps2789 body-exp2790) (list (quote letrec) (map list vars2788 val-exps2789) body-exp2790)))))) (build-named-let2085 (lambda (src2792 ids2793 vars2794 val-exps2795 body-exp2796) (let ((f2797 (car vars2794)) (f-name2798 (car ids2793)) (vars2799 (cdr vars2794)) (ids2800 (cdr ids2793))) (let ((atom-key2801 (fluid-ref *mode*2062))) (if (memv atom-key2801 (quote (c))) ((@ (language tree-il) make-letrec) src2792 (list f-name2798) (list f2797) (list (build-lambda2080 src2792 ids2800 vars2799 #f body-exp2796)) (build-application2072 src2792 (build-lexical-reference2074 (quote fun) src2792 f-name2798 f2797) val-exps2795)) (list (quote let) f2797 (map list vars2799 val-exps2795) body-exp2796)))))) (build-let2084 (lambda (src2802 ids2803 vars2804 val-exps2805 body-exp2806) (if (null? vars2804) body-exp2806 (let ((atom-key2807 (fluid-ref *mode*2062))) (if (memv atom-key2807 (quote (c))) ((@ (language tree-il) make-let) src2802 ids2803 vars2804 val-exps2805 body-exp2806) (list (quote let) (map list vars2804 val-exps2805) body-exp2806)))))) (build-sequence2083 (lambda (src2808 exps2809) (if (null? (cdr exps2809)) (car exps2809) (let ((atom-key2810 (fluid-ref *mode*2062))) (if (memv atom-key2810 (quote (c))) ((@ (language tree-il) make-sequence) src2808 exps2809) (cons (quote begin) exps2809)))))) (build-data2082 (lambda (src2811 exp2812) (let ((atom-key2813 (fluid-ref *mode*2062))) (if (memv atom-key2813 (quote (c))) ((@ (language tree-il) make-const) src2811 exp2812) (if (if (self-evaluating? exp2812) (not (vector? exp2812)) #f) exp2812 (list (quote quote) exp2812)))))) (build-primref2081 (lambda (src2814 name2815) (if (equal? (module-name (current-module)) (quote (guile))) (let ((atom-key2816 (fluid-ref *mode*2062))) (if (memv atom-key2816 (quote (c))) ((@ (language tree-il) make-toplevel-ref) src2814 name2815) name2815)) (let ((atom-key2817 (fluid-ref *mode*2062))) (if (memv atom-key2817 (quote (c))) ((@ (language tree-il) make-module-ref) src2814 (quote (guile)) name2815 #f) (list (quote @@) (quote (guile)) name2815)))))) (build-lambda2080 (lambda (src2818 ids2819 vars2820 docstring2821 exp2822) (let ((atom-key2823 (fluid-ref *mode*2062))) (if (memv atom-key2823 (quote (c))) ((@ (language tree-il) make-lambda) src2818 ids2819 vars2820 (if docstring2821 (list (cons (quote documentation) docstring2821)) (quote ())) exp2822) (cons (quote lambda) (cons vars2820 (append (if docstring2821 (list docstring2821) (quote ())) (list exp2822)))))))) (build-global-definition2079 (lambda (source2824 var2825 exp2826) (let ((atom-key2827 (fluid-ref *mode*2062))) (if (memv atom-key2827 (quote (c))) ((@ (language tree-il) make-toplevel-define) source2824 var2825 exp2826) (list (quote define) var2825 exp2826))))) (build-global-assignment2078 (lambda (source2828 var2829 exp2830 mod2831) (analyze-variable2076 mod2831 var2829 (lambda (mod2832 var2833 public?2834) (let ((atom-key2835 (fluid-ref *mode*2062))) (if (memv atom-key2835 (quote (c))) ((@ (language tree-il) make-module-set) source2828 mod2832 var2833 public?2834 exp2830) (list (quote set!) (list (if public?2834 (quote @) (quote @@)) mod2832 var2833) exp2830)))) (lambda (var2836) (let ((atom-key2837 (fluid-ref *mode*2062))) (if (memv atom-key2837 (quote (c))) ((@ (language tree-il) make-toplevel-set) source2828 var2836 exp2830) (list (quote set!) var2836 exp2830))))))) (build-global-reference2077 (lambda (source2838 var2839 mod2840) (analyze-variable2076 mod2840 var2839 (lambda (mod2841 var2842 public?2843) (let ((atom-key2844 (fluid-ref *mode*2062))) (if (memv atom-key2844 (quote (c))) ((@ (language tree-il) make-module-ref) source2838 mod2841 var2842 public?2843) (list (if public?2843 (quote @) (quote @@)) mod2841 var2842)))) (lambda (var2845) (let ((atom-key2846 (fluid-ref *mode*2062))) (if (memv atom-key2846 (quote (c))) ((@ (language tree-il) make-toplevel-ref) source2838 var2845) var2845)))))) (analyze-variable2076 (lambda (mod2847 var2848 modref-cont2849 bare-cont2850) (if (not mod2847) (bare-cont2850 var2848) (let ((kind2851 (car mod2847)) (mod2852 (cdr mod2847))) (if (memv kind2851 (quote (public))) (modref-cont2849 mod2852 var2848 #t) (if (memv kind2851 (quote (private))) (if (not (equal? mod2852 (module-name (current-module)))) (modref-cont2849 mod2852 var2848 #f) (bare-cont2850 var2848)) (if (memv kind2851 (quote (bare))) (bare-cont2850 var2848) (if (memv kind2851 (quote (hygiene))) (if (if (not (equal? mod2852 (module-name (current-module)))) (module-variable (resolve-module mod2852) var2848) #f) (modref-cont2849 mod2852 var2848 #f) (bare-cont2850 var2848)) (syntax-violation #f "bad module kind" var2848 mod2852))))))))) (build-lexical-assignment2075 (lambda (source2853 name2854 var2855 exp2856) (let ((atom-key2857 (fluid-ref *mode*2062))) (if (memv atom-key2857 (quote (c))) ((@ (language tree-il) make-lexical-set) source2853 name2854 var2855 exp2856) (list (quote set!) var2855 exp2856))))) (build-lexical-reference2074 (lambda (type2858 source2859 name2860 var2861) (let ((atom-key2862 (fluid-ref *mode*2062))) (if (memv atom-key2862 (quote (c))) ((@ (language tree-il) make-lexical-ref) source2859 name2860 var2861) var2861)))) (build-conditional2073 (lambda (source2863 test-exp2864 then-exp2865 else-exp2866) (let ((atom-key2867 (fluid-ref *mode*2062))) (if (memv atom-key2867 (quote (c))) ((@ (language tree-il) make-conditional) source2863 test-exp2864 then-exp2865 else-exp2866) (list (quote if) test-exp2864 then-exp2865 else-exp2866))))) (build-application2072 (lambda (source2868 fun-exp2869 arg-exps2870) (let ((atom-key2871 (fluid-ref *mode*2062))) (if (memv atom-key2871 (quote (c))) ((@ (language tree-il) make-application) source2868 fun-exp2869 arg-exps2870) (cons fun-exp2869 arg-exps2870))))) (build-void2071 (lambda (source2872) (let ((atom-key2873 (fluid-ref *mode*2062))) (if (memv atom-key2873 (quote (c))) ((@ (language tree-il) make-void) source2872) (quote (if #f #f)))))) (get-global-definition-hook2070 (lambda (symbol2874 module2875) (begin (if (if (not module2875) (current-module) #f) (warn "module system is booted, we should have a module" symbol2874) (if #f #f)) (let ((v2876 (module-variable (if module2875 (resolve-module (cdr module2875)) (current-module)) symbol2874))) (if v2876 (if (variable-bound? v2876) (let ((val2877 (variable-ref v2876))) (if (macro? val2877) (if (syncase-macro-type val2877) (cons (syncase-macro-type val2877) (syncase-macro-binding val2877)) #f) #f)) #f) #f))))) (put-global-definition-hook2069 (lambda (symbol2878 type2879 val2880) (let ((existing2881 (let ((v2882 (module-variable (current-module) symbol2878))) (if v2882 (if (variable-bound? v2882) (let ((val2883 (variable-ref v2882))) (if (macro? val2883) (if (not (syncase-macro-type val2883)) val2883 #f) #f)) #f) #f)))) (module-define! (current-module) symbol2878 (if existing2881 (make-extended-syncase-macro existing2881 type2879 val2880) (make-syncase-macro type2879 val2880)))))) (local-eval-hook2068 (lambda (x2884 mod2885) (primitive-eval (list noexpand2061 (let ((atom-key2886 (fluid-ref *mode*2062))) (if (memv atom-key2886 (quote (c))) ((@ (language tree-il) tree-il->scheme) x2884) x2884)))))) (top-level-eval-hook2067 (lambda (x2887 mod2888) (primitive-eval (list noexpand2061 (let ((atom-key2889 (fluid-ref *mode*2062))) (if (memv atom-key2889 (quote (c))) ((@ (language tree-il) tree-il->scheme) x2887) x2887)))))) (fx<2066 <) (fx=2065 =) (fx-2064 -) (fx+2063 +) (*mode*2062 (make-fluid)) (noexpand2061 "noexpand")) (begin (global-extend2102 (quote local-syntax) (quote letrec-syntax) #t) (global-extend2102 (quote local-syntax) (quote let-syntax) #f) (global-extend2102 (quote core) (quote fluid-let-syntax) (lambda (e2890 r2891 w2892 s2893 mod2894) ((lambda (tmp2895) ((lambda (tmp2896) (if (if tmp2896 (apply (lambda (_2897 var2898 val2899 e12900 e22901) (valid-bound-ids?2129 var2898)) tmp2896) #f) (apply (lambda (_2903 var2904 val2905 e12906 e22907) (let ((names2908 (map (lambda (x2909) (id-var-name2126 x2909 w2892)) var2904))) (begin (for-each (lambda (id2911 n2912) (let ((atom-key2913 (binding-type2096 (lookup2101 n2912 r2891 mod2894)))) (if (memv atom-key2913 (quote (displaced-lexical))) (syntax-violation (quote fluid-let-syntax) "identifier out of context" e2890 (source-wrap2133 id2911 w2892 s2893 mod2894)) (if #f #f)))) var2904 names2908) (chi-body2144 (cons e12906 e22907) (source-wrap2133 e2890 w2892 s2893 mod2894) (extend-env2098 names2908 (let ((trans-r2916 (macros-only-env2100 r2891))) (map (lambda (x2917) (cons (quote macro) (eval-local-transformer2147 (chi2140 x2917 trans-r2916 w2892 mod2894) mod2894))) val2905)) r2891) w2892 mod2894)))) tmp2896) ((lambda (_2919) (syntax-violation (quote fluid-let-syntax) "bad syntax" (source-wrap2133 e2890 w2892 s2893 mod2894))) tmp2895))) ($sc-dispatch tmp2895 (quote (any #(each (any any)) any . each-any))))) e2890))) (global-extend2102 (quote core) (quote quote) (lambda (e2920 r2921 w2922 s2923 mod2924) ((lambda (tmp2925) ((lambda (tmp2926) (if tmp2926 (apply (lambda (_2927 e2928) (build-data2082 s2923 (strip2151 e2928 w2922))) tmp2926) ((lambda (_2929) (syntax-violation (quote quote) "bad syntax" (source-wrap2133 e2920 w2922 s2923 mod2924))) tmp2925))) ($sc-dispatch tmp2925 (quote (any any))))) e2920))) (global-extend2102 (quote core) (quote syntax) (letrec ((regen2937 (lambda (x2938) (let ((atom-key2939 (car x2938))) (if (memv atom-key2939 (quote (ref))) (build-lexical-reference2074 (quote value) #f (cadr x2938) (cadr x2938)) (if (memv atom-key2939 (quote (primitive))) (build-primref2081 #f (cadr x2938)) (if (memv atom-key2939 (quote (quote))) (build-data2082 #f (cadr x2938)) (if (memv atom-key2939 (quote (lambda))) (build-lambda2080 #f (cadr x2938) (cadr x2938) #f (regen2937 (caddr x2938))) (if (memv atom-key2939 (quote (map))) (let ((ls2940 (map regen2937 (cdr x2938)))) (build-application2072 #f (build-primref2081 #f (quote map)) ls2940)) (build-application2072 #f (build-primref2081 #f (car x2938)) (map regen2937 (cdr x2938))))))))))) (gen-vector2936 (lambda (x2941) (if (eq? (car x2941) (quote list)) (cons (quote vector) (cdr x2941)) (if (eq? (car x2941) (quote quote)) (list (quote quote) (list->vector (cadr x2941))) (list (quote list->vector) x2941))))) (gen-append2935 (lambda (x2942 y2943) (if (equal? y2943 (quote (quote ()))) x2942 (list (quote append) x2942 y2943)))) (gen-cons2934 (lambda (x2944 y2945) (let ((atom-key2946 (car y2945))) (if (memv atom-key2946 (quote (quote))) (if (eq? (car x2944) (quote quote)) (list (quote quote) (cons (cadr x2944) (cadr y2945))) (if (eq? (cadr y2945) (quote ())) (list (quote list) x2944) (list (quote cons) x2944 y2945))) (if (memv atom-key2946 (quote (list))) (cons (quote list) (cons x2944 (cdr y2945))) (list (quote cons) x2944 y2945)))))) (gen-map2933 (lambda (e2947 map-env2948) (let ((formals2949 (map cdr map-env2948)) (actuals2950 (map (lambda (x2951) (list (quote ref) (car x2951))) map-env2948))) (if (eq? (car e2947) (quote ref)) (car actuals2950) (if (and-map (lambda (x2952) (if (eq? (car x2952) (quote ref)) (memq (cadr x2952) formals2949) #f)) (cdr e2947)) (cons (quote map) (cons (list (quote primitive) (car e2947)) (map (let ((r2953 (map cons formals2949 actuals2950))) (lambda (x2954) (cdr (assq (cadr x2954) r2953)))) (cdr e2947)))) (cons (quote map) (cons (list (quote lambda) formals2949 e2947) actuals2950))))))) (gen-mappend2932 (lambda (e2955 map-env2956) (list (quote apply) (quote (primitive append)) (gen-map2933 e2955 map-env2956)))) (gen-ref2931 (lambda (src2957 var2958 level2959 maps2960) (if (fx=2065 level2959 0) (values var2958 maps2960) (if (null? maps2960) (syntax-violation (quote syntax) "missing ellipsis" src2957) (call-with-values (lambda () (gen-ref2931 src2957 var2958 (fx-2064 level2959 1) (cdr maps2960))) (lambda (outer-var2961 outer-maps2962) (let ((b2963 (assq outer-var2961 (car maps2960)))) (if b2963 (values (cdr b2963) maps2960) (let ((inner-var2964 (gen-var2152 (quote tmp)))) (values inner-var2964 (cons (cons (cons outer-var2961 inner-var2964) (car maps2960)) outer-maps2962))))))))))) (gen-syntax2930 (lambda (src2965 e2966 r2967 maps2968 ellipsis?2969 mod2970) (if (id?2104 e2966) (let ((label2971 (id-var-name2126 e2966 (quote (()))))) (let ((b2972 (lookup2101 label2971 r2967 mod2970))) (if (eq? (binding-type2096 b2972) (quote syntax)) (call-with-values (lambda () (let ((var.lev2973 (binding-value2097 b2972))) (gen-ref2931 src2965 (car var.lev2973) (cdr var.lev2973) maps2968))) (lambda (var2974 maps2975) (values (list (quote ref) var2974) maps2975))) (if (ellipsis?2969 e2966) (syntax-violation (quote syntax) "misplaced ellipsis" src2965) (values (list (quote quote) e2966) maps2968))))) ((lambda (tmp2976) ((lambda (tmp2977) (if (if tmp2977 (apply (lambda (dots2978 e2979) (ellipsis?2969 dots2978)) tmp2977) #f) (apply (lambda (dots2980 e2981) (gen-syntax2930 src2965 e2981 r2967 maps2968 (lambda (x2982) #f) mod2970)) tmp2977) ((lambda (tmp2983) (if (if tmp2983 (apply (lambda (x2984 dots2985 y2986) (ellipsis?2969 dots2985)) tmp2983) #f) (apply (lambda (x2987 dots2988 y2989) (letrec ((f2990 (lambda (y2991 k2992) ((lambda (tmp2996) ((lambda (tmp2997) (if (if tmp2997 (apply (lambda (dots2998 y2999) (ellipsis?2969 dots2998)) tmp2997) #f) (apply (lambda (dots3000 y3001) (f2990 y3001 (lambda (maps3002) (call-with-values (lambda () (k2992 (cons (quote ()) maps3002))) (lambda (x3003 maps3004) (if (null? (car maps3004)) (syntax-violation (quote syntax) "extra ellipsis" src2965) (values (gen-mappend2932 x3003 (car maps3004)) (cdr maps3004)))))))) tmp2997) ((lambda (_3005) (call-with-values (lambda () (gen-syntax2930 src2965 y2991 r2967 maps2968 ellipsis?2969 mod2970)) (lambda (y3006 maps3007) (call-with-values (lambda () (k2992 maps3007)) (lambda (x3008 maps3009) (values (gen-append2935 x3008 y3006) maps3009)))))) tmp2996))) ($sc-dispatch tmp2996 (quote (any . any))))) y2991)))) (f2990 y2989 (lambda (maps2993) (call-with-values (lambda () (gen-syntax2930 src2965 x2987 r2967 (cons (quote ()) maps2993) ellipsis?2969 mod2970)) (lambda (x2994 maps2995) (if (null? (car maps2995)) (syntax-violation (quote syntax) "extra ellipsis" src2965) (values (gen-map2933 x2994 (car maps2995)) (cdr maps2995))))))))) tmp2983) ((lambda (tmp3010) (if tmp3010 (apply (lambda (x3011 y3012) (call-with-values (lambda () (gen-syntax2930 src2965 x3011 r2967 maps2968 ellipsis?2969 mod2970)) (lambda (x3013 maps3014) (call-with-values (lambda () (gen-syntax2930 src2965 y3012 r2967 maps3014 ellipsis?2969 mod2970)) (lambda (y3015 maps3016) (values (gen-cons2934 x3013 y3015) maps3016)))))) tmp3010) ((lambda (tmp3017) (if tmp3017 (apply (lambda (e13018 e23019) (call-with-values (lambda () (gen-syntax2930 src2965 (cons e13018 e23019) r2967 maps2968 ellipsis?2969 mod2970)) (lambda (e3021 maps3022) (values (gen-vector2936 e3021) maps3022)))) tmp3017) ((lambda (_3023) (values (list (quote quote) e2966) maps2968)) tmp2976))) ($sc-dispatch tmp2976 (quote #(vector (any . each-any))))))) ($sc-dispatch tmp2976 (quote (any . any)))))) ($sc-dispatch tmp2976 (quote (any any . any)))))) ($sc-dispatch tmp2976 (quote (any any))))) e2966))))) (lambda (e3024 r3025 w3026 s3027 mod3028) (let ((e3029 (source-wrap2133 e3024 w3026 s3027 mod3028))) ((lambda (tmp3030) ((lambda (tmp3031) (if tmp3031 (apply (lambda (_3032 x3033) (call-with-values (lambda () (gen-syntax2930 e3029 x3033 r3025 (quote ()) ellipsis?2149 mod3028)) (lambda (e3034 maps3035) (regen2937 e3034)))) tmp3031) ((lambda (_3036) (syntax-violation (quote syntax) "bad `syntax' form" e3029)) tmp3030))) ($sc-dispatch tmp3030 (quote (any any))))) e3029))))) (global-extend2102 (quote core) (quote lambda) (lambda (e3037 r3038 w3039 s3040 mod3041) ((lambda (tmp3042) ((lambda (tmp3043) (if tmp3043 (apply (lambda (_3044 c3045) (chi-lambda-clause2145 (source-wrap2133 e3037 w3039 s3040 mod3041) #f c3045 r3038 w3039 mod3041 (lambda (names3046 vars3047 docstring3048 body3049) (build-lambda2080 s3040 names3046 vars3047 docstring3048 body3049)))) tmp3043) (syntax-violation #f "source expression failed to match any pattern" tmp3042))) ($sc-dispatch tmp3042 (quote (any . any))))) e3037))) (global-extend2102 (quote core) (quote let) (letrec ((chi-let3050 (lambda (e3051 r3052 w3053 s3054 mod3055 constructor3056 ids3057 vals3058 exps3059) (if (not (valid-bound-ids?2129 ids3057)) (syntax-violation (quote let) "duplicate bound variable" e3051) (let ((labels3060 (gen-labels2110 ids3057)) (new-vars3061 (map gen-var2152 ids3057))) (let ((nw3062 (make-binding-wrap2121 ids3057 labels3060 w3053)) (nr3063 (extend-var-env2099 labels3060 new-vars3061 r3052))) (constructor3056 s3054 (map syntax->datum ids3057) new-vars3061 (map (lambda (x3064) (chi2140 x3064 r3052 w3053 mod3055)) vals3058) (chi-body2144 exps3059 (source-wrap2133 e3051 nw3062 s3054 mod3055) nr3063 nw3062 mod3055)))))))) (lambda (e3065 r3066 w3067 s3068 mod3069) ((lambda (tmp3070) ((lambda (tmp3071) (if tmp3071 (apply (lambda (_3072 id3073 val3074 e13075 e23076) (chi-let3050 e3065 r3066 w3067 s3068 mod3069 build-let2084 id3073 val3074 (cons e13075 e23076))) tmp3071) ((lambda (tmp3080) (if (if tmp3080 (apply (lambda (_3081 f3082 id3083 val3084 e13085 e23086) (id?2104 f3082)) tmp3080) #f) (apply (lambda (_3087 f3088 id3089 val3090 e13091 e23092) (chi-let3050 e3065 r3066 w3067 s3068 mod3069 build-named-let2085 (cons f3088 id3089) val3090 (cons e13091 e23092))) tmp3080) ((lambda (_3096) (syntax-violation (quote let) "bad let" (source-wrap2133 e3065 w3067 s3068 mod3069))) tmp3070))) ($sc-dispatch tmp3070 (quote (any any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp3070 (quote (any #(each (any any)) any . each-any))))) e3065)))) (global-extend2102 (quote core) (quote letrec) (lambda (e3097 r3098 w3099 s3100 mod3101) ((lambda (tmp3102) ((lambda (tmp3103) (if tmp3103 (apply (lambda (_3104 id3105 val3106 e13107 e23108) (let ((ids3109 id3105)) (if (not (valid-bound-ids?2129 ids3109)) (syntax-violation (quote letrec) "duplicate bound variable" e3097) (let ((labels3111 (gen-labels2110 ids3109)) (new-vars3112 (map gen-var2152 ids3109))) (let ((w3113 (make-binding-wrap2121 ids3109 labels3111 w3099)) (r3114 (extend-var-env2099 labels3111 new-vars3112 r3098))) (build-letrec2086 s3100 (map syntax->datum ids3109) new-vars3112 (map (lambda (x3115) (chi2140 x3115 r3114 w3113 mod3101)) val3106) (chi-body2144 (cons e13107 e23108) (source-wrap2133 e3097 w3113 s3100 mod3101) r3114 w3113 mod3101))))))) tmp3103) ((lambda (_3118) (syntax-violation (quote letrec) "bad letrec" (source-wrap2133 e3097 w3099 s3100 mod3101))) tmp3102))) ($sc-dispatch tmp3102 (quote (any #(each (any any)) any . each-any))))) e3097))) (global-extend2102 (quote core) (quote set!) (lambda (e3119 r3120 w3121 s3122 mod3123) ((lambda (tmp3124) ((lambda (tmp3125) (if (if tmp3125 (apply (lambda (_3126 id3127 val3128) (id?2104 id3127)) tmp3125) #f) (apply (lambda (_3129 id3130 val3131) (let ((val3132 (chi2140 val3131 r3120 w3121 mod3123)) (n3133 (id-var-name2126 id3130 w3121))) (let ((b3134 (lookup2101 n3133 r3120 mod3123))) (let ((atom-key3135 (binding-type2096 b3134))) (if (memv atom-key3135 (quote (lexical))) (build-lexical-assignment2075 s3122 (syntax->datum id3130) (binding-value2097 b3134) val3132) (if (memv atom-key3135 (quote (global))) (build-global-assignment2078 s3122 n3133 val3132 mod3123) (if (memv atom-key3135 (quote (displaced-lexical))) (syntax-violation (quote set!) "identifier out of context" (wrap2132 id3130 w3121 mod3123)) (syntax-violation (quote set!) "bad set!" (source-wrap2133 e3119 w3121 s3122 mod3123))))))))) tmp3125) ((lambda (tmp3136) (if tmp3136 (apply (lambda (_3137 head3138 tail3139 val3140) (call-with-values (lambda () (syntax-type2138 head3138 r3120 (quote (())) #f #f mod3123)) (lambda (type3141 value3142 ee3143 ww3144 ss3145 modmod3146) (if (memv type3141 (quote (module-ref))) (let ((val3147 (chi2140 val3140 r3120 w3121 mod3123))) (call-with-values (lambda () (value3142 (cons head3138 tail3139))) (lambda (id3149 mod3150) (build-global-assignment2078 s3122 id3149 val3147 mod3150)))) (build-application2072 s3122 (chi2140 (list (quote #(syntax-object setter ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type value ee ww ss modmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage #(_ head tail val) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(e r w s mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) head3138) r3120 w3121 mod3123) (map (lambda (e3151) (chi2140 e3151 r3120 w3121 mod3123)) (append tail3139 (list val3140)))))))) tmp3136) ((lambda (_3153) (syntax-violation (quote set!) "bad set!" (source-wrap2133 e3119 w3121 s3122 mod3123))) tmp3124))) ($sc-dispatch tmp3124 (quote (any (any . each-any) any)))))) ($sc-dispatch tmp3124 (quote (any any any))))) e3119))) (global-extend2102 (quote module-ref) (quote @) (lambda (e3154) ((lambda (tmp3155) ((lambda (tmp3156) (if (if tmp3156 (apply (lambda (_3157 mod3158 id3159) (if (and-map id?2104 mod3158) (id?2104 id3159) #f)) tmp3156) #f) (apply (lambda (_3161 mod3162 id3163) (values (syntax->datum id3163) (syntax->datum (cons (quote #(syntax-object public ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod3162)))) tmp3156) (syntax-violation #f "source expression failed to match any pattern" tmp3155))) ($sc-dispatch tmp3155 (quote (any each-any any))))) e3154))) (global-extend2102 (quote module-ref) (quote @@) (lambda (e3165) ((lambda (tmp3166) ((lambda (tmp3167) (if (if tmp3167 (apply (lambda (_3168 mod3169 id3170) (if (and-map id?2104 mod3169) (id?2104 id3170) #f)) tmp3167) #f) (apply (lambda (_3172 mod3173 id3174) (values (syntax->datum id3174) (syntax->datum (cons (quote #(syntax-object private ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod3173)))) tmp3167) (syntax-violation #f "source expression failed to match any pattern" tmp3166))) ($sc-dispatch tmp3166 (quote (any each-any any))))) e3165))) (global-extend2102 (quote core) (quote if) (lambda (e3176 r3177 w3178 s3179 mod3180) ((lambda (tmp3181) ((lambda (tmp3182) (if tmp3182 (apply (lambda (_3183 test3184 then3185) (build-conditional2073 s3179 (chi2140 test3184 r3177 w3178 mod3180) (chi2140 then3185 r3177 w3178 mod3180) (build-void2071 #f))) tmp3182) ((lambda (tmp3186) (if tmp3186 (apply (lambda (_3187 test3188 then3189 else3190) (build-conditional2073 s3179 (chi2140 test3188 r3177 w3178 mod3180) (chi2140 then3189 r3177 w3178 mod3180) (chi2140 else3190 r3177 w3178 mod3180))) tmp3186) (syntax-violation #f "source expression failed to match any pattern" tmp3181))) ($sc-dispatch tmp3181 (quote (any any any any)))))) ($sc-dispatch tmp3181 (quote (any any any))))) e3176))) (global-extend2102 (quote begin) (quote begin) (quote ())) (global-extend2102 (quote define) (quote define) (quote ())) (global-extend2102 (quote define-syntax) (quote define-syntax) (quote ())) (global-extend2102 (quote eval-when) (quote eval-when) (quote ())) (global-extend2102 (quote core) (quote syntax-case) (letrec ((gen-syntax-case3194 (lambda (x3195 keys3196 clauses3197 r3198 mod3199) (if (null? clauses3197) (build-application2072 #f (build-primref2081 #f (quote syntax-violation)) (list #f "source expression failed to match any pattern" x3195)) ((lambda (tmp3200) ((lambda (tmp3201) (if tmp3201 (apply (lambda (pat3202 exp3203) (if (if (id?2104 pat3202) (and-map (lambda (x3204) (not (free-id=?2127 pat3202 x3204))) (cons (quote #(syntax-object ... ((top) #(ribcage #(pat exp) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x keys clauses r mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (gen-syntax-case gen-clause build-dispatch-call convert-pattern) ((top) (top) (top) (top)) ("i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) keys3196)) #f) (let ((labels3205 (list (gen-label2109))) (var3206 (gen-var2152 pat3202))) (build-application2072 #f (build-lambda2080 #f (list (syntax->datum pat3202)) (list var3206) #f (chi2140 exp3203 (extend-env2098 labels3205 (list (cons (quote syntax) (cons var3206 0))) r3198) (make-binding-wrap2121 (list pat3202) labels3205 (quote (()))) mod3199)) (list x3195))) (gen-clause3193 x3195 keys3196 (cdr clauses3197) r3198 pat3202 #t exp3203 mod3199))) tmp3201) ((lambda (tmp3207) (if tmp3207 (apply (lambda (pat3208 fender3209 exp3210) (gen-clause3193 x3195 keys3196 (cdr clauses3197) r3198 pat3208 fender3209 exp3210 mod3199)) tmp3207) ((lambda (_3211) (syntax-violation (quote syntax-case) "invalid clause" (car clauses3197))) tmp3200))) ($sc-dispatch tmp3200 (quote (any any any)))))) ($sc-dispatch tmp3200 (quote (any any))))) (car clauses3197))))) (gen-clause3193 (lambda (x3212 keys3213 clauses3214 r3215 pat3216 fender3217 exp3218 mod3219) (call-with-values (lambda () (convert-pattern3191 pat3216 keys3213)) (lambda (p3220 pvars3221) (if (not (distinct-bound-ids?2130 (map car pvars3221))) (syntax-violation (quote syntax-case) "duplicate pattern variable" pat3216) (if (not (and-map (lambda (x3222) (not (ellipsis?2149 (car x3222)))) pvars3221)) (syntax-violation (quote syntax-case) "misplaced ellipsis" pat3216) (let ((y3223 (gen-var2152 (quote tmp)))) (build-application2072 #f (build-lambda2080 #f (list (quote tmp)) (list y3223) #f (let ((y3224 (build-lexical-reference2074 (quote value) #f (quote tmp) y3223))) (build-conditional2073 #f ((lambda (tmp3225) ((lambda (tmp3226) (if tmp3226 (apply (lambda () y3224) tmp3226) ((lambda (_3227) (build-conditional2073 #f y3224 (build-dispatch-call3192 pvars3221 fender3217 y3224 r3215 mod3219) (build-data2082 #f #f))) tmp3225))) ($sc-dispatch tmp3225 (quote #(atom #t))))) fender3217) (build-dispatch-call3192 pvars3221 exp3218 y3224 r3215 mod3219) (gen-syntax-case3194 x3212 keys3213 clauses3214 r3215 mod3219)))) (list (if (eq? p3220 (quote any)) (build-application2072 #f (build-primref2081 #f (quote list)) (list x3212)) (build-application2072 #f (build-primref2081 #f (quote $sc-dispatch)) (list x3212 (build-data2082 #f p3220))))))))))))) (build-dispatch-call3192 (lambda (pvars3228 exp3229 y3230 r3231 mod3232) (let ((ids3233 (map car pvars3228)) (levels3234 (map cdr pvars3228))) (let ((labels3235 (gen-labels2110 ids3233)) (new-vars3236 (map gen-var2152 ids3233))) (build-application2072 #f (build-primref2081 #f (quote apply)) (list (build-lambda2080 #f (map syntax->datum ids3233) new-vars3236 #f (chi2140 exp3229 (extend-env2098 labels3235 (map (lambda (var3237 level3238) (cons (quote syntax) (cons var3237 level3238))) new-vars3236 (map cdr pvars3228)) r3231) (make-binding-wrap2121 ids3233 labels3235 (quote (()))) mod3232)) y3230)))))) (convert-pattern3191 (lambda (pattern3239 keys3240) (letrec ((cvt3241 (lambda (p3242 n3243 ids3244) (if (id?2104 p3242) (if (bound-id-member?2131 p3242 keys3240) (values (vector (quote free-id) p3242) ids3244) (values (quote any) (cons (cons p3242 n3243) ids3244))) ((lambda (tmp3245) ((lambda (tmp3246) (if (if tmp3246 (apply (lambda (x3247 dots3248) (ellipsis?2149 dots3248)) tmp3246) #f) (apply (lambda (x3249 dots3250) (call-with-values (lambda () (cvt3241 x3249 (fx+2063 n3243 1) ids3244)) (lambda (p3251 ids3252) (values (if (eq? p3251 (quote any)) (quote each-any) (vector (quote each) p3251)) ids3252)))) tmp3246) ((lambda (tmp3253) (if tmp3253 (apply (lambda (x3254 y3255) (call-with-values (lambda () (cvt3241 y3255 n3243 ids3244)) (lambda (y3256 ids3257) (call-with-values (lambda () (cvt3241 x3254 n3243 ids3257)) (lambda (x3258 ids3259) (values (cons x3258 y3256) ids3259)))))) tmp3253) ((lambda (tmp3260) (if tmp3260 (apply (lambda () (values (quote ()) ids3244)) tmp3260) ((lambda (tmp3261) (if tmp3261 (apply (lambda (x3262) (call-with-values (lambda () (cvt3241 x3262 n3243 ids3244)) (lambda (p3264 ids3265) (values (vector (quote vector) p3264) ids3265)))) tmp3261) ((lambda (x3266) (values (vector (quote atom) (strip2151 p3242 (quote (())))) ids3244)) tmp3245))) ($sc-dispatch tmp3245 (quote #(vector each-any)))))) ($sc-dispatch tmp3245 (quote ()))))) ($sc-dispatch tmp3245 (quote (any . any)))))) ($sc-dispatch tmp3245 (quote (any any))))) p3242))))) (cvt3241 pattern3239 0 (quote ())))))) (lambda (e3267 r3268 w3269 s3270 mod3271) (let ((e3272 (source-wrap2133 e3267 w3269 s3270 mod3271))) ((lambda (tmp3273) ((lambda (tmp3274) (if tmp3274 (apply (lambda (_3275 val3276 key3277 m3278) (if (and-map (lambda (x3279) (if (id?2104 x3279) (not (ellipsis?2149 x3279)) #f)) key3277) (let ((x3281 (gen-var2152 (quote tmp)))) (build-application2072 s3270 (build-lambda2080 #f (list (quote tmp)) (list x3281) #f (gen-syntax-case3194 (build-lexical-reference2074 (quote value) #f (quote tmp) x3281) key3277 m3278 r3268 mod3271)) (list (chi2140 val3276 r3268 (quote (())) mod3271)))) (syntax-violation (quote syntax-case) "invalid literals list" e3272))) tmp3274) (syntax-violation #f "source expression failed to match any pattern" tmp3273))) ($sc-dispatch tmp3273 (quote (any any each-any . each-any))))) e3272))))) (set! sc-expand (lambda (x3285 . rest3284) (if (if (pair? x3285) (equal? (car x3285) noexpand2061) #f) (cadr x3285) (let ((m3286 (if (null? rest3284) (quote e) (car rest3284))) (esew3287 (if (let ((t3288 (null? rest3284))) (if t3288 t3288 (null? (cdr rest3284)))) (quote (eval)) (cadr rest3284)))) (with-fluid* *mode*2062 m3286 (lambda () (chi-top2139 x3285 (quote ()) (quote ((top))) m3286 esew3287 (cons (quote hygiene) (module-name (current-module)))))))))) (set! identifier? (lambda (x3289) (nonsymbol-id?2103 x3289))) (set! datum->syntax (lambda (id3290 datum3291) (make-syntax-object2087 datum3291 (syntax-object-wrap2090 id3290) #f))) (set! syntax->datum (lambda (x3292) (strip2151 x3292 (quote (()))))) (set! generate-temporaries (lambda (ls3293) (begin (let ((x3294 ls3293)) (if (not (list? x3294)) (syntax-violation (quote generate-temporaries) "invalid argument" x3294) (if #f #f))) (map (lambda (x3295) (wrap2132 (gensym) (quote ((top))) #f)) ls3293)))) (set! free-identifier=? (lambda (x3296 y3297) (begin (let ((x3298 x3296)) (if (not (nonsymbol-id?2103 x3298)) (syntax-violation (quote free-identifier=?) "invalid argument" x3298) (if #f #f))) (let ((x3299 y3297)) (if (not (nonsymbol-id?2103 x3299)) (syntax-violation (quote free-identifier=?) "invalid argument" x3299) (if #f #f))) (free-id=?2127 x3296 y3297)))) (set! bound-identifier=? (lambda (x3300 y3301) (begin (let ((x3302 x3300)) (if (not (nonsymbol-id?2103 x3302)) (syntax-violation (quote bound-identifier=?) "invalid argument" x3302) (if #f #f))) (let ((x3303 y3301)) (if (not (nonsymbol-id?2103 x3303)) (syntax-violation (quote bound-identifier=?) "invalid argument" x3303) (if #f #f))) (bound-id=?2128 x3300 y3301)))) (set! syntax-violation (lambda (who3307 message3306 form3305 . subform3304) (begin (let ((x3308 who3307)) (if (not ((lambda (x3309) (let ((t3310 (not x3309))) (if t3310 t3310 (let ((t3311 (string? x3309))) (if t3311 t3311 (symbol? x3309)))))) x3308)) (syntax-violation (quote syntax-violation) "invalid argument" x3308) (if #f #f))) (let ((x3312 message3306)) (if (not (string? x3312)) (syntax-violation (quote syntax-violation) "invalid argument" x3312) (if #f #f))) (scm-error (quote syntax-error) (quote sc-expand) (string-append (if who3307 "~a: " "") "~a " (if (null? subform3304) "in ~a" "in subform `~s' of `~s'")) (let ((tail3313 (cons message3306 (map (lambda (x3314) (strip2151 x3314 (quote (())))) (append subform3304 (list form3305)))))) (if who3307 (cons who3307 tail3313) tail3313)) #f)))) (letrec ((match3319 (lambda (e3320 p3321 w3322 r3323 mod3324) (if (not r3323) #f (if (eq? p3321 (quote any)) (cons (wrap2132 e3320 w3322 mod3324) r3323) (if (syntax-object?2088 e3320) (match*3318 (let ((e3325 (syntax-object-expression2089 e3320))) (if (annotation? e3325) (annotation-expression e3325) e3325)) p3321 (join-wraps2123 w3322 (syntax-object-wrap2090 e3320)) r3323 (syntax-object-module2091 e3320)) (match*3318 (let ((e3326 e3320)) (if (annotation? e3326) (annotation-expression e3326) e3326)) p3321 w3322 r3323 mod3324)))))) (match*3318 (lambda (e3327 p3328 w3329 r3330 mod3331) (if (null? p3328) (if (null? e3327) r3330 #f) (if (pair? p3328) (if (pair? e3327) (match3319 (car e3327) (car p3328) w3329 (match3319 (cdr e3327) (cdr p3328) w3329 r3330 mod3331) mod3331) #f) (if (eq? p3328 (quote each-any)) (let ((l3332 (match-each-any3316 e3327 w3329 mod3331))) (if l3332 (cons l3332 r3330) #f)) (let ((atom-key3333 (vector-ref p3328 0))) (if (memv atom-key3333 (quote (each))) (if (null? e3327) (match-empty3317 (vector-ref p3328 1) r3330) (let ((l3334 (match-each3315 e3327 (vector-ref p3328 1) w3329 mod3331))) (if l3334 (letrec ((collect3335 (lambda (l3336) (if (null? (car l3336)) r3330 (cons (map car l3336) (collect3335 (map cdr l3336))))))) (collect3335 l3334)) #f))) (if (memv atom-key3333 (quote (free-id))) (if (id?2104 e3327) (if (free-id=?2127 (wrap2132 e3327 w3329 mod3331) (vector-ref p3328 1)) r3330 #f) #f) (if (memv atom-key3333 (quote (atom))) (if (equal? (vector-ref p3328 1) (strip2151 e3327 w3329)) r3330 #f) (if (memv atom-key3333 (quote (vector))) (if (vector? e3327) (match3319 (vector->list e3327) (vector-ref p3328 1) w3329 r3330 mod3331) #f) (if #f #f))))))))))) (match-empty3317 (lambda (p3337 r3338) (if (null? p3337) r3338 (if (eq? p3337 (quote any)) (cons (quote ()) r3338) (if (pair? p3337) (match-empty3317 (car p3337) (match-empty3317 (cdr p3337) r3338)) (if (eq? p3337 (quote each-any)) (cons (quote ()) r3338) (let ((atom-key3339 (vector-ref p3337 0))) (if (memv atom-key3339 (quote (each))) (match-empty3317 (vector-ref p3337 1) r3338) (if (memv atom-key3339 (quote (free-id atom))) r3338 (if (memv atom-key3339 (quote (vector))) (match-empty3317 (vector-ref p3337 1) r3338) (if #f #f))))))))))) (match-each-any3316 (lambda (e3340 w3341 mod3342) (if (annotation? e3340) (match-each-any3316 (annotation-expression e3340) w3341 mod3342) (if (pair? e3340) (let ((l3343 (match-each-any3316 (cdr e3340) w3341 mod3342))) (if l3343 (cons (wrap2132 (car e3340) w3341 mod3342) l3343) #f)) (if (null? e3340) (quote ()) (if (syntax-object?2088 e3340) (match-each-any3316 (syntax-object-expression2089 e3340) (join-wraps2123 w3341 (syntax-object-wrap2090 e3340)) mod3342) #f)))))) (match-each3315 (lambda (e3344 p3345 w3346 mod3347) (if (annotation? e3344) (match-each3315 (annotation-expression e3344) p3345 w3346 mod3347) (if (pair? e3344) (let ((first3348 (match3319 (car e3344) p3345 w3346 (quote ()) mod3347))) (if first3348 (let ((rest3349 (match-each3315 (cdr e3344) p3345 w3346 mod3347))) (if rest3349 (cons first3348 rest3349) #f)) #f)) (if (null? e3344) (quote ()) (if (syntax-object?2088 e3344) (match-each3315 (syntax-object-expression2089 e3344) p3345 (join-wraps2123 w3346 (syntax-object-wrap2090 e3344)) (syntax-object-module2091 e3344)) #f))))))) (set! $sc-dispatch (lambda (e3350 p3351) (if (eq? p3351 (quote any)) (list e3350) (if (syntax-object?2088 e3350) (match*3318 (let ((e3352 (syntax-object-expression2089 e3350))) (if (annotation? e3352) (annotation-expression e3352) e3352)) p3351 (syntax-object-wrap2090 e3350) (quote ()) (syntax-object-module2091 e3350)) (match*3318 (let ((e3353 e3350)) (if (annotation? e3353) (annotation-expression e3353) e3353)) p3351 (quote (())) (quote ()) #f)))))))))
(define with-syntax (make-syncase-macro (quote macro) (lambda (x3354) ((lambda (tmp3355) ((lambda (tmp3356) (if tmp3356 (apply (lambda (_3357 e13358 e23359) (cons (quote #(syntax-object begin ((top) #(ribcage #(_ e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e13358 e23359))) tmp3356) ((lambda (tmp3361) (if tmp3361 (apply (lambda (_3362 out3363 in3364 e13365 e23366) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in3364 (quote ()) (list out3363 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e13365 e23366))))) tmp3361) ((lambda (tmp3368) (if tmp3368 (apply (lambda (_3369 out3370 in3371 e13372 e23373) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object list ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in3371) (quote ()) (list out3370 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e13372 e23373))))) tmp3368) (syntax-violation #f "source expression failed to match any pattern" tmp3355))) ($sc-dispatch tmp3355 (quote (any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp3355 (quote (any ((any any)) any . each-any)))))) ($sc-dispatch tmp3355 (quote (any () any . each-any))))) x3354))))
(define syntax-rules (make-syncase-macro (quote macro) (lambda (x3377) ((lambda (tmp3378) ((lambda (tmp3379) (if tmp3379 (apply (lambda (_3380 k3381 keyword3382 pattern3383 template3384) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (cons (quote #(syntax-object syntax-case ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons k3381 (map (lambda (tmp3387 tmp3386) (list (cons (quote #(syntax-object dummy ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp3386) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp3387))) template3384 pattern3383)))))) tmp3379) (syntax-violation #f "source expression failed to match any pattern" tmp3378))) ($sc-dispatch tmp3378 (quote (any each-any . #(each ((any . any) any))))))) x3377))))
(define let* (make-extended-syncase-macro (module-ref (current-module) (quote let*)) (quote macro) (lambda (x3388) ((lambda (tmp3389) ((lambda (tmp3390) (if (if tmp3390 (apply (lambda (let*3391 x3392 v3393 e13394 e23395) (and-map identifier? x3392)) tmp3390) #f) (apply (lambda (let*3397 x3398 v3399 e13400 e23401) (letrec ((f3402 (lambda (bindings3403) (if (null? bindings3403) (cons (quote #(syntax-object let ((top) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote ()) (cons e13400 e23401))) ((lambda (tmp3407) ((lambda (tmp3408) (if tmp3408 (apply (lambda (body3409 binding3410) (list (quote #(syntax-object let ((top) #(ribcage #(body binding) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list binding3410) body3409)) tmp3408) (syntax-violation #f "source expression failed to match any pattern" tmp3407))) ($sc-dispatch tmp3407 (quote (any any))))) (list (f3402 (cdr bindings3403)) (car bindings3403))))))) (f3402 (map list x3398 v3399)))) tmp3390) (syntax-violation #f "source expression failed to match any pattern" tmp3389))) ($sc-dispatch tmp3389 (quote (any #(each (any any)) any . each-any))))) x3388))))
(define do (make-extended-syncase-macro (module-ref (current-module) (quote do)) (quote macro) (lambda (orig-x3411) ((lambda (tmp3412) ((lambda (tmp3413) (if tmp3413 (apply (lambda (_3414 var3415 init3416 step3417 e03418 e13419 c3420) ((lambda (tmp3421) ((lambda (tmp3422) (if tmp3422 (apply (lambda (step3423) ((lambda (tmp3424) ((lambda (tmp3425) (if tmp3425 (apply (lambda () (list (quote #(syntax-object let ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var3415 init3416) (list (quote #(syntax-object if ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object not ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e03418) (cons (quote #(syntax-object begin ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c3420 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step3423))))))) tmp3425) ((lambda (tmp3430) (if tmp3430 (apply (lambda (e13431 e23432) (list (quote #(syntax-object let ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var3415 init3416) (list (quote #(syntax-object if ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e03418 (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (cons e13431 e23432)) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c3420 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step3423))))))) tmp3430) (syntax-violation #f "source expression failed to match any pattern" tmp3424))) ($sc-dispatch tmp3424 (quote (any . each-any)))))) ($sc-dispatch tmp3424 (quote ())))) e13419)) tmp3422) (syntax-violation #f "source expression failed to match any pattern" tmp3421))) ($sc-dispatch tmp3421 (quote each-any)))) (map (lambda (v3439 s3440) ((lambda (tmp3441) ((lambda (tmp3442) (if tmp3442 (apply (lambda () v3439) tmp3442) ((lambda (tmp3443) (if tmp3443 (apply (lambda (e3444) e3444) tmp3443) ((lambda (_3445) (syntax-violation (quote do) "bad step expression" orig-x3411 s3440)) tmp3441))) ($sc-dispatch tmp3441 (quote (any)))))) ($sc-dispatch tmp3441 (quote ())))) s3440)) var3415 step3417))) tmp3413) (syntax-violation #f "source expression failed to match any pattern" tmp3412))) ($sc-dispatch tmp3412 (quote (any #(each (any any . any)) (any . each-any) . each-any))))) orig-x3411))))
(define quasiquote (make-extended-syncase-macro (module-ref (current-module) (quote quasiquote)) (quote macro) (letrec ((quasicons3448 (lambda (x3452 y3453) ((lambda (tmp3454) ((lambda (tmp3455) (if tmp3455 (apply (lambda (x3456 y3457) ((lambda (tmp3458) ((lambda (tmp3459) (if tmp3459 (apply (lambda (dy3460) ((lambda (tmp3461) ((lambda (tmp3462) (if tmp3462 (apply (lambda (dx3463) (list (quote #(syntax-object quote ((top) #(ribcage #(dx) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons dx3463 dy3460))) tmp3462) ((lambda (_3464) (if (null? dy3460) (list (quote #(syntax-object list ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x3456) (list (quote #(syntax-object cons ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x3456 y3457))) tmp3461))) ($sc-dispatch tmp3461 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) x3456)) tmp3459) ((lambda (tmp3465) (if tmp3465 (apply (lambda (stuff3466) (cons (quote #(syntax-object list ((top) #(ribcage #(stuff) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons x3456 stuff3466))) tmp3465) ((lambda (else3467) (list (quote #(syntax-object cons ((top) #(ribcage #(else) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x3456 y3457)) tmp3458))) ($sc-dispatch tmp3458 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . any)))))) ($sc-dispatch tmp3458 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) y3457)) tmp3455) (syntax-violation #f "source expression failed to match any pattern" tmp3454))) ($sc-dispatch tmp3454 (quote (any any))))) (list x3452 y3453)))) (quasiappend3449 (lambda (x3468 y3469) ((lambda (tmp3470) ((lambda (tmp3471) (if tmp3471 (apply (lambda (x3472 y3473) ((lambda (tmp3474) ((lambda (tmp3475) (if tmp3475 (apply (lambda () x3472) tmp3475) ((lambda (_3476) (list (quote #(syntax-object append ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x3472 y3473)) tmp3474))) ($sc-dispatch tmp3474 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) ()))))) y3473)) tmp3471) (syntax-violation #f "source expression failed to match any pattern" tmp3470))) ($sc-dispatch tmp3470 (quote (any any))))) (list x3468 y3469)))) (quasivector3450 (lambda (x3477) ((lambda (tmp3478) ((lambda (x3479) ((lambda (tmp3480) ((lambda (tmp3481) (if tmp3481 (apply (lambda (x3482) (list (quote #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (list->vector x3482))) tmp3481) ((lambda (tmp3484) (if tmp3484 (apply (lambda (x3485) (cons (quote #(syntax-object vector ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x3485)) tmp3484) ((lambda (_3487) (list (quote #(syntax-object list->vector ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x3479)) tmp3480))) ($sc-dispatch tmp3480 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . each-any)))))) ($sc-dispatch tmp3480 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) each-any))))) x3479)) tmp3478)) x3477))) (quasi3451 (lambda (p3488 lev3489) ((lambda (tmp3490) ((lambda (tmp3491) (if tmp3491 (apply (lambda (p3492) (if (= lev3489 0) p3492 (quasicons3448 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi3451 (list p3492) (- lev3489 1))))) tmp3491) ((lambda (tmp3493) (if tmp3493 (apply (lambda (p3494 q3495) (if (= lev3489 0) (quasiappend3449 p3494 (quasi3451 q3495 lev3489)) (quasicons3448 (quasicons3448 (quote (#(syntax-object quote ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote-splicing ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi3451 (list p3494) (- lev3489 1))) (quasi3451 q3495 lev3489)))) tmp3493) ((lambda (tmp3496) (if tmp3496 (apply (lambda (p3497) (quasicons3448 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object quasiquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi3451 (list p3497) (+ lev3489 1)))) tmp3496) ((lambda (tmp3498) (if tmp3498 (apply (lambda (p3499 q3500) (quasicons3448 (quasi3451 p3499 lev3489) (quasi3451 q3500 lev3489))) tmp3498) ((lambda (tmp3501) (if tmp3501 (apply (lambda (x3502) (quasivector3450 (quasi3451 x3502 lev3489))) tmp3501) ((lambda (p3504) (list (quote #(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) p3504)) tmp3490))) ($sc-dispatch tmp3490 (quote #(vector each-any)))))) ($sc-dispatch tmp3490 (quote (any . any)))))) ($sc-dispatch tmp3490 (quote (#(free-id #(syntax-object quasiquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any)))))) ($sc-dispatch tmp3490 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any) . any)))))) ($sc-dispatch tmp3490 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) p3488)))) (lambda (x3505) ((lambda (tmp3506) ((lambda (tmp3507) (if tmp3507 (apply (lambda (_3508 e3509) (quasi3451 e3509 0)) tmp3507) (syntax-violation #f "source expression failed to match any pattern" tmp3506))) ($sc-dispatch tmp3506 (quote (any any))))) x3505)))))
(define include (make-syncase-macro (quote macro) (lambda (x3510) (letrec ((read-file3511 (lambda (fn3512 k3513) (let ((p3514 (open-input-file fn3512))) (letrec ((f3515 (lambda (x3516) (if (eof-object? x3516) (begin (close-input-port p3514) (quote ())) (cons (datum->syntax k3513 x3516) (f3515 (read p3514))))))) (f3515 (read p3514))))))) ((lambda (tmp3517) ((lambda (tmp3518) (if tmp3518 (apply (lambda (k3519 filename3520) (let ((fn3521 (syntax->datum filename3520))) ((lambda (tmp3522) ((lambda (tmp3523) (if tmp3523 (apply (lambda (exp3524) (cons (quote #(syntax-object begin ((top) #(ribcage #(exp) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(fn) #((top)) #("i")) #(ribcage #(k filename) #((top) (top)) #("i" "i")) #(ribcage (read-file) ((top)) ("i")) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) exp3524)) tmp3523) (syntax-violation #f "source expression failed to match any pattern" tmp3522))) ($sc-dispatch tmp3522 (quote each-any)))) (read-file3511 fn3521 k3519)))) tmp3518) (syntax-violation #f "source expression failed to match any pattern" tmp3517))) ($sc-dispatch tmp3517 (quote (any any))))) x3510)))))
(define unquote (make-syncase-macro (quote macro) (lambda (x3526) ((lambda (tmp3527) ((lambda (tmp3528) (if tmp3528 (apply (lambda (_3529 e3530) (syntax-violation (quote unquote) "expression not valid outside of quasiquote" x3526)) tmp3528) (syntax-violation #f "source expression failed to match any pattern" tmp3527))) ($sc-dispatch tmp3527 (quote (any any))))) x3526))))
(define unquote-splicing (make-syncase-macro (quote macro) (lambda (x3531) ((lambda (tmp3532) ((lambda (tmp3533) (if tmp3533 (apply (lambda (_3534 e3535) (syntax-violation (quote unquote-splicing) "expression not valid outside of quasiquote" x3531)) tmp3533) (syntax-violation #f "source expression failed to match any pattern" tmp3532))) ($sc-dispatch tmp3532 (quote (any any))))) x3531))))
(define case (make-extended-syncase-macro (module-ref (current-module) (quote case)) (quote macro) (lambda (x3536) ((lambda (tmp3537) ((lambda (tmp3538) (if tmp3538 (apply (lambda (_3539 e3540 m13541 m23542) ((lambda (tmp3543) ((lambda (body3544) (list (quote #(syntax-object let ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (list (quote #(syntax-object t ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e3540)) body3544)) tmp3543)) (letrec ((f3545 (lambda (clause3546 clauses3547) (if (null? clauses3547) ((lambda (tmp3549) ((lambda (tmp3550) (if tmp3550 (apply (lambda (e13551 e23552) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e13551 e23552))) tmp3550) ((lambda (tmp3554) (if tmp3554 (apply (lambda (k3555 e13556 e23557) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k3555)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e13556 e23557)))) tmp3554) ((lambda (_3560) (syntax-violation (quote case) "bad clause" x3536 clause3546)) tmp3549))) ($sc-dispatch tmp3549 (quote (each-any any . each-any)))))) ($sc-dispatch tmp3549 (quote (#(free-id #(syntax-object else ((top) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) any . each-any))))) clause3546) ((lambda (tmp3561) ((lambda (rest3562) ((lambda (tmp3563) ((lambda (tmp3564) (if tmp3564 (apply (lambda (k3565 e13566 e23567) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k3565)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e13566 e23567)) rest3562)) tmp3564) ((lambda (_3570) (syntax-violation (quote case) "bad clause" x3536 clause3546)) tmp3563))) ($sc-dispatch tmp3563 (quote (each-any any . each-any))))) clause3546)) tmp3561)) (f3545 (car clauses3547) (cdr clauses3547))))))) (f3545 m13541 m23542)))) tmp3538) (syntax-violation #f "source expression failed to match any pattern" tmp3537))) ($sc-dispatch tmp3537 (quote (any any any . each-any))))) x3536))))
(define identifier-syntax (make-syncase-macro (quote macro) (lambda (x3571) ((lambda (tmp3572) ((lambda (tmp3573) (if tmp3573 (apply (lambda (_3574 e3575) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote ()) (list (quote #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object identifier? ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) (#(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e3575)) (list (cons _3574 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e3575 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))))))))) tmp3573) (syntax-violation #f "source expression failed to match any pattern" tmp3572))) ($sc-dispatch tmp3572 (quote (any any))))) x3571))))
