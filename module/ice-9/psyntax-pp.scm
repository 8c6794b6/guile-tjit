(eval-when (compile) (set-current-module (resolve-module (quote (guile)))))
(if #f #f)
(letrec ((and-map*1328 (lambda (f1368 first1367 . rest1366) (let ((t1369 (null? first1367))) (if t1369 t1369 (if (null? rest1366) (letrec ((andmap1370 (lambda (first1371) (let ((x1372 (car first1371)) (first1373 (cdr first1371))) (if (null? first1373) (f1368 x1372) (if (f1368 x1372) (andmap1370 first1373) #f)))))) (andmap1370 first1367)) (letrec ((andmap1374 (lambda (first1375 rest1376) (let ((x1377 (car first1375)) (xr1378 (map car rest1376)) (first1379 (cdr first1375)) (rest1380 (map cdr rest1376))) (if (null? first1379) (apply f1368 (cons x1377 xr1378)) (if (apply f1368 (cons x1377 xr1378)) (andmap1374 first1379 rest1380) #f)))))) (andmap1374 first1367 rest1366)))))))) (letrec ((lambda-var-list1473 (lambda (vars1597) (letrec ((lvl1598 (lambda (vars1599 ls1600 w1601) (if (pair? vars1599) (lvl1598 (cdr vars1599) (cons (wrap1453 (car vars1599) w1601 #f) ls1600) w1601) (if (id?1425 vars1599) (cons (wrap1453 vars1599 w1601 #f) ls1600) (if (null? vars1599) ls1600 (if (syntax-object?1409 vars1599) (lvl1598 (syntax-object-expression1410 vars1599) ls1600 (join-wraps1444 w1601 (syntax-object-wrap1411 vars1599))) (cons vars1599 ls1600)))))))) (lvl1598 vars1597 (quote ()) (quote (())))))) (gen-var1472 (lambda (id1602) (let ((id1603 (if (syntax-object?1409 id1602) (syntax-object-expression1410 id1602) id1602))) (gensym (symbol->string id1603))))) (strip1471 (lambda (x1604 w1605) (if (memq (quote top) (wrap-marks1428 w1605)) x1604 (letrec ((f1606 (lambda (x1607) (if (syntax-object?1409 x1607) (strip1471 (syntax-object-expression1410 x1607) (syntax-object-wrap1411 x1607)) (if (pair? x1607) (let ((a1608 (f1606 (car x1607))) (d1609 (f1606 (cdr x1607)))) (if (if (eq? a1608 (car x1607)) (eq? d1609 (cdr x1607)) #f) x1607 (cons a1608 d1609))) (if (vector? x1607) (let ((old1610 (vector->list x1607))) (let ((new1611 (map f1606 old1610))) (if (and-map*1328 eq? old1610 new1611) x1607 (list->vector new1611)))) x1607)))))) (f1606 x1604))))) (ellipsis?1470 (lambda (x1612) (if (nonsymbol-id?1424 x1612) (free-id=?1448 x1612 (quote #(syntax-object ... ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) #f))) (chi-void1469 (lambda () (build-void1391 #f))) (eval-local-transformer1468 (lambda (expanded1613 mod1614) (let ((p1615 (local-eval-hook1388 expanded1613 mod1614))) (if (procedure? p1615) p1615 (syntax-violation #f "nonprocedure transformer" p1615))))) (chi-local-syntax1467 (lambda (rec?1616 e1617 r1618 w1619 s1620 mod1621 k1622) ((lambda (tmp1623) ((lambda (tmp1624) (if tmp1624 (apply (lambda (_1625 id1626 val1627 e11628 e21629) (let ((ids1630 id1626)) (if (not (valid-bound-ids?1450 ids1630)) (syntax-violation #f "duplicate bound keyword" e1617) (let ((labels1632 (gen-labels1431 ids1630))) (let ((new-w1633 (make-binding-wrap1442 ids1630 labels1632 w1619))) (k1622 (cons e11628 e21629) (extend-env1419 labels1632 (let ((w1635 (if rec?1616 new-w1633 w1619)) (trans-r1636 (macros-only-env1421 r1618))) (map (lambda (x1637) (cons (quote macro) (eval-local-transformer1468 (chi1461 x1637 trans-r1636 w1635 mod1621) mod1621))) val1627)) r1618) new-w1633 s1620 mod1621)))))) tmp1624) ((lambda (_1639) (syntax-violation #f "bad local syntax definition" (source-wrap1454 e1617 w1619 s1620 mod1621))) tmp1623))) ($sc-dispatch tmp1623 (quote (any #(each (any any)) any . each-any))))) e1617))) (chi-lambda-clause1466 (lambda (e1640 docstring1641 c1642 r1643 w1644 mod1645 k1646) ((lambda (tmp1647) ((lambda (tmp1648) (if (if tmp1648 (apply (lambda (args1649 doc1650 e11651 e21652) (if (string? (syntax->datum doc1650)) (not docstring1641) #f)) tmp1648) #f) (apply (lambda (args1653 doc1654 e11655 e21656) (chi-lambda-clause1466 e1640 doc1654 (cons args1653 (cons e11655 e21656)) r1643 w1644 mod1645 k1646)) tmp1648) ((lambda (tmp1658) (if tmp1658 (apply (lambda (id1659 e11660 e21661) (let ((ids1662 id1659)) (if (not (valid-bound-ids?1450 ids1662)) (syntax-violation (quote lambda) "invalid parameter list" e1640) (let ((labels1664 (gen-labels1431 ids1662)) (new-vars1665 (map gen-var1472 ids1662))) (k1646 (map syntax->datum ids1662) new-vars1665 (if docstring1641 (syntax->datum docstring1641) #f) (chi-body1465 (cons e11660 e21661) e1640 (extend-var-env1420 labels1664 new-vars1665 r1643) (make-binding-wrap1442 ids1662 labels1664 w1644) mod1645)))))) tmp1658) ((lambda (tmp1667) (if tmp1667 (apply (lambda (ids1668 e11669 e21670) (let ((old-ids1671 (lambda-var-list1473 ids1668))) (if (not (valid-bound-ids?1450 old-ids1671)) (syntax-violation (quote lambda) "invalid parameter list" e1640) (let ((labels1672 (gen-labels1431 old-ids1671)) (new-vars1673 (map gen-var1472 old-ids1671))) (k1646 (letrec ((f1674 (lambda (ls11675 ls21676) (if (null? ls11675) (syntax->datum ls21676) (f1674 (cdr ls11675) (cons (syntax->datum (car ls11675)) ls21676)))))) (f1674 (cdr old-ids1671) (car old-ids1671))) (letrec ((f1677 (lambda (ls11678 ls21679) (if (null? ls11678) ls21679 (f1677 (cdr ls11678) (cons (car ls11678) ls21679)))))) (f1677 (cdr new-vars1673) (car new-vars1673))) (if docstring1641 (syntax->datum docstring1641) #f) (chi-body1465 (cons e11669 e21670) e1640 (extend-var-env1420 labels1672 new-vars1673 r1643) (make-binding-wrap1442 old-ids1671 labels1672 w1644) mod1645)))))) tmp1667) ((lambda (_1681) (syntax-violation (quote lambda) "bad lambda" e1640)) tmp1647))) ($sc-dispatch tmp1647 (quote (any any . each-any)))))) ($sc-dispatch tmp1647 (quote (each-any any . each-any)))))) ($sc-dispatch tmp1647 (quote (any any any . each-any))))) c1642))) (chi-body1465 (lambda (body1682 outer-form1683 r1684 w1685 mod1686) (let ((r1687 (cons (quote ("placeholder" placeholder)) r1684))) (let ((ribcage1688 (make-ribcage1432 (quote ()) (quote ()) (quote ())))) (let ((w1689 (make-wrap1427 (wrap-marks1428 w1685) (cons ribcage1688 (wrap-subst1429 w1685))))) (letrec ((parse1690 (lambda (body1691 ids1692 labels1693 var-ids1694 vars1695 vals1696 bindings1697) (if (null? body1691) (syntax-violation #f "no expressions in body" outer-form1683) (let ((e1699 (cdar body1691)) (er1700 (caar body1691))) (call-with-values (lambda () (syntax-type1459 e1699 er1700 (quote (())) (source-annotation1416 er1700) ribcage1688 mod1686 #f)) (lambda (type1701 value1702 e1703 w1704 s1705 mod1706) (if (memv type1701 (quote (define-form))) (let ((id1707 (wrap1453 value1702 w1704 mod1706)) (label1708 (gen-label1430))) (let ((var1709 (gen-var1472 id1707))) (begin (extend-ribcage!1441 ribcage1688 id1707 label1708) (parse1690 (cdr body1691) (cons id1707 ids1692) (cons label1708 labels1693) (cons id1707 var-ids1694) (cons var1709 vars1695) (cons (cons er1700 (wrap1453 e1703 w1704 mod1706)) vals1696) (cons (cons (quote lexical) var1709) bindings1697))))) (if (memv type1701 (quote (define-syntax-form))) (let ((id1710 (wrap1453 value1702 w1704 mod1706)) (label1711 (gen-label1430))) (begin (extend-ribcage!1441 ribcage1688 id1710 label1711) (parse1690 (cdr body1691) (cons id1710 ids1692) (cons label1711 labels1693) var-ids1694 vars1695 vals1696 (cons (cons (quote macro) (cons er1700 (wrap1453 e1703 w1704 mod1706))) bindings1697)))) (if (memv type1701 (quote (begin-form))) ((lambda (tmp1712) ((lambda (tmp1713) (if tmp1713 (apply (lambda (_1714 e11715) (parse1690 (letrec ((f1716 (lambda (forms1717) (if (null? forms1717) (cdr body1691) (cons (cons er1700 (wrap1453 (car forms1717) w1704 mod1706)) (f1716 (cdr forms1717))))))) (f1716 e11715)) ids1692 labels1693 var-ids1694 vars1695 vals1696 bindings1697)) tmp1713) (syntax-violation #f "source expression failed to match any pattern" tmp1712))) ($sc-dispatch tmp1712 (quote (any . each-any))))) e1703) (if (memv type1701 (quote (local-syntax-form))) (chi-local-syntax1467 value1702 e1703 er1700 w1704 s1705 mod1706 (lambda (forms1719 er1720 w1721 s1722 mod1723) (parse1690 (letrec ((f1724 (lambda (forms1725) (if (null? forms1725) (cdr body1691) (cons (cons er1720 (wrap1453 (car forms1725) w1721 mod1723)) (f1724 (cdr forms1725))))))) (f1724 forms1719)) ids1692 labels1693 var-ids1694 vars1695 vals1696 bindings1697))) (if (null? ids1692) (build-sequence1404 #f (map (lambda (x1726) (chi1461 (cdr x1726) (car x1726) (quote (())) mod1706)) (cons (cons er1700 (source-wrap1454 e1703 w1704 s1705 mod1706)) (cdr body1691)))) (begin (if (not (valid-bound-ids?1450 ids1692)) (syntax-violation #f "invalid or duplicate identifier in definition" outer-form1683)) (letrec ((loop1727 (lambda (bs1728 er-cache1729 r-cache1730) (if (not (null? bs1728)) (let ((b1731 (car bs1728))) (if (eq? (car b1731) (quote macro)) (let ((er1732 (cadr b1731))) (let ((r-cache1733 (if (eq? er1732 er-cache1729) r-cache1730 (macros-only-env1421 er1732)))) (begin (set-cdr! b1731 (eval-local-transformer1468 (chi1461 (cddr b1731) r-cache1733 (quote (())) mod1706) mod1706)) (loop1727 (cdr bs1728) er1732 r-cache1733)))) (loop1727 (cdr bs1728) er-cache1729 r-cache1730))))))) (loop1727 bindings1697 #f #f)) (set-cdr! r1687 (extend-env1419 labels1693 bindings1697 (cdr r1687))) (build-letrec1407 #f (map syntax->datum var-ids1694) vars1695 (map (lambda (x1734) (chi1461 (cdr x1734) (car x1734) (quote (())) mod1706)) vals1696) (build-sequence1404 #f (map (lambda (x1735) (chi1461 (cdr x1735) (car x1735) (quote (())) mod1706)) (cons (cons er1700 (source-wrap1454 e1703 w1704 s1705 mod1706)) (cdr body1691)))))))))))))))))) (parse1690 (map (lambda (x1698) (cons r1687 (wrap1453 x1698 w1689 mod1686))) body1682) (quote ()) (quote ()) (quote ()) (quote ()) (quote ()) (quote ())))))))) (chi-macro1464 (lambda (p1736 e1737 r1738 w1739 rib1740 mod1741) (letrec ((rebuild-macro-output1742 (lambda (x1743 m1744) (if (pair? x1743) (cons (rebuild-macro-output1742 (car x1743) m1744) (rebuild-macro-output1742 (cdr x1743) m1744)) (if (syntax-object?1409 x1743) (let ((w1745 (syntax-object-wrap1411 x1743))) (let ((ms1746 (wrap-marks1428 w1745)) (s1747 (wrap-subst1429 w1745))) (if (if (pair? ms1746) (eq? (car ms1746) #f) #f) (make-syntax-object1408 (syntax-object-expression1410 x1743) (make-wrap1427 (cdr ms1746) (if rib1740 (cons rib1740 (cdr s1747)) (cdr s1747))) (syntax-object-module1412 x1743)) (make-syntax-object1408 (syntax-object-expression1410 x1743) (make-wrap1427 (cons m1744 ms1746) (if rib1740 (cons rib1740 (cons (quote shift) s1747)) (cons (quote shift) s1747))) (let ((pmod1748 (procedure-module p1736))) (if pmod1748 (cons (quote hygiene) (module-name pmod1748)) (quote (hygiene guile)))))))) (if (vector? x1743) (let ((n1749 (vector-length x1743))) (let ((v1750 (make-vector n1749))) (letrec ((loop1751 (lambda (i1752) (if (fx=1385 i1752 n1749) (begin (if #f #f) v1750) (begin (vector-set! v1750 i1752 (rebuild-macro-output1742 (vector-ref x1743 i1752) m1744)) (loop1751 (fx+1383 i1752 1))))))) (loop1751 0)))) (if (symbol? x1743) (syntax-violation #f "encountered raw symbol in macro output" (source-wrap1454 e1737 w1739 s mod1741) x1743) x1743))))))) (rebuild-macro-output1742 (p1736 (wrap1453 e1737 (anti-mark1440 w1739) mod1741)) (string #\m))))) (chi-application1463 (lambda (x1753 e1754 r1755 w1756 s1757 mod1758) ((lambda (tmp1759) ((lambda (tmp1760) (if tmp1760 (apply (lambda (e01761 e11762) (build-application1392 s1757 x1753 (map (lambda (e1763) (chi1461 e1763 r1755 w1756 mod1758)) e11762))) tmp1760) (syntax-violation #f "source expression failed to match any pattern" tmp1759))) ($sc-dispatch tmp1759 (quote (any . each-any))))) e1754))) (chi-expr1462 (lambda (type1765 value1766 e1767 r1768 w1769 s1770 mod1771) (if (memv type1765 (quote (lexical))) (build-lexical-reference1394 (quote value) s1770 e1767 value1766) (if (memv type1765 (quote (core core-form))) (value1766 e1767 r1768 w1769 s1770 mod1771) (if (memv type1765 (quote (module-ref))) (call-with-values (lambda () (value1766 e1767)) (lambda (id1772 mod1773) (build-global-reference1397 s1770 id1772 mod1773))) (if (memv type1765 (quote (lexical-call))) (chi-application1463 (build-lexical-reference1394 (quote fun) (source-annotation1416 (car e1767)) (car e1767) value1766) e1767 r1768 w1769 s1770 mod1771) (if (memv type1765 (quote (global-call))) (chi-application1463 (build-global-reference1397 (source-annotation1416 (car e1767)) (if (syntax-object?1409 value1766) (syntax-object-expression1410 value1766) value1766) (if (syntax-object?1409 value1766) (syntax-object-module1412 value1766) mod1771)) e1767 r1768 w1769 s1770 mod1771) (if (memv type1765 (quote (constant))) (build-data1403 s1770 (strip1471 (source-wrap1454 e1767 w1769 s1770 mod1771) (quote (())))) (if (memv type1765 (quote (global))) (build-global-reference1397 s1770 value1766 mod1771) (if (memv type1765 (quote (call))) (chi-application1463 (chi1461 (car e1767) r1768 w1769 mod1771) e1767 r1768 w1769 s1770 mod1771) (if (memv type1765 (quote (begin-form))) ((lambda (tmp1774) ((lambda (tmp1775) (if tmp1775 (apply (lambda (_1776 e11777 e21778) (chi-sequence1455 (cons e11777 e21778) r1768 w1769 s1770 mod1771)) tmp1775) (syntax-violation #f "source expression failed to match any pattern" tmp1774))) ($sc-dispatch tmp1774 (quote (any any . each-any))))) e1767) (if (memv type1765 (quote (local-syntax-form))) (chi-local-syntax1467 value1766 e1767 r1768 w1769 s1770 mod1771 chi-sequence1455) (if (memv type1765 (quote (eval-when-form))) ((lambda (tmp1780) ((lambda (tmp1781) (if tmp1781 (apply (lambda (_1782 x1783 e11784 e21785) (let ((when-list1786 (chi-when-list1458 e1767 x1783 w1769))) (if (memq (quote eval) when-list1786) (chi-sequence1455 (cons e11784 e21785) r1768 w1769 s1770 mod1771) (chi-void1469)))) tmp1781) (syntax-violation #f "source expression failed to match any pattern" tmp1780))) ($sc-dispatch tmp1780 (quote (any each-any any . each-any))))) e1767) (if (memv type1765 (quote (define-form define-syntax-form))) (syntax-violation #f "definition in expression context" e1767 (wrap1453 value1766 w1769 mod1771)) (if (memv type1765 (quote (syntax))) (syntax-violation #f "reference to pattern variable outside syntax form" (source-wrap1454 e1767 w1769 s1770 mod1771)) (if (memv type1765 (quote (displaced-lexical))) (syntax-violation #f "reference to identifier outside its scope" (source-wrap1454 e1767 w1769 s1770 mod1771)) (syntax-violation #f "unexpected syntax" (source-wrap1454 e1767 w1769 s1770 mod1771)))))))))))))))))) (chi1461 (lambda (e1789 r1790 w1791 mod1792) (call-with-values (lambda () (syntax-type1459 e1789 r1790 w1791 (source-annotation1416 e1789) #f mod1792 #f)) (lambda (type1793 value1794 e1795 w1796 s1797 mod1798) (chi-expr1462 type1793 value1794 e1795 r1790 w1796 s1797 mod1798))))) (chi-top1460 (lambda (e1799 r1800 w1801 m1802 esew1803 mod1804) (call-with-values (lambda () (syntax-type1459 e1799 r1800 w1801 (source-annotation1416 e1799) #f mod1804 #f)) (lambda (type1812 value1813 e1814 w1815 s1816 mod1817) (if (memv type1812 (quote (begin-form))) ((lambda (tmp1818) ((lambda (tmp1819) (if tmp1819 (apply (lambda (_1820) (chi-void1469)) tmp1819) ((lambda (tmp1821) (if tmp1821 (apply (lambda (_1822 e11823 e21824) (chi-top-sequence1456 (cons e11823 e21824) r1800 w1815 s1816 m1802 esew1803 mod1817)) tmp1821) (syntax-violation #f "source expression failed to match any pattern" tmp1818))) ($sc-dispatch tmp1818 (quote (any any . each-any)))))) ($sc-dispatch tmp1818 (quote (any))))) e1814) (if (memv type1812 (quote (local-syntax-form))) (chi-local-syntax1467 value1813 e1814 r1800 w1815 s1816 mod1817 (lambda (body1826 r1827 w1828 s1829 mod1830) (chi-top-sequence1456 body1826 r1827 w1828 s1829 m1802 esew1803 mod1830))) (if (memv type1812 (quote (eval-when-form))) ((lambda (tmp1831) ((lambda (tmp1832) (if tmp1832 (apply (lambda (_1833 x1834 e11835 e21836) (let ((when-list1837 (chi-when-list1458 e1814 x1834 w1815)) (body1838 (cons e11835 e21836))) (if (eq? m1802 (quote e)) (if (memq (quote eval) when-list1837) (chi-top-sequence1456 body1838 r1800 w1815 s1816 (quote e) (quote (eval)) mod1817) (chi-void1469)) (if (memq (quote load) when-list1837) (if (let ((t1841 (memq (quote compile) when-list1837))) (if t1841 t1841 (if (eq? m1802 (quote c&e)) (memq (quote eval) when-list1837) #f))) (chi-top-sequence1456 body1838 r1800 w1815 s1816 (quote c&e) (quote (compile load)) mod1817) (if (memq m1802 (quote (c c&e))) (chi-top-sequence1456 body1838 r1800 w1815 s1816 (quote c) (quote (load)) mod1817) (chi-void1469))) (if (let ((t1842 (memq (quote compile) when-list1837))) (if t1842 t1842 (if (eq? m1802 (quote c&e)) (memq (quote eval) when-list1837) #f))) (begin (top-level-eval-hook1387 (chi-top-sequence1456 body1838 r1800 w1815 s1816 (quote e) (quote (eval)) mod1817) mod1817) (chi-void1469)) (chi-void1469)))))) tmp1832) (syntax-violation #f "source expression failed to match any pattern" tmp1831))) ($sc-dispatch tmp1831 (quote (any each-any any . each-any))))) e1814) (if (memv type1812 (quote (define-syntax-form))) (let ((n1843 (id-var-name1447 value1813 w1815)) (r1844 (macros-only-env1421 r1800))) (if (memv m1802 (quote (c))) (if (memq (quote compile) esew1803) (let ((e1845 (chi-install-global1457 n1843 (chi1461 e1814 r1844 w1815 mod1817)))) (begin (top-level-eval-hook1387 e1845 mod1817) (if (memq (quote load) esew1803) e1845 (chi-void1469)))) (if (memq (quote load) esew1803) (chi-install-global1457 n1843 (chi1461 e1814 r1844 w1815 mod1817)) (chi-void1469))) (if (memv m1802 (quote (c&e))) (let ((e1846 (chi-install-global1457 n1843 (chi1461 e1814 r1844 w1815 mod1817)))) (begin (top-level-eval-hook1387 e1846 mod1817) e1846)) (begin (if (memq (quote eval) esew1803) (top-level-eval-hook1387 (chi-install-global1457 n1843 (chi1461 e1814 r1844 w1815 mod1817)) mod1817)) (chi-void1469))))) (if (memv type1812 (quote (define-form))) (let ((n1847 (id-var-name1447 value1813 w1815))) (let ((type1848 (binding-type1417 (lookup1422 n1847 r1800 mod1817)))) (if (memv type1848 (quote (global core macro module-ref))) (begin (if (if (not (module-local-variable (current-module) n1847)) (current-module) #f) (module-define! (current-module) n1847 #f)) (let ((x1849 (build-global-definition1400 s1816 n1847 (chi1461 e1814 r1800 w1815 mod1817)))) (begin (if (eq? m1802 (quote c&e)) (top-level-eval-hook1387 x1849 mod1817)) x1849))) (if (memv type1848 (quote (displaced-lexical))) (syntax-violation #f "identifier out of context" e1814 (wrap1453 value1813 w1815 mod1817)) (syntax-violation #f "cannot define keyword at top level" e1814 (wrap1453 value1813 w1815 mod1817)))))) (let ((x1850 (chi-expr1462 type1812 value1813 e1814 r1800 w1815 s1816 mod1817))) (begin (if (eq? m1802 (quote c&e)) (top-level-eval-hook1387 x1850 mod1817)) x1850))))))))))) (syntax-type1459 (lambda (e1851 r1852 w1853 s1854 rib1855 mod1856 for-car?1857) (if (symbol? e1851) (let ((n1858 (id-var-name1447 e1851 w1853))) (let ((b1859 (lookup1422 n1858 r1852 mod1856))) (let ((type1860 (binding-type1417 b1859))) (if (memv type1860 (quote (lexical))) (values type1860 (binding-value1418 b1859) e1851 w1853 s1854 mod1856) (if (memv type1860 (quote (global))) (values type1860 n1858 e1851 w1853 s1854 mod1856) (if (memv type1860 (quote (macro))) (if for-car?1857 (values type1860 (binding-value1418 b1859) e1851 w1853 s1854 mod1856) (syntax-type1459 (chi-macro1464 (binding-value1418 b1859) e1851 r1852 w1853 rib1855 mod1856) r1852 (quote (())) s1854 rib1855 mod1856 #f)) (values type1860 (binding-value1418 b1859) e1851 w1853 s1854 mod1856))))))) (if (pair? e1851) (let ((first1861 (car e1851))) (call-with-values (lambda () (syntax-type1459 first1861 r1852 w1853 s1854 rib1855 mod1856 #t)) (lambda (ftype1862 fval1863 fe1864 fw1865 fs1866 fmod1867) (if (memv ftype1862 (quote (lexical))) (values (quote lexical-call) fval1863 e1851 w1853 s1854 mod1856) (if (memv ftype1862 (quote (global))) (values (quote global-call) (make-syntax-object1408 fval1863 w1853 fmod1867) e1851 w1853 s1854 mod1856) (if (memv ftype1862 (quote (macro))) (syntax-type1459 (chi-macro1464 fval1863 e1851 r1852 w1853 rib1855 mod1856) r1852 (quote (())) s1854 rib1855 mod1856 for-car?1857) (if (memv ftype1862 (quote (module-ref))) (call-with-values (lambda () (fval1863 e1851)) (lambda (sym1868 mod1869) (syntax-type1459 sym1868 r1852 w1853 s1854 rib1855 mod1869 for-car?1857))) (if (memv ftype1862 (quote (core))) (values (quote core-form) fval1863 e1851 w1853 s1854 mod1856) (if (memv ftype1862 (quote (local-syntax))) (values (quote local-syntax-form) fval1863 e1851 w1853 s1854 mod1856) (if (memv ftype1862 (quote (begin))) (values (quote begin-form) #f e1851 w1853 s1854 mod1856) (if (memv ftype1862 (quote (eval-when))) (values (quote eval-when-form) #f e1851 w1853 s1854 mod1856) (if (memv ftype1862 (quote (define))) ((lambda (tmp1870) ((lambda (tmp1871) (if (if tmp1871 (apply (lambda (_1872 name1873 val1874) (id?1425 name1873)) tmp1871) #f) (apply (lambda (_1875 name1876 val1877) (values (quote define-form) name1876 val1877 w1853 s1854 mod1856)) tmp1871) ((lambda (tmp1878) (if (if tmp1878 (apply (lambda (_1879 name1880 args1881 e11882 e21883) (if (id?1425 name1880) (valid-bound-ids?1450 (lambda-var-list1473 args1881)) #f)) tmp1878) #f) (apply (lambda (_1884 name1885 args1886 e11887 e21888) (values (quote define-form) (wrap1453 name1885 w1853 mod1856) (cons (quote #(syntax-object lambda ((top) #(ribcage #(_ name args e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(ftype fval fe fw fs fmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(e r w s rib mod for-car?) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) (wrap1453 (cons args1886 (cons e11887 e21888)) w1853 mod1856)) (quote (())) s1854 mod1856)) tmp1878) ((lambda (tmp1890) (if (if tmp1890 (apply (lambda (_1891 name1892) (id?1425 name1892)) tmp1890) #f) (apply (lambda (_1893 name1894) (values (quote define-form) (wrap1453 name1894 w1853 mod1856) (quote (#(syntax-object if ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(ftype fval fe fw fs fmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(e r w s rib mod for-car?) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)) #(syntax-object #f ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(ftype fval fe fw fs fmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(e r w s rib mod for-car?) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)) #(syntax-object #f ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(ftype fval fe fw fs fmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(e r w s rib mod for-car?) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote (())) s1854 mod1856)) tmp1890) (syntax-violation #f "source expression failed to match any pattern" tmp1870))) ($sc-dispatch tmp1870 (quote (any any)))))) ($sc-dispatch tmp1870 (quote (any (any . any) any . each-any)))))) ($sc-dispatch tmp1870 (quote (any any any))))) e1851) (if (memv ftype1862 (quote (define-syntax))) ((lambda (tmp1895) ((lambda (tmp1896) (if (if tmp1896 (apply (lambda (_1897 name1898 val1899) (id?1425 name1898)) tmp1896) #f) (apply (lambda (_1900 name1901 val1902) (values (quote define-syntax-form) name1901 val1902 w1853 s1854 mod1856)) tmp1896) (syntax-violation #f "source expression failed to match any pattern" tmp1895))) ($sc-dispatch tmp1895 (quote (any any any))))) e1851) (values (quote call) #f e1851 w1853 s1854 mod1856)))))))))))))) (if (syntax-object?1409 e1851) (syntax-type1459 (syntax-object-expression1410 e1851) r1852 (join-wraps1444 w1853 (syntax-object-wrap1411 e1851)) s1854 rib1855 (let ((t1903 (syntax-object-module1412 e1851))) (if t1903 t1903 mod1856)) for-car?1857) (if (self-evaluating? e1851) (values (quote constant) #f e1851 w1853 s1854 mod1856) (values (quote other) #f e1851 w1853 s1854 mod1856))))))) (chi-when-list1458 (lambda (e1904 when-list1905 w1906) (letrec ((f1907 (lambda (when-list1908 situations1909) (if (null? when-list1908) situations1909 (f1907 (cdr when-list1908) (cons (let ((x1910 (car when-list1908))) (if (free-id=?1448 x1910 (quote #(syntax-object compile ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote compile) (if (free-id=?1448 x1910 (quote #(syntax-object load ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote load) (if (free-id=?1448 x1910 (quote #(syntax-object eval ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote eval) (syntax-violation (quote eval-when) "invalid situation" e1904 (wrap1453 x1910 w1906 #f)))))) situations1909)))))) (f1907 when-list1905 (quote ()))))) (chi-install-global1457 (lambda (name1911 e1912) (build-global-definition1400 #f name1911 (if (let ((v1913 (module-variable (current-module) name1911))) (if v1913 (if (variable-bound? v1913) (if (macro? (variable-ref v1913)) (not (eq? (macro-type (variable-ref v1913)) (quote syncase-macro))) #f) #f) #f)) (build-application1392 #f (build-primref1402 #f (quote make-extended-syncase-macro)) (list (build-application1392 #f (build-primref1402 #f (quote module-ref)) (list (build-application1392 #f (build-primref1402 #f (quote current-module)) (quote ())) (build-data1403 #f name1911))) (build-data1403 #f (quote macro)) e1912)) (build-application1392 #f (build-primref1402 #f (quote make-syncase-macro)) (list (build-data1403 #f (quote macro)) e1912)))))) (chi-top-sequence1456 (lambda (body1914 r1915 w1916 s1917 m1918 esew1919 mod1920) (build-sequence1404 s1917 (letrec ((dobody1921 (lambda (body1922 r1923 w1924 m1925 esew1926 mod1927) (if (null? body1922) (quote ()) (let ((first1928 (chi-top1460 (car body1922) r1923 w1924 m1925 esew1926 mod1927))) (cons first1928 (dobody1921 (cdr body1922) r1923 w1924 m1925 esew1926 mod1927))))))) (dobody1921 body1914 r1915 w1916 m1918 esew1919 mod1920))))) (chi-sequence1455 (lambda (body1929 r1930 w1931 s1932 mod1933) (build-sequence1404 s1932 (letrec ((dobody1934 (lambda (body1935 r1936 w1937 mod1938) (if (null? body1935) (quote ()) (let ((first1939 (chi1461 (car body1935) r1936 w1937 mod1938))) (cons first1939 (dobody1934 (cdr body1935) r1936 w1937 mod1938))))))) (dobody1934 body1929 r1930 w1931 mod1933))))) (source-wrap1454 (lambda (x1940 w1941 s1942 defmod1943) (begin (if (if s1942 (pair? x1940) #f) (set-source-properties! x1940 s1942)) (wrap1453 x1940 w1941 defmod1943)))) (wrap1453 (lambda (x1944 w1945 defmod1946) (if (if (null? (wrap-marks1428 w1945)) (null? (wrap-subst1429 w1945)) #f) x1944 (if (syntax-object?1409 x1944) (make-syntax-object1408 (syntax-object-expression1410 x1944) (join-wraps1444 w1945 (syntax-object-wrap1411 x1944)) (syntax-object-module1412 x1944)) (if (null? x1944) x1944 (make-syntax-object1408 x1944 w1945 defmod1946)))))) (bound-id-member?1452 (lambda (x1947 list1948) (if (not (null? list1948)) (let ((t1949 (bound-id=?1449 x1947 (car list1948)))) (if t1949 t1949 (bound-id-member?1452 x1947 (cdr list1948)))) #f))) (distinct-bound-ids?1451 (lambda (ids1950) (letrec ((distinct?1951 (lambda (ids1952) (let ((t1953 (null? ids1952))) (if t1953 t1953 (if (not (bound-id-member?1452 (car ids1952) (cdr ids1952))) (distinct?1951 (cdr ids1952)) #f)))))) (distinct?1951 ids1950)))) (valid-bound-ids?1450 (lambda (ids1954) (if (letrec ((all-ids?1955 (lambda (ids1956) (let ((t1957 (null? ids1956))) (if t1957 t1957 (if (id?1425 (car ids1956)) (all-ids?1955 (cdr ids1956)) #f)))))) (all-ids?1955 ids1954)) (distinct-bound-ids?1451 ids1954) #f))) (bound-id=?1449 (lambda (i1958 j1959) (if (if (syntax-object?1409 i1958) (syntax-object?1409 j1959) #f) (if (eq? (syntax-object-expression1410 i1958) (syntax-object-expression1410 j1959)) (same-marks?1446 (wrap-marks1428 (syntax-object-wrap1411 i1958)) (wrap-marks1428 (syntax-object-wrap1411 j1959))) #f) (eq? i1958 j1959)))) (free-id=?1448 (lambda (i1960 j1961) (if (eq? (let ((x1962 i1960)) (if (syntax-object?1409 x1962) (syntax-object-expression1410 x1962) x1962)) (let ((x1963 j1961)) (if (syntax-object?1409 x1963) (syntax-object-expression1410 x1963) x1963))) (eq? (id-var-name1447 i1960 (quote (()))) (id-var-name1447 j1961 (quote (())))) #f))) (id-var-name1447 (lambda (id1964 w1965) (letrec ((search-vector-rib1968 (lambda (sym1974 subst1975 marks1976 symnames1977 ribcage1978) (let ((n1979 (vector-length symnames1977))) (letrec ((f1980 (lambda (i1981) (if (fx=1385 i1981 n1979) (search1966 sym1974 (cdr subst1975) marks1976) (if (if (eq? (vector-ref symnames1977 i1981) sym1974) (same-marks?1446 marks1976 (vector-ref (ribcage-marks1435 ribcage1978) i1981)) #f) (values (vector-ref (ribcage-labels1436 ribcage1978) i1981) marks1976) (f1980 (fx+1383 i1981 1))))))) (f1980 0))))) (search-list-rib1967 (lambda (sym1982 subst1983 marks1984 symnames1985 ribcage1986) (letrec ((f1987 (lambda (symnames1988 i1989) (if (null? symnames1988) (search1966 sym1982 (cdr subst1983) marks1984) (if (if (eq? (car symnames1988) sym1982) (same-marks?1446 marks1984 (list-ref (ribcage-marks1435 ribcage1986) i1989)) #f) (values (list-ref (ribcage-labels1436 ribcage1986) i1989) marks1984) (f1987 (cdr symnames1988) (fx+1383 i1989 1))))))) (f1987 symnames1985 0)))) (search1966 (lambda (sym1990 subst1991 marks1992) (if (null? subst1991) (values #f marks1992) (let ((fst1993 (car subst1991))) (if (eq? fst1993 (quote shift)) (search1966 sym1990 (cdr subst1991) (cdr marks1992)) (let ((symnames1994 (ribcage-symnames1434 fst1993))) (if (vector? symnames1994) (search-vector-rib1968 sym1990 subst1991 marks1992 symnames1994 fst1993) (search-list-rib1967 sym1990 subst1991 marks1992 symnames1994 fst1993))))))))) (if (symbol? id1964) (let ((t1995 (call-with-values (lambda () (search1966 id1964 (wrap-subst1429 w1965) (wrap-marks1428 w1965))) (lambda (x1997 . ignore1996) x1997)))) (if t1995 t1995 id1964)) (if (syntax-object?1409 id1964) (let ((id1998 (syntax-object-expression1410 id1964)) (w11999 (syntax-object-wrap1411 id1964))) (let ((marks2000 (join-marks1445 (wrap-marks1428 w1965) (wrap-marks1428 w11999)))) (call-with-values (lambda () (search1966 id1998 (wrap-subst1429 w1965) marks2000)) (lambda (new-id2001 marks2002) (let ((t2003 new-id2001)) (if t2003 t2003 (let ((t2004 (call-with-values (lambda () (search1966 id1998 (wrap-subst1429 w11999) marks2002)) (lambda (x2006 . ignore2005) x2006)))) (if t2004 t2004 id1998)))))))) (syntax-violation (quote id-var-name) "invalid id" id1964)))))) (same-marks?1446 (lambda (x2007 y2008) (let ((t2009 (eq? x2007 y2008))) (if t2009 t2009 (if (not (null? x2007)) (if (not (null? y2008)) (if (eq? (car x2007) (car y2008)) (same-marks?1446 (cdr x2007) (cdr y2008)) #f) #f) #f))))) (join-marks1445 (lambda (m12010 m22011) (smart-append1443 m12010 m22011))) (join-wraps1444 (lambda (w12012 w22013) (let ((m12014 (wrap-marks1428 w12012)) (s12015 (wrap-subst1429 w12012))) (if (null? m12014) (if (null? s12015) w22013 (make-wrap1427 (wrap-marks1428 w22013) (smart-append1443 s12015 (wrap-subst1429 w22013)))) (make-wrap1427 (smart-append1443 m12014 (wrap-marks1428 w22013)) (smart-append1443 s12015 (wrap-subst1429 w22013))))))) (smart-append1443 (lambda (m12016 m22017) (if (null? m22017) m12016 (append m12016 m22017)))) (make-binding-wrap1442 (lambda (ids2018 labels2019 w2020) (if (null? ids2018) w2020 (make-wrap1427 (wrap-marks1428 w2020) (cons (let ((labelvec2021 (list->vector labels2019))) (let ((n2022 (vector-length labelvec2021))) (let ((symnamevec2023 (make-vector n2022)) (marksvec2024 (make-vector n2022))) (begin (letrec ((f2025 (lambda (ids2026 i2027) (if (not (null? ids2026)) (call-with-values (lambda () (id-sym-name&marks1426 (car ids2026) w2020)) (lambda (symname2028 marks2029) (begin (vector-set! symnamevec2023 i2027 symname2028) (vector-set! marksvec2024 i2027 marks2029) (f2025 (cdr ids2026) (fx+1383 i2027 1))))))))) (f2025 ids2018 0)) (make-ribcage1432 symnamevec2023 marksvec2024 labelvec2021))))) (wrap-subst1429 w2020)))))) (extend-ribcage!1441 (lambda (ribcage2030 id2031 label2032) (begin (set-ribcage-symnames!1437 ribcage2030 (cons (syntax-object-expression1410 id2031) (ribcage-symnames1434 ribcage2030))) (set-ribcage-marks!1438 ribcage2030 (cons (wrap-marks1428 (syntax-object-wrap1411 id2031)) (ribcage-marks1435 ribcage2030))) (set-ribcage-labels!1439 ribcage2030 (cons label2032 (ribcage-labels1436 ribcage2030)))))) (anti-mark1440 (lambda (w2033) (make-wrap1427 (cons #f (wrap-marks1428 w2033)) (cons (quote shift) (wrap-subst1429 w2033))))) (set-ribcage-labels!1439 (lambda (x2034 update2035) (vector-set! x2034 3 update2035))) (set-ribcage-marks!1438 (lambda (x2036 update2037) (vector-set! x2036 2 update2037))) (set-ribcage-symnames!1437 (lambda (x2038 update2039) (vector-set! x2038 1 update2039))) (ribcage-labels1436 (lambda (x2040) (vector-ref x2040 3))) (ribcage-marks1435 (lambda (x2041) (vector-ref x2041 2))) (ribcage-symnames1434 (lambda (x2042) (vector-ref x2042 1))) (ribcage?1433 (lambda (x2043) (if (vector? x2043) (if (= (vector-length x2043) 4) (eq? (vector-ref x2043 0) (quote ribcage)) #f) #f))) (make-ribcage1432 (lambda (symnames2044 marks2045 labels2046) (vector (quote ribcage) symnames2044 marks2045 labels2046))) (gen-labels1431 (lambda (ls2047) (if (null? ls2047) (quote ()) (cons (gen-label1430) (gen-labels1431 (cdr ls2047)))))) (gen-label1430 (lambda () (string #\i))) (wrap-subst1429 cdr) (wrap-marks1428 car) (make-wrap1427 cons) (id-sym-name&marks1426 (lambda (x2048 w2049) (if (syntax-object?1409 x2048) (values (syntax-object-expression1410 x2048) (join-marks1445 (wrap-marks1428 w2049) (wrap-marks1428 (syntax-object-wrap1411 x2048)))) (values x2048 (wrap-marks1428 w2049))))) (id?1425 (lambda (x2050) (if (symbol? x2050) #t (if (syntax-object?1409 x2050) (symbol? (syntax-object-expression1410 x2050)) #f)))) (nonsymbol-id?1424 (lambda (x2051) (if (syntax-object?1409 x2051) (symbol? (syntax-object-expression1410 x2051)) #f))) (global-extend1423 (lambda (type2052 sym2053 val2054) (put-global-definition-hook1389 sym2053 type2052 val2054))) (lookup1422 (lambda (x2055 r2056 mod2057) (let ((t2058 (assq x2055 r2056))) (if t2058 (cdr t2058) (if (symbol? x2055) (let ((t2059 (get-global-definition-hook1390 x2055 mod2057))) (if t2059 t2059 (quote (global)))) (quote (displaced-lexical))))))) (macros-only-env1421 (lambda (r2060) (if (null? r2060) (quote ()) (let ((a2061 (car r2060))) (if (eq? (cadr a2061) (quote macro)) (cons a2061 (macros-only-env1421 (cdr r2060))) (macros-only-env1421 (cdr r2060))))))) (extend-var-env1420 (lambda (labels2062 vars2063 r2064) (if (null? labels2062) r2064 (extend-var-env1420 (cdr labels2062) (cdr vars2063) (cons (cons (car labels2062) (cons (quote lexical) (car vars2063))) r2064))))) (extend-env1419 (lambda (labels2065 bindings2066 r2067) (if (null? labels2065) r2067 (extend-env1419 (cdr labels2065) (cdr bindings2066) (cons (cons (car labels2065) (car bindings2066)) r2067))))) (binding-value1418 cdr) (binding-type1417 car) (source-annotation1416 (lambda (x2068) (if (syntax-object?1409 x2068) (source-annotation1416 (syntax-object-expression1410 x2068)) (if (pair? x2068) (let ((props2069 (source-properties x2068))) (if (pair? props2069) props2069 #f)) #f)))) (set-syntax-object-module!1415 (lambda (x2070 update2071) (vector-set! x2070 3 update2071))) (set-syntax-object-wrap!1414 (lambda (x2072 update2073) (vector-set! x2072 2 update2073))) (set-syntax-object-expression!1413 (lambda (x2074 update2075) (vector-set! x2074 1 update2075))) (syntax-object-module1412 (lambda (x2076) (vector-ref x2076 3))) (syntax-object-wrap1411 (lambda (x2077) (vector-ref x2077 2))) (syntax-object-expression1410 (lambda (x2078) (vector-ref x2078 1))) (syntax-object?1409 (lambda (x2079) (if (vector? x2079) (if (= (vector-length x2079) 4) (eq? (vector-ref x2079 0) (quote syntax-object)) #f) #f))) (make-syntax-object1408 (lambda (expression2080 wrap2081 module2082) (vector (quote syntax-object) expression2080 wrap2081 module2082))) (build-letrec1407 (lambda (src2083 ids2084 vars2085 val-exps2086 body-exp2087) (if (null? vars2085) body-exp2087 (let ((atom-key2088 (fluid-ref *mode*1382))) (if (memv atom-key2088 (quote (c))) (begin (for-each maybe-name-value!1399 ids2084 val-exps2086) ((@ (language tree-il) make-letrec) src2083 ids2084 vars2085 val-exps2086 body-exp2087)) (list (quote letrec) (map list vars2085 val-exps2086) body-exp2087)))))) (build-named-let1406 (lambda (src2089 ids2090 vars2091 val-exps2092 body-exp2093) (let ((f2094 (car vars2091)) (f-name2095 (car ids2090)) (vars2096 (cdr vars2091)) (ids2097 (cdr ids2090))) (let ((atom-key2098 (fluid-ref *mode*1382))) (if (memv atom-key2098 (quote (c))) (let ((proc2099 (build-lambda1401 src2089 ids2097 vars2096 #f body-exp2093))) (begin (maybe-name-value!1399 f-name2095 proc2099) (for-each maybe-name-value!1399 ids2097 val-exps2092) ((@ (language tree-il) make-letrec) src2089 (list f-name2095) (list f2094) (list proc2099) (build-application1392 src2089 (build-lexical-reference1394 (quote fun) src2089 f-name2095 f2094) val-exps2092)))) (list (quote let) f2094 (map list vars2096 val-exps2092) body-exp2093)))))) (build-let1405 (lambda (src2100 ids2101 vars2102 val-exps2103 body-exp2104) (if (null? vars2102) body-exp2104 (let ((atom-key2105 (fluid-ref *mode*1382))) (if (memv atom-key2105 (quote (c))) (begin (for-each maybe-name-value!1399 ids2101 val-exps2103) ((@ (language tree-il) make-let) src2100 ids2101 vars2102 val-exps2103 body-exp2104)) (list (quote let) (map list vars2102 val-exps2103) body-exp2104)))))) (build-sequence1404 (lambda (src2106 exps2107) (if (null? (cdr exps2107)) (car exps2107) (let ((atom-key2108 (fluid-ref *mode*1382))) (if (memv atom-key2108 (quote (c))) ((@ (language tree-il) make-sequence) src2106 exps2107) (cons (quote begin) exps2107)))))) (build-data1403 (lambda (src2109 exp2110) (let ((atom-key2111 (fluid-ref *mode*1382))) (if (memv atom-key2111 (quote (c))) ((@ (language tree-il) make-const) src2109 exp2110) (if (if (self-evaluating? exp2110) (not (vector? exp2110)) #f) exp2110 (list (quote quote) exp2110)))))) (build-primref1402 (lambda (src2112 name2113) (if (equal? (module-name (current-module)) (quote (guile))) (let ((atom-key2114 (fluid-ref *mode*1382))) (if (memv atom-key2114 (quote (c))) ((@ (language tree-il) make-toplevel-ref) src2112 name2113) name2113)) (let ((atom-key2115 (fluid-ref *mode*1382))) (if (memv atom-key2115 (quote (c))) ((@ (language tree-il) make-module-ref) src2112 (quote (guile)) name2113 #f) (list (quote @@) (quote (guile)) name2113)))))) (build-lambda1401 (lambda (src2116 ids2117 vars2118 docstring2119 exp2120) (let ((atom-key2121 (fluid-ref *mode*1382))) (if (memv atom-key2121 (quote (c))) ((@ (language tree-il) make-lambda) src2116 ids2117 vars2118 (if docstring2119 (list (cons (quote documentation) docstring2119)) (quote ())) exp2120) (cons (quote lambda) (cons vars2118 (append (if docstring2119 (list docstring2119) (quote ())) (list exp2120)))))))) (build-global-definition1400 (lambda (source2122 var2123 exp2124) (let ((atom-key2125 (fluid-ref *mode*1382))) (if (memv atom-key2125 (quote (c))) (begin (maybe-name-value!1399 var2123 exp2124) ((@ (language tree-il) make-toplevel-define) source2122 var2123 exp2124)) (list (quote define) var2123 exp2124))))) (maybe-name-value!1399 (lambda (name2126 val2127) (if ((@ (language tree-il) lambda?) val2127) (let ((meta2128 ((@ (language tree-il) lambda-meta) val2127))) (if (not (assq (quote name) meta2128)) ((setter (@ (language tree-il) lambda-meta)) val2127 (acons (quote name) name2126 meta2128))))))) (build-global-assignment1398 (lambda (source2129 var2130 exp2131 mod2132) (analyze-variable1396 mod2132 var2130 (lambda (mod2133 var2134 public?2135) (let ((atom-key2136 (fluid-ref *mode*1382))) (if (memv atom-key2136 (quote (c))) ((@ (language tree-il) make-module-set) source2129 mod2133 var2134 public?2135 exp2131) (list (quote set!) (list (if public?2135 (quote @) (quote @@)) mod2133 var2134) exp2131)))) (lambda (var2137) (let ((atom-key2138 (fluid-ref *mode*1382))) (if (memv atom-key2138 (quote (c))) ((@ (language tree-il) make-toplevel-set) source2129 var2137 exp2131) (list (quote set!) var2137 exp2131))))))) (build-global-reference1397 (lambda (source2139 var2140 mod2141) (analyze-variable1396 mod2141 var2140 (lambda (mod2142 var2143 public?2144) (let ((atom-key2145 (fluid-ref *mode*1382))) (if (memv atom-key2145 (quote (c))) ((@ (language tree-il) make-module-ref) source2139 mod2142 var2143 public?2144) (list (if public?2144 (quote @) (quote @@)) mod2142 var2143)))) (lambda (var2146) (let ((atom-key2147 (fluid-ref *mode*1382))) (if (memv atom-key2147 (quote (c))) ((@ (language tree-il) make-toplevel-ref) source2139 var2146) var2146)))))) (analyze-variable1396 (lambda (mod2148 var2149 modref-cont2150 bare-cont2151) (if (not mod2148) (bare-cont2151 var2149) (let ((kind2152 (car mod2148)) (mod2153 (cdr mod2148))) (if (memv kind2152 (quote (public))) (modref-cont2150 mod2153 var2149 #t) (if (memv kind2152 (quote (private))) (if (not (equal? mod2153 (module-name (current-module)))) (modref-cont2150 mod2153 var2149 #f) (bare-cont2151 var2149)) (if (memv kind2152 (quote (bare))) (bare-cont2151 var2149) (if (memv kind2152 (quote (hygiene))) (if (if (not (equal? mod2153 (module-name (current-module)))) (module-variable (resolve-module mod2153) var2149) #f) (modref-cont2150 mod2153 var2149 #f) (bare-cont2151 var2149)) (syntax-violation #f "bad module kind" var2149 mod2153))))))))) (build-lexical-assignment1395 (lambda (source2154 name2155 var2156 exp2157) (let ((atom-key2158 (fluid-ref *mode*1382))) (if (memv atom-key2158 (quote (c))) ((@ (language tree-il) make-lexical-set) source2154 name2155 var2156 exp2157) (list (quote set!) var2156 exp2157))))) (build-lexical-reference1394 (lambda (type2159 source2160 name2161 var2162) (let ((atom-key2163 (fluid-ref *mode*1382))) (if (memv atom-key2163 (quote (c))) ((@ (language tree-il) make-lexical-ref) source2160 name2161 var2162) var2162)))) (build-conditional1393 (lambda (source2164 test-exp2165 then-exp2166 else-exp2167) (let ((atom-key2168 (fluid-ref *mode*1382))) (if (memv atom-key2168 (quote (c))) ((@ (language tree-il) make-conditional) source2164 test-exp2165 then-exp2166 else-exp2167) (if (equal? else-exp2167 (quote (if #f #f))) (list (quote if) test-exp2165 then-exp2166) (list (quote if) test-exp2165 then-exp2166 else-exp2167)))))) (build-application1392 (lambda (source2169 fun-exp2170 arg-exps2171) (let ((atom-key2172 (fluid-ref *mode*1382))) (if (memv atom-key2172 (quote (c))) ((@ (language tree-il) make-application) source2169 fun-exp2170 arg-exps2171) (cons fun-exp2170 arg-exps2171))))) (build-void1391 (lambda (source2173) (let ((atom-key2174 (fluid-ref *mode*1382))) (if (memv atom-key2174 (quote (c))) ((@ (language tree-il) make-void) source2173) (quote (if #f #f)))))) (get-global-definition-hook1390 (lambda (symbol2175 module2176) (begin (if (if (not module2176) (current-module) #f) (warn "module system is booted, we should have a module" symbol2175)) (let ((v2177 (module-variable (if module2176 (resolve-module (cdr module2176)) (current-module)) symbol2175))) (if v2177 (if (variable-bound? v2177) (let ((val2178 (variable-ref v2177))) (if (macro? val2178) (if (syncase-macro-type val2178) (cons (syncase-macro-type val2178) (syncase-macro-binding val2178)) #f) #f)) #f) #f))))) (put-global-definition-hook1389 (lambda (symbol2179 type2180 val2181) (let ((existing2182 (let ((v2183 (module-variable (current-module) symbol2179))) (if v2183 (if (variable-bound? v2183) (let ((val2184 (variable-ref v2183))) (if (macro? val2184) (if (not (syncase-macro-type val2184)) val2184 #f) #f)) #f) #f)))) (module-define! (current-module) symbol2179 (if existing2182 (make-extended-syncase-macro existing2182 type2180 val2181) (make-syncase-macro type2180 val2181)))))) (local-eval-hook1388 (lambda (x2185 mod2186) (primitive-eval (list noexpand1381 (let ((atom-key2187 (fluid-ref *mode*1382))) (if (memv atom-key2187 (quote (c))) ((@ (language tree-il) tree-il->scheme) x2185) x2185)))))) (top-level-eval-hook1387 (lambda (x2188 mod2189) (primitive-eval (list noexpand1381 (let ((atom-key2190 (fluid-ref *mode*1382))) (if (memv atom-key2190 (quote (c))) ((@ (language tree-il) tree-il->scheme) x2188) x2188)))))) (fx<1386 <) (fx=1385 =) (fx-1384 -) (fx+1383 +) (*mode*1382 (make-fluid)) (noexpand1381 "noexpand")) (begin (global-extend1423 (quote local-syntax) (quote letrec-syntax) #t) (global-extend1423 (quote local-syntax) (quote let-syntax) #f) (global-extend1423 (quote core) (quote fluid-let-syntax) (lambda (e2191 r2192 w2193 s2194 mod2195) ((lambda (tmp2196) ((lambda (tmp2197) (if (if tmp2197 (apply (lambda (_2198 var2199 val2200 e12201 e22202) (valid-bound-ids?1450 var2199)) tmp2197) #f) (apply (lambda (_2204 var2205 val2206 e12207 e22208) (let ((names2209 (map (lambda (x2210) (id-var-name1447 x2210 w2193)) var2205))) (begin (for-each (lambda (id2212 n2213) (let ((atom-key2214 (binding-type1417 (lookup1422 n2213 r2192 mod2195)))) (if (memv atom-key2214 (quote (displaced-lexical))) (syntax-violation (quote fluid-let-syntax) "identifier out of context" e2191 (source-wrap1454 id2212 w2193 s2194 mod2195))))) var2205 names2209) (chi-body1465 (cons e12207 e22208) (source-wrap1454 e2191 w2193 s2194 mod2195) (extend-env1419 names2209 (let ((trans-r2217 (macros-only-env1421 r2192))) (map (lambda (x2218) (cons (quote macro) (eval-local-transformer1468 (chi1461 x2218 trans-r2217 w2193 mod2195) mod2195))) val2206)) r2192) w2193 mod2195)))) tmp2197) ((lambda (_2220) (syntax-violation (quote fluid-let-syntax) "bad syntax" (source-wrap1454 e2191 w2193 s2194 mod2195))) tmp2196))) ($sc-dispatch tmp2196 (quote (any #(each (any any)) any . each-any))))) e2191))) (global-extend1423 (quote core) (quote quote) (lambda (e2221 r2222 w2223 s2224 mod2225) ((lambda (tmp2226) ((lambda (tmp2227) (if tmp2227 (apply (lambda (_2228 e2229) (build-data1403 s2224 (strip1471 e2229 w2223))) tmp2227) ((lambda (_2230) (syntax-violation (quote quote) "bad syntax" (source-wrap1454 e2221 w2223 s2224 mod2225))) tmp2226))) ($sc-dispatch tmp2226 (quote (any any))))) e2221))) (global-extend1423 (quote core) (quote syntax) (letrec ((regen2238 (lambda (x2239) (let ((atom-key2240 (car x2239))) (if (memv atom-key2240 (quote (ref))) (build-lexical-reference1394 (quote value) #f (cadr x2239) (cadr x2239)) (if (memv atom-key2240 (quote (primitive))) (build-primref1402 #f (cadr x2239)) (if (memv atom-key2240 (quote (quote))) (build-data1403 #f (cadr x2239)) (if (memv atom-key2240 (quote (lambda))) (build-lambda1401 #f (cadr x2239) (cadr x2239) #f (regen2238 (caddr x2239))) (build-application1392 #f (build-primref1402 #f (car x2239)) (map regen2238 (cdr x2239)))))))))) (gen-vector2237 (lambda (x2241) (if (eq? (car x2241) (quote list)) (cons (quote vector) (cdr x2241)) (if (eq? (car x2241) (quote quote)) (list (quote quote) (list->vector (cadr x2241))) (list (quote list->vector) x2241))))) (gen-append2236 (lambda (x2242 y2243) (if (equal? y2243 (quote (quote ()))) x2242 (list (quote append) x2242 y2243)))) (gen-cons2235 (lambda (x2244 y2245) (let ((atom-key2246 (car y2245))) (if (memv atom-key2246 (quote (quote))) (if (eq? (car x2244) (quote quote)) (list (quote quote) (cons (cadr x2244) (cadr y2245))) (if (eq? (cadr y2245) (quote ())) (list (quote list) x2244) (list (quote cons) x2244 y2245))) (if (memv atom-key2246 (quote (list))) (cons (quote list) (cons x2244 (cdr y2245))) (list (quote cons) x2244 y2245)))))) (gen-map2234 (lambda (e2247 map-env2248) (let ((formals2249 (map cdr map-env2248)) (actuals2250 (map (lambda (x2251) (list (quote ref) (car x2251))) map-env2248))) (if (eq? (car e2247) (quote ref)) (car actuals2250) (if (and-map (lambda (x2252) (if (eq? (car x2252) (quote ref)) (memq (cadr x2252) formals2249) #f)) (cdr e2247)) (cons (quote map) (cons (list (quote primitive) (car e2247)) (map (let ((r2253 (map cons formals2249 actuals2250))) (lambda (x2254) (cdr (assq (cadr x2254) r2253)))) (cdr e2247)))) (cons (quote map) (cons (list (quote lambda) formals2249 e2247) actuals2250))))))) (gen-mappend2233 (lambda (e2255 map-env2256) (list (quote apply) (quote (primitive append)) (gen-map2234 e2255 map-env2256)))) (gen-ref2232 (lambda (src2257 var2258 level2259 maps2260) (if (fx=1385 level2259 0) (values var2258 maps2260) (if (null? maps2260) (syntax-violation (quote syntax) "missing ellipsis" src2257) (call-with-values (lambda () (gen-ref2232 src2257 var2258 (fx-1384 level2259 1) (cdr maps2260))) (lambda (outer-var2261 outer-maps2262) (let ((b2263 (assq outer-var2261 (car maps2260)))) (if b2263 (values (cdr b2263) maps2260) (let ((inner-var2264 (gen-var1472 (quote tmp)))) (values inner-var2264 (cons (cons (cons outer-var2261 inner-var2264) (car maps2260)) outer-maps2262))))))))))) (gen-syntax2231 (lambda (src2265 e2266 r2267 maps2268 ellipsis?2269 mod2270) (if (id?1425 e2266) (let ((label2271 (id-var-name1447 e2266 (quote (()))))) (let ((b2272 (lookup1422 label2271 r2267 mod2270))) (if (eq? (binding-type1417 b2272) (quote syntax)) (call-with-values (lambda () (let ((var.lev2273 (binding-value1418 b2272))) (gen-ref2232 src2265 (car var.lev2273) (cdr var.lev2273) maps2268))) (lambda (var2274 maps2275) (values (list (quote ref) var2274) maps2275))) (if (ellipsis?2269 e2266) (syntax-violation (quote syntax) "misplaced ellipsis" src2265) (values (list (quote quote) e2266) maps2268))))) ((lambda (tmp2276) ((lambda (tmp2277) (if (if tmp2277 (apply (lambda (dots2278 e2279) (ellipsis?2269 dots2278)) tmp2277) #f) (apply (lambda (dots2280 e2281) (gen-syntax2231 src2265 e2281 r2267 maps2268 (lambda (x2282) #f) mod2270)) tmp2277) ((lambda (tmp2283) (if (if tmp2283 (apply (lambda (x2284 dots2285 y2286) (ellipsis?2269 dots2285)) tmp2283) #f) (apply (lambda (x2287 dots2288 y2289) (letrec ((f2290 (lambda (y2291 k2292) ((lambda (tmp2296) ((lambda (tmp2297) (if (if tmp2297 (apply (lambda (dots2298 y2299) (ellipsis?2269 dots2298)) tmp2297) #f) (apply (lambda (dots2300 y2301) (f2290 y2301 (lambda (maps2302) (call-with-values (lambda () (k2292 (cons (quote ()) maps2302))) (lambda (x2303 maps2304) (if (null? (car maps2304)) (syntax-violation (quote syntax) "extra ellipsis" src2265) (values (gen-mappend2233 x2303 (car maps2304)) (cdr maps2304)))))))) tmp2297) ((lambda (_2305) (call-with-values (lambda () (gen-syntax2231 src2265 y2291 r2267 maps2268 ellipsis?2269 mod2270)) (lambda (y2306 maps2307) (call-with-values (lambda () (k2292 maps2307)) (lambda (x2308 maps2309) (values (gen-append2236 x2308 y2306) maps2309)))))) tmp2296))) ($sc-dispatch tmp2296 (quote (any . any))))) y2291)))) (f2290 y2289 (lambda (maps2293) (call-with-values (lambda () (gen-syntax2231 src2265 x2287 r2267 (cons (quote ()) maps2293) ellipsis?2269 mod2270)) (lambda (x2294 maps2295) (if (null? (car maps2295)) (syntax-violation (quote syntax) "extra ellipsis" src2265) (values (gen-map2234 x2294 (car maps2295)) (cdr maps2295))))))))) tmp2283) ((lambda (tmp2310) (if tmp2310 (apply (lambda (x2311 y2312) (call-with-values (lambda () (gen-syntax2231 src2265 x2311 r2267 maps2268 ellipsis?2269 mod2270)) (lambda (x2313 maps2314) (call-with-values (lambda () (gen-syntax2231 src2265 y2312 r2267 maps2314 ellipsis?2269 mod2270)) (lambda (y2315 maps2316) (values (gen-cons2235 x2313 y2315) maps2316)))))) tmp2310) ((lambda (tmp2317) (if tmp2317 (apply (lambda (e12318 e22319) (call-with-values (lambda () (gen-syntax2231 src2265 (cons e12318 e22319) r2267 maps2268 ellipsis?2269 mod2270)) (lambda (e2321 maps2322) (values (gen-vector2237 e2321) maps2322)))) tmp2317) ((lambda (_2323) (values (list (quote quote) e2266) maps2268)) tmp2276))) ($sc-dispatch tmp2276 (quote #(vector (any . each-any))))))) ($sc-dispatch tmp2276 (quote (any . any)))))) ($sc-dispatch tmp2276 (quote (any any . any)))))) ($sc-dispatch tmp2276 (quote (any any))))) e2266))))) (lambda (e2324 r2325 w2326 s2327 mod2328) (let ((e2329 (source-wrap1454 e2324 w2326 s2327 mod2328))) ((lambda (tmp2330) ((lambda (tmp2331) (if tmp2331 (apply (lambda (_2332 x2333) (call-with-values (lambda () (gen-syntax2231 e2329 x2333 r2325 (quote ()) ellipsis?1470 mod2328)) (lambda (e2334 maps2335) (regen2238 e2334)))) tmp2331) ((lambda (_2336) (syntax-violation (quote syntax) "bad `syntax' form" e2329)) tmp2330))) ($sc-dispatch tmp2330 (quote (any any))))) e2329))))) (global-extend1423 (quote core) (quote lambda) (lambda (e2337 r2338 w2339 s2340 mod2341) ((lambda (tmp2342) ((lambda (tmp2343) (if tmp2343 (apply (lambda (_2344 c2345) (chi-lambda-clause1466 (source-wrap1454 e2337 w2339 s2340 mod2341) #f c2345 r2338 w2339 mod2341 (lambda (names2346 vars2347 docstring2348 body2349) (build-lambda1401 s2340 names2346 vars2347 docstring2348 body2349)))) tmp2343) (syntax-violation #f "source expression failed to match any pattern" tmp2342))) ($sc-dispatch tmp2342 (quote (any . any))))) e2337))) (global-extend1423 (quote core) (quote let) (letrec ((chi-let2350 (lambda (e2351 r2352 w2353 s2354 mod2355 constructor2356 ids2357 vals2358 exps2359) (if (not (valid-bound-ids?1450 ids2357)) (syntax-violation (quote let) "duplicate bound variable" e2351) (let ((labels2360 (gen-labels1431 ids2357)) (new-vars2361 (map gen-var1472 ids2357))) (let ((nw2362 (make-binding-wrap1442 ids2357 labels2360 w2353)) (nr2363 (extend-var-env1420 labels2360 new-vars2361 r2352))) (constructor2356 s2354 (map syntax->datum ids2357) new-vars2361 (map (lambda (x2364) (chi1461 x2364 r2352 w2353 mod2355)) vals2358) (chi-body1465 exps2359 (source-wrap1454 e2351 nw2362 s2354 mod2355) nr2363 nw2362 mod2355)))))))) (lambda (e2365 r2366 w2367 s2368 mod2369) ((lambda (tmp2370) ((lambda (tmp2371) (if (if tmp2371 (apply (lambda (_2372 id2373 val2374 e12375 e22376) (and-map id?1425 id2373)) tmp2371) #f) (apply (lambda (_2378 id2379 val2380 e12381 e22382) (chi-let2350 e2365 r2366 w2367 s2368 mod2369 build-let1405 id2379 val2380 (cons e12381 e22382))) tmp2371) ((lambda (tmp2386) (if (if tmp2386 (apply (lambda (_2387 f2388 id2389 val2390 e12391 e22392) (if (id?1425 f2388) (and-map id?1425 id2389) #f)) tmp2386) #f) (apply (lambda (_2394 f2395 id2396 val2397 e12398 e22399) (chi-let2350 e2365 r2366 w2367 s2368 mod2369 build-named-let1406 (cons f2395 id2396) val2397 (cons e12398 e22399))) tmp2386) ((lambda (_2403) (syntax-violation (quote let) "bad let" (source-wrap1454 e2365 w2367 s2368 mod2369))) tmp2370))) ($sc-dispatch tmp2370 (quote (any any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp2370 (quote (any #(each (any any)) any . each-any))))) e2365)))) (global-extend1423 (quote core) (quote letrec) (lambda (e2404 r2405 w2406 s2407 mod2408) ((lambda (tmp2409) ((lambda (tmp2410) (if (if tmp2410 (apply (lambda (_2411 id2412 val2413 e12414 e22415) (and-map id?1425 id2412)) tmp2410) #f) (apply (lambda (_2417 id2418 val2419 e12420 e22421) (let ((ids2422 id2418)) (if (not (valid-bound-ids?1450 ids2422)) (syntax-violation (quote letrec) "duplicate bound variable" e2404) (let ((labels2424 (gen-labels1431 ids2422)) (new-vars2425 (map gen-var1472 ids2422))) (let ((w2426 (make-binding-wrap1442 ids2422 labels2424 w2406)) (r2427 (extend-var-env1420 labels2424 new-vars2425 r2405))) (build-letrec1407 s2407 (map syntax->datum ids2422) new-vars2425 (map (lambda (x2428) (chi1461 x2428 r2427 w2426 mod2408)) val2419) (chi-body1465 (cons e12420 e22421) (source-wrap1454 e2404 w2426 s2407 mod2408) r2427 w2426 mod2408))))))) tmp2410) ((lambda (_2431) (syntax-violation (quote letrec) "bad letrec" (source-wrap1454 e2404 w2406 s2407 mod2408))) tmp2409))) ($sc-dispatch tmp2409 (quote (any #(each (any any)) any . each-any))))) e2404))) (global-extend1423 (quote core) (quote set!) (lambda (e2432 r2433 w2434 s2435 mod2436) ((lambda (tmp2437) ((lambda (tmp2438) (if (if tmp2438 (apply (lambda (_2439 id2440 val2441) (id?1425 id2440)) tmp2438) #f) (apply (lambda (_2442 id2443 val2444) (let ((val2445 (chi1461 val2444 r2433 w2434 mod2436)) (n2446 (id-var-name1447 id2443 w2434))) (let ((b2447 (lookup1422 n2446 r2433 mod2436))) (let ((atom-key2448 (binding-type1417 b2447))) (if (memv atom-key2448 (quote (lexical))) (build-lexical-assignment1395 s2435 (syntax->datum id2443) (binding-value1418 b2447) val2445) (if (memv atom-key2448 (quote (global))) (build-global-assignment1398 s2435 n2446 val2445 mod2436) (if (memv atom-key2448 (quote (displaced-lexical))) (syntax-violation (quote set!) "identifier out of context" (wrap1453 id2443 w2434 mod2436)) (syntax-violation (quote set!) "bad set!" (source-wrap1454 e2432 w2434 s2435 mod2436))))))))) tmp2438) ((lambda (tmp2449) (if tmp2449 (apply (lambda (_2450 head2451 tail2452 val2453) (call-with-values (lambda () (syntax-type1459 head2451 r2433 (quote (())) #f #f mod2436 #t)) (lambda (type2454 value2455 ee2456 ww2457 ss2458 modmod2459) (if (memv type2454 (quote (module-ref))) (let ((val2460 (chi1461 val2453 r2433 w2434 mod2436))) (call-with-values (lambda () (value2455 (cons head2451 tail2452))) (lambda (id2462 mod2463) (build-global-assignment1398 s2435 id2462 val2460 mod2463)))) (build-application1392 s2435 (chi1461 (list (quote #(syntax-object setter ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type value ee ww ss modmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage #(_ head tail val) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(e r w s mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) head2451) r2433 w2434 mod2436) (map (lambda (e2464) (chi1461 e2464 r2433 w2434 mod2436)) (append tail2452 (list val2453)))))))) tmp2449) ((lambda (_2466) (syntax-violation (quote set!) "bad set!" (source-wrap1454 e2432 w2434 s2435 mod2436))) tmp2437))) ($sc-dispatch tmp2437 (quote (any (any . each-any) any)))))) ($sc-dispatch tmp2437 (quote (any any any))))) e2432))) (global-extend1423 (quote module-ref) (quote @) (lambda (e2467) ((lambda (tmp2468) ((lambda (tmp2469) (if (if tmp2469 (apply (lambda (_2470 mod2471 id2472) (if (and-map id?1425 mod2471) (id?1425 id2472) #f)) tmp2469) #f) (apply (lambda (_2474 mod2475 id2476) (values (syntax->datum id2476) (syntax->datum (cons (quote #(syntax-object public ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod2475)))) tmp2469) (syntax-violation #f "source expression failed to match any pattern" tmp2468))) ($sc-dispatch tmp2468 (quote (any each-any any))))) e2467))) (global-extend1423 (quote module-ref) (quote @@) (lambda (e2478) ((lambda (tmp2479) ((lambda (tmp2480) (if (if tmp2480 (apply (lambda (_2481 mod2482 id2483) (if (and-map id?1425 mod2482) (id?1425 id2483) #f)) tmp2480) #f) (apply (lambda (_2485 mod2486 id2487) (values (syntax->datum id2487) (syntax->datum (cons (quote #(syntax-object private ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod2486)))) tmp2480) (syntax-violation #f "source expression failed to match any pattern" tmp2479))) ($sc-dispatch tmp2479 (quote (any each-any any))))) e2478))) (global-extend1423 (quote core) (quote if) (lambda (e2489 r2490 w2491 s2492 mod2493) ((lambda (tmp2494) ((lambda (tmp2495) (if tmp2495 (apply (lambda (_2496 test2497 then2498) (build-conditional1393 s2492 (chi1461 test2497 r2490 w2491 mod2493) (chi1461 then2498 r2490 w2491 mod2493) (build-void1391 #f))) tmp2495) ((lambda (tmp2499) (if tmp2499 (apply (lambda (_2500 test2501 then2502 else2503) (build-conditional1393 s2492 (chi1461 test2501 r2490 w2491 mod2493) (chi1461 then2502 r2490 w2491 mod2493) (chi1461 else2503 r2490 w2491 mod2493))) tmp2499) (syntax-violation #f "source expression failed to match any pattern" tmp2494))) ($sc-dispatch tmp2494 (quote (any any any any)))))) ($sc-dispatch tmp2494 (quote (any any any))))) e2489))) (global-extend1423 (quote begin) (quote begin) (quote ())) (global-extend1423 (quote define) (quote define) (quote ())) (global-extend1423 (quote define-syntax) (quote define-syntax) (quote ())) (global-extend1423 (quote eval-when) (quote eval-when) (quote ())) (global-extend1423 (quote core) (quote syntax-case) (letrec ((gen-syntax-case2507 (lambda (x2508 keys2509 clauses2510 r2511 mod2512) (if (null? clauses2510) (build-application1392 #f (build-primref1402 #f (quote syntax-violation)) (list (build-data1403 #f #f) (build-data1403 #f "source expression failed to match any pattern") x2508)) ((lambda (tmp2513) ((lambda (tmp2514) (if tmp2514 (apply (lambda (pat2515 exp2516) (if (if (id?1425 pat2515) (and-map (lambda (x2517) (not (free-id=?1448 pat2515 x2517))) (cons (quote #(syntax-object ... ((top) #(ribcage #(pat exp) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x keys clauses r mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (gen-syntax-case gen-clause build-dispatch-call convert-pattern) ((top) (top) (top) (top)) ("i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) keys2509)) #f) (let ((labels2518 (list (gen-label1430))) (var2519 (gen-var1472 pat2515))) (build-application1392 #f (build-lambda1401 #f (list (syntax->datum pat2515)) (list var2519) #f (chi1461 exp2516 (extend-env1419 labels2518 (list (cons (quote syntax) (cons var2519 0))) r2511) (make-binding-wrap1442 (list pat2515) labels2518 (quote (()))) mod2512)) (list x2508))) (gen-clause2506 x2508 keys2509 (cdr clauses2510) r2511 pat2515 #t exp2516 mod2512))) tmp2514) ((lambda (tmp2520) (if tmp2520 (apply (lambda (pat2521 fender2522 exp2523) (gen-clause2506 x2508 keys2509 (cdr clauses2510) r2511 pat2521 fender2522 exp2523 mod2512)) tmp2520) ((lambda (_2524) (syntax-violation (quote syntax-case) "invalid clause" (car clauses2510))) tmp2513))) ($sc-dispatch tmp2513 (quote (any any any)))))) ($sc-dispatch tmp2513 (quote (any any))))) (car clauses2510))))) (gen-clause2506 (lambda (x2525 keys2526 clauses2527 r2528 pat2529 fender2530 exp2531 mod2532) (call-with-values (lambda () (convert-pattern2504 pat2529 keys2526)) (lambda (p2533 pvars2534) (if (not (distinct-bound-ids?1451 (map car pvars2534))) (syntax-violation (quote syntax-case) "duplicate pattern variable" pat2529) (if (not (and-map (lambda (x2535) (not (ellipsis?1470 (car x2535)))) pvars2534)) (syntax-violation (quote syntax-case) "misplaced ellipsis" pat2529) (let ((y2536 (gen-var1472 (quote tmp)))) (build-application1392 #f (build-lambda1401 #f (list (quote tmp)) (list y2536) #f (let ((y2537 (build-lexical-reference1394 (quote value) #f (quote tmp) y2536))) (build-conditional1393 #f ((lambda (tmp2538) ((lambda (tmp2539) (if tmp2539 (apply (lambda () y2537) tmp2539) ((lambda (_2540) (build-conditional1393 #f y2537 (build-dispatch-call2505 pvars2534 fender2530 y2537 r2528 mod2532) (build-data1403 #f #f))) tmp2538))) ($sc-dispatch tmp2538 (quote #(atom #t))))) fender2530) (build-dispatch-call2505 pvars2534 exp2531 y2537 r2528 mod2532) (gen-syntax-case2507 x2525 keys2526 clauses2527 r2528 mod2532)))) (list (if (eq? p2533 (quote any)) (build-application1392 #f (build-primref1402 #f (quote list)) (list x2525)) (build-application1392 #f (build-primref1402 #f (quote $sc-dispatch)) (list x2525 (build-data1403 #f p2533))))))))))))) (build-dispatch-call2505 (lambda (pvars2541 exp2542 y2543 r2544 mod2545) (let ((ids2546 (map car pvars2541)) (levels2547 (map cdr pvars2541))) (let ((labels2548 (gen-labels1431 ids2546)) (new-vars2549 (map gen-var1472 ids2546))) (build-application1392 #f (build-primref1402 #f (quote apply)) (list (build-lambda1401 #f (map syntax->datum ids2546) new-vars2549 #f (chi1461 exp2542 (extend-env1419 labels2548 (map (lambda (var2550 level2551) (cons (quote syntax) (cons var2550 level2551))) new-vars2549 (map cdr pvars2541)) r2544) (make-binding-wrap1442 ids2546 labels2548 (quote (()))) mod2545)) y2543)))))) (convert-pattern2504 (lambda (pattern2552 keys2553) (letrec ((cvt2554 (lambda (p2555 n2556 ids2557) (if (id?1425 p2555) (if (bound-id-member?1452 p2555 keys2553) (values (vector (quote free-id) p2555) ids2557) (values (quote any) (cons (cons p2555 n2556) ids2557))) ((lambda (tmp2558) ((lambda (tmp2559) (if (if tmp2559 (apply (lambda (x2560 dots2561) (ellipsis?1470 dots2561)) tmp2559) #f) (apply (lambda (x2562 dots2563) (call-with-values (lambda () (cvt2554 x2562 (fx+1383 n2556 1) ids2557)) (lambda (p2564 ids2565) (values (if (eq? p2564 (quote any)) (quote each-any) (vector (quote each) p2564)) ids2565)))) tmp2559) ((lambda (tmp2566) (if tmp2566 (apply (lambda (x2567 y2568) (call-with-values (lambda () (cvt2554 y2568 n2556 ids2557)) (lambda (y2569 ids2570) (call-with-values (lambda () (cvt2554 x2567 n2556 ids2570)) (lambda (x2571 ids2572) (values (cons x2571 y2569) ids2572)))))) tmp2566) ((lambda (tmp2573) (if tmp2573 (apply (lambda () (values (quote ()) ids2557)) tmp2573) ((lambda (tmp2574) (if tmp2574 (apply (lambda (x2575) (call-with-values (lambda () (cvt2554 x2575 n2556 ids2557)) (lambda (p2577 ids2578) (values (vector (quote vector) p2577) ids2578)))) tmp2574) ((lambda (x2579) (values (vector (quote atom) (strip1471 p2555 (quote (())))) ids2557)) tmp2558))) ($sc-dispatch tmp2558 (quote #(vector each-any)))))) ($sc-dispatch tmp2558 (quote ()))))) ($sc-dispatch tmp2558 (quote (any . any)))))) ($sc-dispatch tmp2558 (quote (any any))))) p2555))))) (cvt2554 pattern2552 0 (quote ())))))) (lambda (e2580 r2581 w2582 s2583 mod2584) (let ((e2585 (source-wrap1454 e2580 w2582 s2583 mod2584))) ((lambda (tmp2586) ((lambda (tmp2587) (if tmp2587 (apply (lambda (_2588 val2589 key2590 m2591) (if (and-map (lambda (x2592) (if (id?1425 x2592) (not (ellipsis?1470 x2592)) #f)) key2590) (let ((x2594 (gen-var1472 (quote tmp)))) (build-application1392 s2583 (build-lambda1401 #f (list (quote tmp)) (list x2594) #f (gen-syntax-case2507 (build-lexical-reference1394 (quote value) #f (quote tmp) x2594) key2590 m2591 r2581 mod2584)) (list (chi1461 val2589 r2581 (quote (())) mod2584)))) (syntax-violation (quote syntax-case) "invalid literals list" e2585))) tmp2587) (syntax-violation #f "source expression failed to match any pattern" tmp2586))) ($sc-dispatch tmp2586 (quote (any any each-any . each-any))))) e2585))))) (set! sc-expand (lambda (x2598 . rest2597) (if (if (pair? x2598) (equal? (car x2598) noexpand1381) #f) (cadr x2598) (let ((m2599 (if (null? rest2597) (quote e) (car rest2597))) (esew2600 (if (let ((t2601 (null? rest2597))) (if t2601 t2601 (null? (cdr rest2597)))) (quote (eval)) (cadr rest2597)))) (with-fluid* *mode*1382 m2599 (lambda () (chi-top1460 x2598 (quote ()) (quote ((top))) m2599 esew2600 (cons (quote hygiene) (module-name (current-module)))))))))) (set! identifier? (lambda (x2602) (nonsymbol-id?1424 x2602))) (set! datum->syntax (lambda (id2603 datum2604) (make-syntax-object1408 datum2604 (syntax-object-wrap1411 id2603) #f))) (set! syntax->datum (lambda (x2605) (strip1471 x2605 (quote (()))))) (set! generate-temporaries (lambda (ls2606) (begin (let ((x2607 ls2606)) (if (not (list? x2607)) (syntax-violation (quote generate-temporaries) "invalid argument" x2607))) (map (lambda (x2608) (wrap1453 (gensym) (quote ((top))) #f)) ls2606)))) (set! free-identifier=? (lambda (x2609 y2610) (begin (let ((x2611 x2609)) (if (not (nonsymbol-id?1424 x2611)) (syntax-violation (quote free-identifier=?) "invalid argument" x2611))) (let ((x2612 y2610)) (if (not (nonsymbol-id?1424 x2612)) (syntax-violation (quote free-identifier=?) "invalid argument" x2612))) (free-id=?1448 x2609 y2610)))) (set! bound-identifier=? (lambda (x2613 y2614) (begin (let ((x2615 x2613)) (if (not (nonsymbol-id?1424 x2615)) (syntax-violation (quote bound-identifier=?) "invalid argument" x2615))) (let ((x2616 y2614)) (if (not (nonsymbol-id?1424 x2616)) (syntax-violation (quote bound-identifier=?) "invalid argument" x2616))) (bound-id=?1449 x2613 y2614)))) (set! syntax-violation (lambda (who2620 message2619 form2618 . subform2617) (begin (let ((x2621 who2620)) (if (not ((lambda (x2622) (let ((t2623 (not x2622))) (if t2623 t2623 (let ((t2624 (string? x2622))) (if t2624 t2624 (symbol? x2622)))))) x2621)) (syntax-violation (quote syntax-violation) "invalid argument" x2621))) (let ((x2625 message2619)) (if (not (string? x2625)) (syntax-violation (quote syntax-violation) "invalid argument" x2625))) (scm-error (quote syntax-error) (quote sc-expand) (string-append (if who2620 "~a: " "") "~a " (if (null? subform2617) "in ~a" "in subform `~s' of `~s'")) (let ((tail2626 (cons message2619 (map (lambda (x2627) (strip1471 x2627 (quote (())))) (append subform2617 (list form2618)))))) (if who2620 (cons who2620 tail2626) tail2626)) #f)))) (letrec ((match2632 (lambda (e2633 p2634 w2635 r2636 mod2637) (if (not r2636) #f (if (eq? p2634 (quote any)) (cons (wrap1453 e2633 w2635 mod2637) r2636) (if (syntax-object?1409 e2633) (match*2631 (syntax-object-expression1410 e2633) p2634 (join-wraps1444 w2635 (syntax-object-wrap1411 e2633)) r2636 (syntax-object-module1412 e2633)) (match*2631 e2633 p2634 w2635 r2636 mod2637)))))) (match*2631 (lambda (e2638 p2639 w2640 r2641 mod2642) (if (null? p2639) (if (null? e2638) r2641 #f) (if (pair? p2639) (if (pair? e2638) (match2632 (car e2638) (car p2639) w2640 (match2632 (cdr e2638) (cdr p2639) w2640 r2641 mod2642) mod2642) #f) (if (eq? p2639 (quote each-any)) (let ((l2643 (match-each-any2629 e2638 w2640 mod2642))) (if l2643 (cons l2643 r2641) #f)) (let ((atom-key2644 (vector-ref p2639 0))) (if (memv atom-key2644 (quote (each))) (if (null? e2638) (match-empty2630 (vector-ref p2639 1) r2641) (let ((l2645 (match-each2628 e2638 (vector-ref p2639 1) w2640 mod2642))) (if l2645 (letrec ((collect2646 (lambda (l2647) (if (null? (car l2647)) r2641 (cons (map car l2647) (collect2646 (map cdr l2647))))))) (collect2646 l2645)) #f))) (if (memv atom-key2644 (quote (free-id))) (if (id?1425 e2638) (if (free-id=?1448 (wrap1453 e2638 w2640 mod2642) (vector-ref p2639 1)) r2641 #f) #f) (if (memv atom-key2644 (quote (atom))) (if (equal? (vector-ref p2639 1) (strip1471 e2638 w2640)) r2641 #f) (if (memv atom-key2644 (quote (vector))) (if (vector? e2638) (match2632 (vector->list e2638) (vector-ref p2639 1) w2640 r2641 mod2642) #f))))))))))) (match-empty2630 (lambda (p2648 r2649) (if (null? p2648) r2649 (if (eq? p2648 (quote any)) (cons (quote ()) r2649) (if (pair? p2648) (match-empty2630 (car p2648) (match-empty2630 (cdr p2648) r2649)) (if (eq? p2648 (quote each-any)) (cons (quote ()) r2649) (let ((atom-key2650 (vector-ref p2648 0))) (if (memv atom-key2650 (quote (each))) (match-empty2630 (vector-ref p2648 1) r2649) (if (memv atom-key2650 (quote (free-id atom))) r2649 (if (memv atom-key2650 (quote (vector))) (match-empty2630 (vector-ref p2648 1) r2649))))))))))) (match-each-any2629 (lambda (e2651 w2652 mod2653) (if (pair? e2651) (let ((l2654 (match-each-any2629 (cdr e2651) w2652 mod2653))) (if l2654 (cons (wrap1453 (car e2651) w2652 mod2653) l2654) #f)) (if (null? e2651) (quote ()) (if (syntax-object?1409 e2651) (match-each-any2629 (syntax-object-expression1410 e2651) (join-wraps1444 w2652 (syntax-object-wrap1411 e2651)) mod2653) #f))))) (match-each2628 (lambda (e2655 p2656 w2657 mod2658) (if (pair? e2655) (let ((first2659 (match2632 (car e2655) p2656 w2657 (quote ()) mod2658))) (if first2659 (let ((rest2660 (match-each2628 (cdr e2655) p2656 w2657 mod2658))) (if rest2660 (cons first2659 rest2660) #f)) #f)) (if (null? e2655) (quote ()) (if (syntax-object?1409 e2655) (match-each2628 (syntax-object-expression1410 e2655) p2656 (join-wraps1444 w2657 (syntax-object-wrap1411 e2655)) (syntax-object-module1412 e2655)) #f)))))) (set! $sc-dispatch (lambda (e2661 p2662) (if (eq? p2662 (quote any)) (list e2661) (if (syntax-object?1409 e2661) (match*2631 (syntax-object-expression1410 e2661) p2662 (syntax-object-wrap1411 e2661) (quote ()) (syntax-object-module1412 e2661)) (match*2631 e2661 p2662 (quote (())) (quote ()) #f)))))))))
(define with-syntax (make-syncase-macro (quote macro) (lambda (x2663) ((lambda (tmp2664) ((lambda (tmp2665) (if tmp2665 (apply (lambda (_2666 e12667 e22668) (cons (quote #(syntax-object begin ((top) #(ribcage #(_ e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12667 e22668))) tmp2665) ((lambda (tmp2670) (if tmp2670 (apply (lambda (_2671 out2672 in2673 e12674 e22675) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in2673 (quote ()) (list out2672 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12674 e22675))))) tmp2670) ((lambda (tmp2677) (if tmp2677 (apply (lambda (_2678 out2679 in2680 e12681 e22682) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object list ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in2680) (quote ()) (list out2679 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12681 e22682))))) tmp2677) (syntax-violation #f "source expression failed to match any pattern" tmp2664))) ($sc-dispatch tmp2664 (quote (any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp2664 (quote (any ((any any)) any . each-any)))))) ($sc-dispatch tmp2664 (quote (any () any . each-any))))) x2663))))
(define syntax-rules (make-syncase-macro (quote macro) (lambda (x2686) ((lambda (tmp2687) ((lambda (tmp2688) (if tmp2688 (apply (lambda (_2689 k2690 keyword2691 pattern2692 template2693) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (cons (quote #(syntax-object syntax-case ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons k2690 (map (lambda (tmp2696 tmp2695) (list (cons (quote #(syntax-object dummy ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp2695) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp2696))) template2693 pattern2692)))))) tmp2688) (syntax-violation #f "source expression failed to match any pattern" tmp2687))) ($sc-dispatch tmp2687 (quote (any each-any . #(each ((any . any) any))))))) x2686))))
(define let* (make-extended-syncase-macro (module-ref (current-module) (quote let*)) (quote macro) (lambda (x2697) ((lambda (tmp2698) ((lambda (tmp2699) (if (if tmp2699 (apply (lambda (let*2700 x2701 v2702 e12703 e22704) (and-map identifier? x2701)) tmp2699) #f) (apply (lambda (let*2706 x2707 v2708 e12709 e22710) (letrec ((f2711 (lambda (bindings2712) (if (null? bindings2712) (cons (quote #(syntax-object let ((top) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote ()) (cons e12709 e22710))) ((lambda (tmp2716) ((lambda (tmp2717) (if tmp2717 (apply (lambda (body2718 binding2719) (list (quote #(syntax-object let ((top) #(ribcage #(body binding) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list binding2719) body2718)) tmp2717) (syntax-violation #f "source expression failed to match any pattern" tmp2716))) ($sc-dispatch tmp2716 (quote (any any))))) (list (f2711 (cdr bindings2712)) (car bindings2712))))))) (f2711 (map list x2707 v2708)))) tmp2699) (syntax-violation #f "source expression failed to match any pattern" tmp2698))) ($sc-dispatch tmp2698 (quote (any #(each (any any)) any . each-any))))) x2697))))
(define do (make-extended-syncase-macro (module-ref (current-module) (quote do)) (quote macro) (lambda (orig-x2720) ((lambda (tmp2721) ((lambda (tmp2722) (if tmp2722 (apply (lambda (_2723 var2724 init2725 step2726 e02727 e12728 c2729) ((lambda (tmp2730) ((lambda (tmp2731) (if tmp2731 (apply (lambda (step2732) ((lambda (tmp2733) ((lambda (tmp2734) (if tmp2734 (apply (lambda () (list (quote #(syntax-object let ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var2724 init2725) (list (quote #(syntax-object if ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object not ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e02727) (cons (quote #(syntax-object begin ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c2729 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step2732))))))) tmp2734) ((lambda (tmp2739) (if tmp2739 (apply (lambda (e12740 e22741) (list (quote #(syntax-object let ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var2724 init2725) (list (quote #(syntax-object if ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e02727 (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (cons e12740 e22741)) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c2729 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step2732))))))) tmp2739) (syntax-violation #f "source expression failed to match any pattern" tmp2733))) ($sc-dispatch tmp2733 (quote (any . each-any)))))) ($sc-dispatch tmp2733 (quote ())))) e12728)) tmp2731) (syntax-violation #f "source expression failed to match any pattern" tmp2730))) ($sc-dispatch tmp2730 (quote each-any)))) (map (lambda (v2748 s2749) ((lambda (tmp2750) ((lambda (tmp2751) (if tmp2751 (apply (lambda () v2748) tmp2751) ((lambda (tmp2752) (if tmp2752 (apply (lambda (e2753) e2753) tmp2752) ((lambda (_2754) (syntax-violation (quote do) "bad step expression" orig-x2720 s2749)) tmp2750))) ($sc-dispatch tmp2750 (quote (any)))))) ($sc-dispatch tmp2750 (quote ())))) s2749)) var2724 step2726))) tmp2722) (syntax-violation #f "source expression failed to match any pattern" tmp2721))) ($sc-dispatch tmp2721 (quote (any #(each (any any . any)) (any . each-any) . each-any))))) orig-x2720))))
(define quasiquote (make-extended-syncase-macro (module-ref (current-module) (quote quasiquote)) (quote macro) (letrec ((quasicons2757 (lambda (x2761 y2762) ((lambda (tmp2763) ((lambda (tmp2764) (if tmp2764 (apply (lambda (x2765 y2766) ((lambda (tmp2767) ((lambda (tmp2768) (if tmp2768 (apply (lambda (dy2769) ((lambda (tmp2770) ((lambda (tmp2771) (if tmp2771 (apply (lambda (dx2772) (list (quote #(syntax-object quote ((top) #(ribcage #(dx) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons dx2772 dy2769))) tmp2771) ((lambda (_2773) (if (null? dy2769) (list (quote #(syntax-object list ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x2765) (list (quote #(syntax-object cons ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x2765 y2766))) tmp2770))) ($sc-dispatch tmp2770 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) x2765)) tmp2768) ((lambda (tmp2774) (if tmp2774 (apply (lambda (stuff2775) (cons (quote #(syntax-object list ((top) #(ribcage #(stuff) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons x2765 stuff2775))) tmp2774) ((lambda (else2776) (list (quote #(syntax-object cons ((top) #(ribcage #(else) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x2765 y2766)) tmp2767))) ($sc-dispatch tmp2767 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . any)))))) ($sc-dispatch tmp2767 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) y2766)) tmp2764) (syntax-violation #f "source expression failed to match any pattern" tmp2763))) ($sc-dispatch tmp2763 (quote (any any))))) (list x2761 y2762)))) (quasiappend2758 (lambda (x2777 y2778) ((lambda (tmp2779) ((lambda (tmp2780) (if tmp2780 (apply (lambda (x2781 y2782) ((lambda (tmp2783) ((lambda (tmp2784) (if tmp2784 (apply (lambda () x2781) tmp2784) ((lambda (_2785) (list (quote #(syntax-object append ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x2781 y2782)) tmp2783))) ($sc-dispatch tmp2783 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) ()))))) y2782)) tmp2780) (syntax-violation #f "source expression failed to match any pattern" tmp2779))) ($sc-dispatch tmp2779 (quote (any any))))) (list x2777 y2778)))) (quasivector2759 (lambda (x2786) ((lambda (tmp2787) ((lambda (x2788) ((lambda (tmp2789) ((lambda (tmp2790) (if tmp2790 (apply (lambda (x2791) (list (quote #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (list->vector x2791))) tmp2790) ((lambda (tmp2793) (if tmp2793 (apply (lambda (x2794) (cons (quote #(syntax-object vector ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x2794)) tmp2793) ((lambda (_2796) (list (quote #(syntax-object list->vector ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x2788)) tmp2789))) ($sc-dispatch tmp2789 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . each-any)))))) ($sc-dispatch tmp2789 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) each-any))))) x2788)) tmp2787)) x2786))) (quasi2760 (lambda (p2797 lev2798) ((lambda (tmp2799) ((lambda (tmp2800) (if tmp2800 (apply (lambda (p2801) (if (= lev2798 0) p2801 (quasicons2757 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi2760 (list p2801) (- lev2798 1))))) tmp2800) ((lambda (tmp2802) (if (if tmp2802 (apply (lambda (args2803) (= lev2798 0)) tmp2802) #f) (apply (lambda (args2804) (syntax-violation (quote unquote) "unquote takes exactly one argument" p2797 (cons (quote #(syntax-object unquote ((top) #(ribcage #(args) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) args2804))) tmp2802) ((lambda (tmp2805) (if tmp2805 (apply (lambda (p2806 q2807) (if (= lev2798 0) (quasiappend2758 p2806 (quasi2760 q2807 lev2798)) (quasicons2757 (quasicons2757 (quote (#(syntax-object quote ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote-splicing ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi2760 (list p2806) (- lev2798 1))) (quasi2760 q2807 lev2798)))) tmp2805) ((lambda (tmp2808) (if (if tmp2808 (apply (lambda (args2809 q2810) (= lev2798 0)) tmp2808) #f) (apply (lambda (args2811 q2812) (syntax-violation (quote unquote-splicing) "unquote-splicing takes exactly one argument" p2797 (cons (quote #(syntax-object unquote-splicing ((top) #(ribcage #(args q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) args2811))) tmp2808) ((lambda (tmp2813) (if tmp2813 (apply (lambda (p2814) (quasicons2757 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object quasiquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi2760 (list p2814) (+ lev2798 1)))) tmp2813) ((lambda (tmp2815) (if tmp2815 (apply (lambda (p2816 q2817) (quasicons2757 (quasi2760 p2816 lev2798) (quasi2760 q2817 lev2798))) tmp2815) ((lambda (tmp2818) (if tmp2818 (apply (lambda (x2819) (quasivector2759 (quasi2760 x2819 lev2798))) tmp2818) ((lambda (p2821) (list (quote #(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) p2821)) tmp2799))) ($sc-dispatch tmp2799 (quote #(vector each-any)))))) ($sc-dispatch tmp2799 (quote (any . any)))))) ($sc-dispatch tmp2799 (quote (#(free-id #(syntax-object quasiquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any)))))) ($sc-dispatch tmp2799 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . any) . any)))))) ($sc-dispatch tmp2799 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any) . any)))))) ($sc-dispatch tmp2799 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . any)))))) ($sc-dispatch tmp2799 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) p2797)))) (lambda (x2822) ((lambda (tmp2823) ((lambda (tmp2824) (if tmp2824 (apply (lambda (_2825 e2826) (quasi2760 e2826 0)) tmp2824) (syntax-violation #f "source expression failed to match any pattern" tmp2823))) ($sc-dispatch tmp2823 (quote (any any))))) x2822)))))
(define include (make-syncase-macro (quote macro) (lambda (x2827) (letrec ((read-file2828 (lambda (fn2829 k2830) (let ((p2831 (open-input-file fn2829))) (letrec ((f2832 (lambda (x2833) (if (eof-object? x2833) (begin (close-input-port p2831) (quote ())) (cons (datum->syntax k2830 x2833) (f2832 (read p2831))))))) (f2832 (read p2831))))))) ((lambda (tmp2834) ((lambda (tmp2835) (if tmp2835 (apply (lambda (k2836 filename2837) (let ((fn2838 (syntax->datum filename2837))) ((lambda (tmp2839) ((lambda (tmp2840) (if tmp2840 (apply (lambda (exp2841) (cons (quote #(syntax-object begin ((top) #(ribcage #(exp) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(fn) #((top)) #("i")) #(ribcage #(k filename) #((top) (top)) #("i" "i")) #(ribcage (read-file) ((top)) ("i")) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) exp2841)) tmp2840) (syntax-violation #f "source expression failed to match any pattern" tmp2839))) ($sc-dispatch tmp2839 (quote each-any)))) (read-file2828 fn2838 k2836)))) tmp2835) (syntax-violation #f "source expression failed to match any pattern" tmp2834))) ($sc-dispatch tmp2834 (quote (any any))))) x2827)))))
(define unquote (make-syncase-macro (quote macro) (lambda (x2843) ((lambda (tmp2844) ((lambda (tmp2845) (if tmp2845 (apply (lambda (_2846 e2847) (syntax-violation (quote unquote) "expression not valid outside of quasiquote" x2843)) tmp2845) (syntax-violation #f "source expression failed to match any pattern" tmp2844))) ($sc-dispatch tmp2844 (quote (any any))))) x2843))))
(define unquote-splicing (make-syncase-macro (quote macro) (lambda (x2848) ((lambda (tmp2849) ((lambda (tmp2850) (if tmp2850 (apply (lambda (_2851 e2852) (syntax-violation (quote unquote-splicing) "expression not valid outside of quasiquote" x2848)) tmp2850) (syntax-violation #f "source expression failed to match any pattern" tmp2849))) ($sc-dispatch tmp2849 (quote (any any))))) x2848))))
(define case (make-extended-syncase-macro (module-ref (current-module) (quote case)) (quote macro) (lambda (x2853) ((lambda (tmp2854) ((lambda (tmp2855) (if tmp2855 (apply (lambda (_2856 e2857 m12858 m22859) ((lambda (tmp2860) ((lambda (body2861) (list (quote #(syntax-object let ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (list (quote #(syntax-object t ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e2857)) body2861)) tmp2860)) (letrec ((f2862 (lambda (clause2863 clauses2864) (if (null? clauses2864) ((lambda (tmp2866) ((lambda (tmp2867) (if tmp2867 (apply (lambda (e12868 e22869) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12868 e22869))) tmp2867) ((lambda (tmp2871) (if tmp2871 (apply (lambda (k2872 e12873 e22874) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k2872)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12873 e22874)))) tmp2871) ((lambda (_2877) (syntax-violation (quote case) "bad clause" x2853 clause2863)) tmp2866))) ($sc-dispatch tmp2866 (quote (each-any any . each-any)))))) ($sc-dispatch tmp2866 (quote (#(free-id #(syntax-object else ((top) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) any . each-any))))) clause2863) ((lambda (tmp2878) ((lambda (rest2879) ((lambda (tmp2880) ((lambda (tmp2881) (if tmp2881 (apply (lambda (k2882 e12883 e22884) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k2882)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12883 e22884)) rest2879)) tmp2881) ((lambda (_2887) (syntax-violation (quote case) "bad clause" x2853 clause2863)) tmp2880))) ($sc-dispatch tmp2880 (quote (each-any any . each-any))))) clause2863)) tmp2878)) (f2862 (car clauses2864) (cdr clauses2864))))))) (f2862 m12858 m22859)))) tmp2855) (syntax-violation #f "source expression failed to match any pattern" tmp2854))) ($sc-dispatch tmp2854 (quote (any any any . each-any))))) x2853))))
(define identifier-syntax (make-syncase-macro (quote macro) (lambda (x2888) ((lambda (tmp2889) ((lambda (tmp2890) (if tmp2890 (apply (lambda (_2891 e2892) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote ()) (list (quote #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object identifier? ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) (#(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e2892)) (list (cons _2891 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e2892 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))))))))) tmp2890) (syntax-violation #f "source expression failed to match any pattern" tmp2889))) ($sc-dispatch tmp2889 (quote (any any))))) x2888))))
