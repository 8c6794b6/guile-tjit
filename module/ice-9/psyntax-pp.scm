(eval-when (compile) (set-current-module (resolve-module (quote (guile)))))
(if #f #f)
(letrec ((and-map*17 (lambda (f57 first56 . rest55) (let ((t58 (null? first56))) (if t58 t58 (if (null? rest55) (letrec ((andmap59 (lambda (first60) (let ((x61 (car first60)) (first62 (cdr first60))) (if (null? first62) (f57 x61) (if (f57 x61) (andmap59 first62) #f)))))) (andmap59 first56)) (letrec ((andmap63 (lambda (first64 rest65) (let ((x66 (car first64)) (xr67 (map car rest65)) (first68 (cdr first64)) (rest69 (map cdr rest65))) (if (null? first68) (apply f57 (cons x66 xr67)) (if (apply f57 (cons x66 xr67)) (andmap63 first68 rest69) #f)))))) (andmap63 first56 rest55)))))))) (letrec ((lambda-var-list163 (lambda (vars292) (letrec ((lvl293 (lambda (vars294 ls295 w296) (if (pair? vars294) (lvl293 (cdr vars294) (cons (wrap142 (car vars294) w296 #f) ls295) w296) (if (id?114 vars294) (cons (wrap142 vars294 w296 #f) ls295) (if (null? vars294) ls295 (if (syntax-object?98 vars294) (lvl293 (syntax-object-expression99 vars294) ls295 (join-wraps133 w296 (syntax-object-wrap100 vars294))) (if (annotation? vars294) (lvl293 (annotation-expression vars294) ls295 w296) (cons vars294 ls295))))))))) (lvl293 vars292 (quote ()) (quote (())))))) (gen-var162 (lambda (id297) (let ((id298 (if (syntax-object?98 id297) (syntax-object-expression99 id297) id297))) (if (annotation? id298) (gensym (symbol->string (annotation-expression id298))) (gensym (symbol->string id298)))))) (strip161 (lambda (x299 w300) (if (memq (quote top) (wrap-marks117 w300)) (if (let ((t301 (annotation? x299))) (if t301 t301 (if (pair? x299) (annotation? (car x299)) #f))) (strip-annotation160 x299 #f) x299) (letrec ((f302 (lambda (x303) (if (syntax-object?98 x303) (strip161 (syntax-object-expression99 x303) (syntax-object-wrap100 x303)) (if (pair? x303) (let ((a304 (f302 (car x303))) (d305 (f302 (cdr x303)))) (if (if (eq? a304 (car x303)) (eq? d305 (cdr x303)) #f) x303 (cons a304 d305))) (if (vector? x303) (let ((old306 (vector->list x303))) (let ((new307 (map f302 old306))) (if (and-map*17 eq? old306 new307) x303 (list->vector new307)))) x303)))))) (f302 x299))))) (strip-annotation160 (lambda (x308 parent309) (if (pair? x308) (let ((new310 (cons #f #f))) (begin (if parent309 (set-annotation-stripped! parent309 new310)) (set-car! new310 (strip-annotation160 (car x308) #f)) (set-cdr! new310 (strip-annotation160 (cdr x308) #f)) new310)) (if (annotation? x308) (let ((t311 (annotation-stripped x308))) (if t311 t311 (strip-annotation160 (annotation-expression x308) x308))) (if (vector? x308) (let ((new312 (make-vector (vector-length x308)))) (begin (if parent309 (set-annotation-stripped! parent309 new312)) (letrec ((loop313 (lambda (i314) (unless (fx<75 i314 0) (vector-set! new312 i314 (strip-annotation160 (vector-ref x308 i314) #f)) (loop313 (fx-73 i314 1)))))) (loop313 (- (vector-length x308) 1))) new312)) x308))))) (ellipsis?159 (lambda (x315) (if (nonsymbol-id?113 x315) (free-id=?137 x315 (quote #(syntax-object ... ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) #f))) (chi-void158 (lambda () (build-void80 #f))) (eval-local-transformer157 (lambda (expanded316 mod317) (let ((p318 (local-eval-hook77 expanded316 mod317))) (if (procedure? p318) p318 (syntax-violation #f "nonprocedure transformer" p318))))) (chi-local-syntax156 (lambda (rec?319 e320 r321 w322 s323 mod324 k325) ((lambda (tmp326) ((lambda (tmp327) (if tmp327 (apply (lambda (_328 id329 val330 e1331 e2332) (let ((ids333 id329)) (if (not (valid-bound-ids?139 ids333)) (syntax-violation #f "duplicate bound keyword" e320) (let ((labels335 (gen-labels120 ids333))) (let ((new-w336 (make-binding-wrap131 ids333 labels335 w322))) (k325 (cons e1331 e2332) (extend-env108 labels335 (let ((w338 (if rec?319 new-w336 w322)) (trans-r339 (macros-only-env110 r321))) (map (lambda (x340) (cons (quote macro) (eval-local-transformer157 (chi150 x340 trans-r339 w338 mod324) mod324))) val330)) r321) new-w336 s323 mod324)))))) tmp327) ((lambda (_342) (syntax-violation #f "bad local syntax definition" (source-wrap143 e320 w322 s323 mod324))) tmp326))) ($sc-dispatch tmp326 (quote (any #(each (any any)) any . each-any))))) e320))) (chi-lambda-clause155 (lambda (e343 docstring344 c345 r346 w347 mod348 k349) ((lambda (tmp350) ((lambda (tmp351) (if (if tmp351 (apply (lambda (args352 doc353 e1354 e2355) (if (string? (syntax->datum doc353)) (not docstring344) #f)) tmp351) #f) (apply (lambda (args356 doc357 e1358 e2359) (chi-lambda-clause155 e343 doc357 (cons args356 (cons e1358 e2359)) r346 w347 mod348 k349)) tmp351) ((lambda (tmp361) (if tmp361 (apply (lambda (id362 e1363 e2364) (let ((ids365 id362)) (if (not (valid-bound-ids?139 ids365)) (syntax-violation (quote lambda) "invalid parameter list" e343) (let ((labels367 (gen-labels120 ids365)) (new-vars368 (map gen-var162 ids365))) (k349 (map syntax->datum ids365) new-vars368 (if docstring344 (syntax->datum docstring344) #f) (chi-body154 (cons e1363 e2364) e343 (extend-var-env109 labels367 new-vars368 r346) (make-binding-wrap131 ids365 labels367 w347) mod348)))))) tmp361) ((lambda (tmp370) (if tmp370 (apply (lambda (ids371 e1372 e2373) (let ((old-ids374 (lambda-var-list163 ids371))) (if (not (valid-bound-ids?139 old-ids374)) (syntax-violation (quote lambda) "invalid parameter list" e343) (let ((labels375 (gen-labels120 old-ids374)) (new-vars376 (map gen-var162 old-ids374))) (k349 (letrec ((f377 (lambda (ls1378 ls2379) (if (null? ls1378) (syntax->datum ls2379) (f377 (cdr ls1378) (cons (syntax->datum (car ls1378)) ls2379)))))) (f377 (cdr old-ids374) (car old-ids374))) (letrec ((f380 (lambda (ls1381 ls2382) (if (null? ls1381) ls2382 (f380 (cdr ls1381) (cons (car ls1381) ls2382)))))) (f380 (cdr new-vars376) (car new-vars376))) (if docstring344 (syntax->datum docstring344) #f) (chi-body154 (cons e1372 e2373) e343 (extend-var-env109 labels375 new-vars376 r346) (make-binding-wrap131 old-ids374 labels375 w347) mod348)))))) tmp370) ((lambda (_384) (syntax-violation (quote lambda) "bad lambda" e343)) tmp350))) ($sc-dispatch tmp350 (quote (any any . each-any)))))) ($sc-dispatch tmp350 (quote (each-any any . each-any)))))) ($sc-dispatch tmp350 (quote (any any any . each-any))))) c345))) (chi-body154 (lambda (body385 outer-form386 r387 w388 mod389) (let ((r390 (cons (quote ("placeholder" placeholder)) r387))) (let ((ribcage391 (make-ribcage121 (quote ()) (quote ()) (quote ())))) (let ((w392 (make-wrap116 (wrap-marks117 w388) (cons ribcage391 (wrap-subst118 w388))))) (letrec ((parse393 (lambda (body394 ids395 labels396 var-ids397 vars398 vals399 bindings400) (if (null? body394) (syntax-violation #f "no expressions in body" outer-form386) (let ((e402 (cdar body394)) (er403 (caar body394))) (call-with-values (lambda () (syntax-type148 e402 er403 (quote (())) #f ribcage391 mod389)) (lambda (type404 value405 e406 w407 s408 mod409) (if (memv type404 (quote (define-form))) (let ((id410 (wrap142 value405 w407 mod409)) (label411 (gen-label119))) (let ((var412 (gen-var162 id410))) (begin (extend-ribcage!130 ribcage391 id410 label411) (parse393 (cdr body394) (cons id410 ids395) (cons label411 labels396) (cons id410 var-ids397) (cons var412 vars398) (cons (cons er403 (wrap142 e406 w407 mod409)) vals399) (cons (cons (quote lexical) var412) bindings400))))) (if (memv type404 (quote (define-syntax-form))) (let ((id413 (wrap142 value405 w407 mod409)) (label414 (gen-label119))) (begin (extend-ribcage!130 ribcage391 id413 label414) (parse393 (cdr body394) (cons id413 ids395) (cons label414 labels396) var-ids397 vars398 vals399 (cons (cons (quote macro) (cons er403 (wrap142 e406 w407 mod409))) bindings400)))) (if (memv type404 (quote (begin-form))) ((lambda (tmp415) ((lambda (tmp416) (if tmp416 (apply (lambda (_417 e1418) (parse393 (letrec ((f419 (lambda (forms420) (if (null? forms420) (cdr body394) (cons (cons er403 (wrap142 (car forms420) w407 mod409)) (f419 (cdr forms420))))))) (f419 e1418)) ids395 labels396 var-ids397 vars398 vals399 bindings400)) tmp416) (syntax-violation #f "source expression failed to match any pattern" tmp415))) ($sc-dispatch tmp415 (quote (any . each-any))))) e406) (if (memv type404 (quote (local-syntax-form))) (chi-local-syntax156 value405 e406 er403 w407 s408 mod409 (lambda (forms422 er423 w424 s425 mod426) (parse393 (letrec ((f427 (lambda (forms428) (if (null? forms428) (cdr body394) (cons (cons er423 (wrap142 (car forms428) w424 mod426)) (f427 (cdr forms428))))))) (f427 forms422)) ids395 labels396 var-ids397 vars398 vals399 bindings400))) (if (null? ids395) (build-sequence93 #f (map (lambda (x429) (chi150 (cdr x429) (car x429) (quote (())) mod409)) (cons (cons er403 (source-wrap143 e406 w407 s408 mod409)) (cdr body394)))) (begin (if (not (valid-bound-ids?139 ids395)) (syntax-violation #f "invalid or duplicate identifier in definition" outer-form386)) (letrec ((loop430 (lambda (bs431 er-cache432 r-cache433) (if (not (null? bs431)) (let ((b434 (car bs431))) (if (eq? (car b434) (quote macro)) (let ((er435 (cadr b434))) (let ((r-cache436 (if (eq? er435 er-cache432) r-cache433 (macros-only-env110 er435)))) (begin (set-cdr! b434 (eval-local-transformer157 (chi150 (cddr b434) r-cache436 (quote (())) mod409) mod409)) (loop430 (cdr bs431) er435 r-cache436)))) (loop430 (cdr bs431) er-cache432 r-cache433))))))) (loop430 bindings400 #f #f)) (set-cdr! r390 (extend-env108 labels396 bindings400 (cdr r390))) (build-letrec96 #f (map syntax->datum var-ids397) vars398 (map (lambda (x437) (chi150 (cdr x437) (car x437) (quote (())) mod409)) vals399) (build-sequence93 #f (map (lambda (x438) (chi150 (cdr x438) (car x438) (quote (())) mod409)) (cons (cons er403 (source-wrap143 e406 w407 s408 mod409)) (cdr body394)))))))))))))))))) (parse393 (map (lambda (x401) (cons r390 (wrap142 x401 w392 mod389))) body385) (quote ()) (quote ()) (quote ()) (quote ()) (quote ()) (quote ())))))))) (chi-macro153 (lambda (p439 e440 r441 w442 rib443 mod444) (letrec ((rebuild-macro-output445 (lambda (x446 m447) (if (pair? x446) (cons (rebuild-macro-output445 (car x446) m447) (rebuild-macro-output445 (cdr x446) m447)) (if (syntax-object?98 x446) (let ((w448 (syntax-object-wrap100 x446))) (let ((ms449 (wrap-marks117 w448)) (s450 (wrap-subst118 w448))) (if (if (pair? ms449) (eq? (car ms449) #f) #f) (make-syntax-object97 (syntax-object-expression99 x446) (make-wrap116 (cdr ms449) (if rib443 (cons rib443 (cdr s450)) (cdr s450))) (syntax-object-module101 x446)) (make-syntax-object97 (syntax-object-expression99 x446) (make-wrap116 (cons m447 ms449) (if rib443 (cons rib443 (cons (quote shift) s450)) (cons (quote shift) s450))) (let ((pmod451 (procedure-module p439))) (if pmod451 (cons (quote hygiene) (module-name pmod451)) (quote (hygiene guile)))))))) (if (vector? x446) (let ((n452 (vector-length x446))) (let ((v453 (make-vector n452))) (letrec ((loop454 (lambda (i455) (if (fx=74 i455 n452) (begin (if #f #f) v453) (begin (vector-set! v453 i455 (rebuild-macro-output445 (vector-ref x446 i455) m447)) (loop454 (fx+72 i455 1))))))) (loop454 0)))) (if (symbol? x446) (syntax-violation #f "encountered raw symbol in macro output" (source-wrap143 e440 w442 s mod444) x446) x446))))))) (rebuild-macro-output445 (p439 (wrap142 e440 (anti-mark129 w442) mod444)) (string #\m))))) (chi-application152 (lambda (x456 e457 r458 w459 s460 mod461) ((lambda (tmp462) ((lambda (tmp463) (if tmp463 (apply (lambda (e0464 e1465) (build-application81 s460 x456 (map (lambda (e466) (chi150 e466 r458 w459 mod461)) e1465))) tmp463) (syntax-violation #f "source expression failed to match any pattern" tmp462))) ($sc-dispatch tmp462 (quote (any . each-any))))) e457))) (chi-expr151 (lambda (type468 value469 e470 r471 w472 s473 mod474) (if (memv type468 (quote (lexical))) (build-lexical-reference83 (quote value) s473 e470 value469) (if (memv type468 (quote (core external-macro))) (value469 e470 r471 w472 s473 mod474) (if (memv type468 (quote (module-ref))) (call-with-values (lambda () (value469 e470)) (lambda (id475 mod476) (build-global-reference86 s473 id475 mod476))) (if (memv type468 (quote (lexical-call))) (chi-application152 (build-lexical-reference83 (quote fun) (source-annotation105 (car e470)) (car e470) value469) e470 r471 w472 s473 mod474) (if (memv type468 (quote (global-call))) (chi-application152 (build-global-reference86 (source-annotation105 (car e470)) value469 (if (syntax-object?98 (car e470)) (syntax-object-module101 (car e470)) mod474)) e470 r471 w472 s473 mod474) (if (memv type468 (quote (constant))) (build-data92 s473 (strip161 (source-wrap143 e470 w472 s473 mod474) (quote (())))) (if (memv type468 (quote (global))) (build-global-reference86 s473 value469 mod474) (if (memv type468 (quote (call))) (chi-application152 (chi150 (car e470) r471 w472 mod474) e470 r471 w472 s473 mod474) (if (memv type468 (quote (begin-form))) ((lambda (tmp477) ((lambda (tmp478) (if tmp478 (apply (lambda (_479 e1480 e2481) (chi-sequence144 (cons e1480 e2481) r471 w472 s473 mod474)) tmp478) (syntax-violation #f "source expression failed to match any pattern" tmp477))) ($sc-dispatch tmp477 (quote (any any . each-any))))) e470) (if (memv type468 (quote (local-syntax-form))) (chi-local-syntax156 value469 e470 r471 w472 s473 mod474 chi-sequence144) (if (memv type468 (quote (eval-when-form))) ((lambda (tmp483) ((lambda (tmp484) (if tmp484 (apply (lambda (_485 x486 e1487 e2488) (let ((when-list489 (chi-when-list147 e470 x486 w472))) (if (memq (quote eval) when-list489) (chi-sequence144 (cons e1487 e2488) r471 w472 s473 mod474) (chi-void158)))) tmp484) (syntax-violation #f "source expression failed to match any pattern" tmp483))) ($sc-dispatch tmp483 (quote (any each-any any . each-any))))) e470) (if (memv type468 (quote (define-form define-syntax-form))) (syntax-violation #f "definition in expression context" e470 (wrap142 value469 w472 mod474)) (if (memv type468 (quote (syntax))) (syntax-violation #f "reference to pattern variable outside syntax form" (source-wrap143 e470 w472 s473 mod474)) (if (memv type468 (quote (displaced-lexical))) (syntax-violation #f "reference to identifier outside its scope" (source-wrap143 e470 w472 s473 mod474)) (syntax-violation #f "unexpected syntax" (source-wrap143 e470 w472 s473 mod474)))))))))))))))))) (chi150 (lambda (e492 r493 w494 mod495) (call-with-values (lambda () (syntax-type148 e492 r493 w494 #f #f mod495)) (lambda (type496 value497 e498 w499 s500 mod501) (chi-expr151 type496 value497 e498 r493 w499 s500 mod501))))) (chi-top149 (lambda (e502 r503 w504 m505 esew506 mod507) (call-with-values (lambda () (syntax-type148 e502 r503 w504 #f #f mod507)) (lambda (type515 value516 e517 w518 s519 mod520) (if (memv type515 (quote (begin-form))) ((lambda (tmp521) ((lambda (tmp522) (if tmp522 (apply (lambda (_523) (chi-void158)) tmp522) ((lambda (tmp524) (if tmp524 (apply (lambda (_525 e1526 e2527) (chi-top-sequence145 (cons e1526 e2527) r503 w518 s519 m505 esew506 mod520)) tmp524) (syntax-violation #f "source expression failed to match any pattern" tmp521))) ($sc-dispatch tmp521 (quote (any any . each-any)))))) ($sc-dispatch tmp521 (quote (any))))) e517) (if (memv type515 (quote (local-syntax-form))) (chi-local-syntax156 value516 e517 r503 w518 s519 mod520 (lambda (body529 r530 w531 s532 mod533) (chi-top-sequence145 body529 r530 w531 s532 m505 esew506 mod533))) (if (memv type515 (quote (eval-when-form))) ((lambda (tmp534) ((lambda (tmp535) (if tmp535 (apply (lambda (_536 x537 e1538 e2539) (let ((when-list540 (chi-when-list147 e517 x537 w518)) (body541 (cons e1538 e2539))) (if (eq? m505 (quote e)) (if (memq (quote eval) when-list540) (chi-top-sequence145 body541 r503 w518 s519 (quote e) (quote (eval)) mod520) (chi-void158)) (if (memq (quote load) when-list540) (if (let ((t544 (memq (quote compile) when-list540))) (if t544 t544 (if (eq? m505 (quote c&e)) (memq (quote eval) when-list540) #f))) (chi-top-sequence145 body541 r503 w518 s519 (quote c&e) (quote (compile load)) mod520) (if (memq m505 (quote (c c&e))) (chi-top-sequence145 body541 r503 w518 s519 (quote c) (quote (load)) mod520) (chi-void158))) (if (let ((t545 (memq (quote compile) when-list540))) (if t545 t545 (if (eq? m505 (quote c&e)) (memq (quote eval) when-list540) #f))) (begin (top-level-eval-hook76 (chi-top-sequence145 body541 r503 w518 s519 (quote e) (quote (eval)) mod520) mod520) (chi-void158)) (chi-void158)))))) tmp535) (syntax-violation #f "source expression failed to match any pattern" tmp534))) ($sc-dispatch tmp534 (quote (any each-any any . each-any))))) e517) (if (memv type515 (quote (define-syntax-form))) (let ((n546 (id-var-name136 value516 w518)) (r547 (macros-only-env110 r503))) (if (memv m505 (quote (c))) (if (memq (quote compile) esew506) (let ((e548 (chi-install-global146 n546 (chi150 e517 r547 w518 mod520)))) (begin (top-level-eval-hook76 e548 mod520) (if (memq (quote load) esew506) e548 (chi-void158)))) (if (memq (quote load) esew506) (chi-install-global146 n546 (chi150 e517 r547 w518 mod520)) (chi-void158))) (if (memv m505 (quote (c&e))) (let ((e549 (chi-install-global146 n546 (chi150 e517 r547 w518 mod520)))) (begin (top-level-eval-hook76 e549 mod520) e549)) (begin (if (memq (quote eval) esew506) (top-level-eval-hook76 (chi-install-global146 n546 (chi150 e517 r547 w518 mod520)) mod520)) (chi-void158))))) (if (memv type515 (quote (define-form))) (let ((n550 (id-var-name136 value516 w518))) (let ((type551 (binding-type106 (lookup111 n550 r503 mod520)))) (if (memv type551 (quote (global core macro module-ref))) (let ((x552 (build-global-definition89 s519 n550 (chi150 e517 r503 w518 mod520)))) (begin (if (eq? m505 (quote c&e)) (top-level-eval-hook76 x552 mod520)) x552)) (if (memv type551 (quote (displaced-lexical))) (syntax-violation #f "identifier out of context" e517 (wrap142 value516 w518 mod520)) (syntax-violation #f "cannot define keyword at top level" e517 (wrap142 value516 w518 mod520)))))) (let ((x553 (chi-expr151 type515 value516 e517 r503 w518 s519 mod520))) (begin (if (eq? m505 (quote c&e)) (top-level-eval-hook76 x553 mod520)) x553))))))))))) (syntax-type148 (lambda (e554 r555 w556 s557 rib558 mod559) (if (symbol? e554) (let ((n560 (id-var-name136 e554 w556))) (let ((b561 (lookup111 n560 r555 mod559))) (let ((type562 (binding-type106 b561))) (if (memv type562 (quote (lexical))) (values type562 (binding-value107 b561) e554 w556 s557 mod559) (if (memv type562 (quote (global))) (values type562 n560 e554 w556 s557 mod559) (if (memv type562 (quote (macro))) (syntax-type148 (chi-macro153 (binding-value107 b561) e554 r555 w556 rib558 mod559) r555 (quote (())) s557 rib558 mod559) (values type562 (binding-value107 b561) e554 w556 s557 mod559))))))) (if (pair? e554) (let ((first563 (car e554))) (if (id?114 first563) (let ((n564 (id-var-name136 first563 w556))) (let ((b565 (lookup111 n564 r555 (let ((t566 (if (syntax-object?98 first563) (syntax-object-module101 first563) #f))) (if t566 t566 mod559))))) (let ((type567 (binding-type106 b565))) (if (memv type567 (quote (lexical))) (values (quote lexical-call) (binding-value107 b565) e554 w556 s557 mod559) (if (memv type567 (quote (global))) (values (quote global-call) n564 e554 w556 s557 mod559) (if (memv type567 (quote (macro))) (syntax-type148 (chi-macro153 (binding-value107 b565) e554 r555 w556 rib558 mod559) r555 (quote (())) s557 rib558 mod559) (if (memv type567 (quote (core external-macro module-ref))) (values type567 (binding-value107 b565) e554 w556 s557 mod559) (if (memv type567 (quote (local-syntax))) (values (quote local-syntax-form) (binding-value107 b565) e554 w556 s557 mod559) (if (memv type567 (quote (begin))) (values (quote begin-form) #f e554 w556 s557 mod559) (if (memv type567 (quote (eval-when))) (values (quote eval-when-form) #f e554 w556 s557 mod559) (if (memv type567 (quote (define))) ((lambda (tmp568) ((lambda (tmp569) (if (if tmp569 (apply (lambda (_570 name571 val572) (id?114 name571)) tmp569) #f) (apply (lambda (_573 name574 val575) (values (quote define-form) name574 val575 w556 s557 mod559)) tmp569) ((lambda (tmp576) (if (if tmp576 (apply (lambda (_577 name578 args579 e1580 e2581) (if (id?114 name578) (valid-bound-ids?139 (lambda-var-list163 args579)) #f)) tmp576) #f) (apply (lambda (_582 name583 args584 e1585 e2586) (values (quote define-form) (wrap142 name583 w556 mod559) (cons (quote #(syntax-object lambda ((top) #(ribcage #(_ name args e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) (wrap142 (cons args584 (cons e1585 e2586)) w556 mod559)) (quote (())) s557 mod559)) tmp576) ((lambda (tmp588) (if (if tmp588 (apply (lambda (_589 name590) (id?114 name590)) tmp588) #f) (apply (lambda (_591 name592) (values (quote define-form) (wrap142 name592 w556 mod559) (quote (#(syntax-object if ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)) #(syntax-object #f ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)) #(syntax-object #f ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote (())) s557 mod559)) tmp588) (syntax-violation #f "source expression failed to match any pattern" tmp568))) ($sc-dispatch tmp568 (quote (any any)))))) ($sc-dispatch tmp568 (quote (any (any . any) any . each-any)))))) ($sc-dispatch tmp568 (quote (any any any))))) e554) (if (memv type567 (quote (define-syntax))) ((lambda (tmp593) ((lambda (tmp594) (if (if tmp594 (apply (lambda (_595 name596 val597) (id?114 name596)) tmp594) #f) (apply (lambda (_598 name599 val600) (values (quote define-syntax-form) name599 val600 w556 s557 mod559)) tmp594) (syntax-violation #f "source expression failed to match any pattern" tmp593))) ($sc-dispatch tmp593 (quote (any any any))))) e554) (values (quote call) #f e554 w556 s557 mod559))))))))))))) (values (quote call) #f e554 w556 s557 mod559))) (if (syntax-object?98 e554) (syntax-type148 (syntax-object-expression99 e554) r555 (join-wraps133 w556 (syntax-object-wrap100 e554)) #f rib558 (let ((t601 (syntax-object-module101 e554))) (if t601 t601 mod559))) (if (annotation? e554) (syntax-type148 (annotation-expression e554) r555 w556 (annotation-source e554) rib558 mod559) (if (self-evaluating? e554) (values (quote constant) #f e554 w556 s557 mod559) (values (quote other) #f e554 w556 s557 mod559)))))))) (chi-when-list147 (lambda (e602 when-list603 w604) (letrec ((f605 (lambda (when-list606 situations607) (if (null? when-list606) situations607 (f605 (cdr when-list606) (cons (let ((x608 (car when-list606))) (if (free-id=?137 x608 (quote #(syntax-object compile ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote compile) (if (free-id=?137 x608 (quote #(syntax-object load ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote load) (if (free-id=?137 x608 (quote #(syntax-object eval ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote eval) (syntax-violation (quote eval-when) "invalid situation" e602 (wrap142 x608 w604 #f)))))) situations607)))))) (f605 when-list603 (quote ()))))) (chi-install-global146 (lambda (name609 e610) (build-global-definition89 #f name609 (if (let ((v611 (module-variable (current-module) name609))) (if v611 (if (variable-bound? v611) (if (macro? (variable-ref v611)) (not (eq? (macro-type (variable-ref v611)) (quote syncase-macro))) #f) #f) #f)) (build-application81 #f (build-primref91 #f (quote make-extended-syncase-macro)) (list (build-application81 #f (build-primref91 #f (quote module-ref)) (list (build-application81 #f (build-primref91 #f (quote current-module)) (quote ())) (build-data92 #f name609))) (build-data92 #f (quote macro)) e610)) (build-application81 #f (build-primref91 #f (quote make-syncase-macro)) (list (build-data92 #f (quote macro)) e610)))))) (chi-top-sequence145 (lambda (body612 r613 w614 s615 m616 esew617 mod618) (build-sequence93 s615 (letrec ((dobody619 (lambda (body620 r621 w622 m623 esew624 mod625) (if (null? body620) (quote ()) (let ((first626 (chi-top149 (car body620) r621 w622 m623 esew624 mod625))) (cons first626 (dobody619 (cdr body620) r621 w622 m623 esew624 mod625))))))) (dobody619 body612 r613 w614 m616 esew617 mod618))))) (chi-sequence144 (lambda (body627 r628 w629 s630 mod631) (build-sequence93 s630 (letrec ((dobody632 (lambda (body633 r634 w635 mod636) (if (null? body633) (quote ()) (let ((first637 (chi150 (car body633) r634 w635 mod636))) (cons first637 (dobody632 (cdr body633) r634 w635 mod636))))))) (dobody632 body627 r628 w629 mod631))))) (source-wrap143 (lambda (x638 w639 s640 defmod641) (wrap142 (if s640 (make-annotation x638 s640 #f) x638) w639 defmod641))) (wrap142 (lambda (x642 w643 defmod644) (if (if (null? (wrap-marks117 w643)) (null? (wrap-subst118 w643)) #f) x642 (if (syntax-object?98 x642) (make-syntax-object97 (syntax-object-expression99 x642) (join-wraps133 w643 (syntax-object-wrap100 x642)) (syntax-object-module101 x642)) (if (null? x642) x642 (make-syntax-object97 x642 w643 defmod644)))))) (bound-id-member?141 (lambda (x645 list646) (if (not (null? list646)) (let ((t647 (bound-id=?138 x645 (car list646)))) (if t647 t647 (bound-id-member?141 x645 (cdr list646)))) #f))) (distinct-bound-ids?140 (lambda (ids648) (letrec ((distinct?649 (lambda (ids650) (let ((t651 (null? ids650))) (if t651 t651 (if (not (bound-id-member?141 (car ids650) (cdr ids650))) (distinct?649 (cdr ids650)) #f)))))) (distinct?649 ids648)))) (valid-bound-ids?139 (lambda (ids652) (if (letrec ((all-ids?653 (lambda (ids654) (let ((t655 (null? ids654))) (if t655 t655 (if (id?114 (car ids654)) (all-ids?653 (cdr ids654)) #f)))))) (all-ids?653 ids652)) (distinct-bound-ids?140 ids652) #f))) (bound-id=?138 (lambda (i656 j657) (if (if (syntax-object?98 i656) (syntax-object?98 j657) #f) (if (eq? (let ((e658 (syntax-object-expression99 i656))) (if (annotation? e658) (annotation-expression e658) e658)) (let ((e659 (syntax-object-expression99 j657))) (if (annotation? e659) (annotation-expression e659) e659))) (same-marks?135 (wrap-marks117 (syntax-object-wrap100 i656)) (wrap-marks117 (syntax-object-wrap100 j657))) #f) (eq? (let ((e660 i656)) (if (annotation? e660) (annotation-expression e660) e660)) (let ((e661 j657)) (if (annotation? e661) (annotation-expression e661) e661)))))) (free-id=?137 (lambda (i662 j663) (if (eq? (let ((x664 i662)) (let ((e665 (if (syntax-object?98 x664) (syntax-object-expression99 x664) x664))) (if (annotation? e665) (annotation-expression e665) e665))) (let ((x666 j663)) (let ((e667 (if (syntax-object?98 x666) (syntax-object-expression99 x666) x666))) (if (annotation? e667) (annotation-expression e667) e667)))) (eq? (id-var-name136 i662 (quote (()))) (id-var-name136 j663 (quote (())))) #f))) (id-var-name136 (lambda (id668 w669) (letrec ((search-vector-rib672 (lambda (sym678 subst679 marks680 symnames681 ribcage682) (let ((n683 (vector-length symnames681))) (letrec ((f684 (lambda (i685) (if (fx=74 i685 n683) (search670 sym678 (cdr subst679) marks680) (if (if (eq? (vector-ref symnames681 i685) sym678) (same-marks?135 marks680 (vector-ref (ribcage-marks124 ribcage682) i685)) #f) (values (vector-ref (ribcage-labels125 ribcage682) i685) marks680) (f684 (fx+72 i685 1))))))) (f684 0))))) (search-list-rib671 (lambda (sym686 subst687 marks688 symnames689 ribcage690) (letrec ((f691 (lambda (symnames692 i693) (if (null? symnames692) (search670 sym686 (cdr subst687) marks688) (if (if (eq? (car symnames692) sym686) (same-marks?135 marks688 (list-ref (ribcage-marks124 ribcage690) i693)) #f) (values (list-ref (ribcage-labels125 ribcage690) i693) marks688) (f691 (cdr symnames692) (fx+72 i693 1))))))) (f691 symnames689 0)))) (search670 (lambda (sym694 subst695 marks696) (if (null? subst695) (values #f marks696) (let ((fst697 (car subst695))) (if (eq? fst697 (quote shift)) (search670 sym694 (cdr subst695) (cdr marks696)) (let ((symnames698 (ribcage-symnames123 fst697))) (if (vector? symnames698) (search-vector-rib672 sym694 subst695 marks696 symnames698 fst697) (search-list-rib671 sym694 subst695 marks696 symnames698 fst697))))))))) (if (symbol? id668) (let ((t699 (call-with-values (lambda () (search670 id668 (wrap-subst118 w669) (wrap-marks117 w669))) (lambda (x701 . ignore700) x701)))) (if t699 t699 id668)) (if (syntax-object?98 id668) (let ((id702 (let ((e704 (syntax-object-expression99 id668))) (if (annotation? e704) (annotation-expression e704) e704))) (w1703 (syntax-object-wrap100 id668))) (let ((marks705 (join-marks134 (wrap-marks117 w669) (wrap-marks117 w1703)))) (call-with-values (lambda () (search670 id702 (wrap-subst118 w669) marks705)) (lambda (new-id706 marks707) (let ((t708 new-id706)) (if t708 t708 (let ((t709 (call-with-values (lambda () (search670 id702 (wrap-subst118 w1703) marks707)) (lambda (x711 . ignore710) x711)))) (if t709 t709 id702)))))))) (if (annotation? id668) (let ((id712 (let ((e713 id668)) (if (annotation? e713) (annotation-expression e713) e713)))) (let ((t714 (call-with-values (lambda () (search670 id712 (wrap-subst118 w669) (wrap-marks117 w669))) (lambda (x716 . ignore715) x716)))) (if t714 t714 id712))) (syntax-violation (quote id-var-name) "invalid id" id668))))))) (same-marks?135 (lambda (x717 y718) (let ((t719 (eq? x717 y718))) (if t719 t719 (if (not (null? x717)) (if (not (null? y718)) (if (eq? (car x717) (car y718)) (same-marks?135 (cdr x717) (cdr y718)) #f) #f) #f))))) (join-marks134 (lambda (m1720 m2721) (smart-append132 m1720 m2721))) (join-wraps133 (lambda (w1722 w2723) (let ((m1724 (wrap-marks117 w1722)) (s1725 (wrap-subst118 w1722))) (if (null? m1724) (if (null? s1725) w2723 (make-wrap116 (wrap-marks117 w2723) (smart-append132 s1725 (wrap-subst118 w2723)))) (make-wrap116 (smart-append132 m1724 (wrap-marks117 w2723)) (smart-append132 s1725 (wrap-subst118 w2723))))))) (smart-append132 (lambda (m1726 m2727) (if (null? m2727) m1726 (append m1726 m2727)))) (make-binding-wrap131 (lambda (ids728 labels729 w730) (if (null? ids728) w730 (make-wrap116 (wrap-marks117 w730) (cons (let ((labelvec731 (list->vector labels729))) (let ((n732 (vector-length labelvec731))) (let ((symnamevec733 (make-vector n732)) (marksvec734 (make-vector n732))) (begin (letrec ((f735 (lambda (ids736 i737) (if (not (null? ids736)) (call-with-values (lambda () (id-sym-name&marks115 (car ids736) w730)) (lambda (symname738 marks739) (begin (vector-set! symnamevec733 i737 symname738) (vector-set! marksvec734 i737 marks739) (f735 (cdr ids736) (fx+72 i737 1))))))))) (f735 ids728 0)) (make-ribcage121 symnamevec733 marksvec734 labelvec731))))) (wrap-subst118 w730)))))) (extend-ribcage!130 (lambda (ribcage740 id741 label742) (begin (set-ribcage-symnames!126 ribcage740 (cons (let ((e743 (syntax-object-expression99 id741))) (if (annotation? e743) (annotation-expression e743) e743)) (ribcage-symnames123 ribcage740))) (set-ribcage-marks!127 ribcage740 (cons (wrap-marks117 (syntax-object-wrap100 id741)) (ribcage-marks124 ribcage740))) (set-ribcage-labels!128 ribcage740 (cons label742 (ribcage-labels125 ribcage740)))))) (anti-mark129 (lambda (w744) (make-wrap116 (cons #f (wrap-marks117 w744)) (cons (quote shift) (wrap-subst118 w744))))) (set-ribcage-labels!128 (lambda (x745 update746) (vector-set! x745 3 update746))) (set-ribcage-marks!127 (lambda (x747 update748) (vector-set! x747 2 update748))) (set-ribcage-symnames!126 (lambda (x749 update750) (vector-set! x749 1 update750))) (ribcage-labels125 (lambda (x751) (vector-ref x751 3))) (ribcage-marks124 (lambda (x752) (vector-ref x752 2))) (ribcage-symnames123 (lambda (x753) (vector-ref x753 1))) (ribcage?122 (lambda (x754) (if (vector? x754) (if (= (vector-length x754) 4) (eq? (vector-ref x754 0) (quote ribcage)) #f) #f))) (make-ribcage121 (lambda (symnames755 marks756 labels757) (vector (quote ribcage) symnames755 marks756 labels757))) (gen-labels120 (lambda (ls758) (if (null? ls758) (quote ()) (cons (gen-label119) (gen-labels120 (cdr ls758)))))) (gen-label119 (lambda () (string #\i))) (wrap-subst118 cdr) (wrap-marks117 car) (make-wrap116 cons) (id-sym-name&marks115 (lambda (x759 w760) (if (syntax-object?98 x759) (values (let ((e761 (syntax-object-expression99 x759))) (if (annotation? e761) (annotation-expression e761) e761)) (join-marks134 (wrap-marks117 w760) (wrap-marks117 (syntax-object-wrap100 x759)))) (values (let ((e762 x759)) (if (annotation? e762) (annotation-expression e762) e762)) (wrap-marks117 w760))))) (id?114 (lambda (x763) (if (symbol? x763) #t (if (syntax-object?98 x763) (symbol? (let ((e764 (syntax-object-expression99 x763))) (if (annotation? e764) (annotation-expression e764) e764))) (if (annotation? x763) (symbol? (annotation-expression x763)) #f))))) (nonsymbol-id?113 (lambda (x765) (if (syntax-object?98 x765) (symbol? (let ((e766 (syntax-object-expression99 x765))) (if (annotation? e766) (annotation-expression e766) e766))) #f))) (global-extend112 (lambda (type767 sym768 val769) (put-global-definition-hook78 sym768 type767 val769))) (lookup111 (lambda (x770 r771 mod772) (let ((t773 (assq x770 r771))) (if t773 (cdr t773) (if (symbol? x770) (let ((t774 (get-global-definition-hook79 x770 mod772))) (if t774 t774 (quote (global)))) (quote (displaced-lexical))))))) (macros-only-env110 (lambda (r775) (if (null? r775) (quote ()) (let ((a776 (car r775))) (if (eq? (cadr a776) (quote macro)) (cons a776 (macros-only-env110 (cdr r775))) (macros-only-env110 (cdr r775))))))) (extend-var-env109 (lambda (labels777 vars778 r779) (if (null? labels777) r779 (extend-var-env109 (cdr labels777) (cdr vars778) (cons (cons (car labels777) (cons (quote lexical) (car vars778))) r779))))) (extend-env108 (lambda (labels780 bindings781 r782) (if (null? labels780) r782 (extend-env108 (cdr labels780) (cdr bindings781) (cons (cons (car labels780) (car bindings781)) r782))))) (binding-value107 cdr) (binding-type106 car) (source-annotation105 (lambda (x783) (if (annotation? x783) (annotation-source x783) (if (syntax-object?98 x783) (source-annotation105 (syntax-object-expression99 x783)) #f)))) (set-syntax-object-module!104 (lambda (x784 update785) (vector-set! x784 3 update785))) (set-syntax-object-wrap!103 (lambda (x786 update787) (vector-set! x786 2 update787))) (set-syntax-object-expression!102 (lambda (x788 update789) (vector-set! x788 1 update789))) (syntax-object-module101 (lambda (x790) (vector-ref x790 3))) (syntax-object-wrap100 (lambda (x791) (vector-ref x791 2))) (syntax-object-expression99 (lambda (x792) (vector-ref x792 1))) (syntax-object?98 (lambda (x793) (if (vector? x793) (if (= (vector-length x793) 4) (eq? (vector-ref x793 0) (quote syntax-object)) #f) #f))) (make-syntax-object97 (lambda (expression794 wrap795 module796) (vector (quote syntax-object) expression794 wrap795 module796))) (build-letrec96 (lambda (src797 ids798 vars799 val-exps800 body-exp801) (if (null? vars799) body-exp801 (let ((atom-key802 (fluid-ref *mode*71))) (if (memv atom-key802 (quote (c))) (begin (for-each maybe-name-value!88 ids798 val-exps800) ((@ (language tree-il) make-letrec) src797 ids798 vars799 val-exps800 body-exp801)) (list (quote letrec) (map list vars799 val-exps800) body-exp801)))))) (build-named-let95 (lambda (src803 ids804 vars805 val-exps806 body-exp807) (let ((f808 (car vars805)) (f-name809 (car ids804)) (vars810 (cdr vars805)) (ids811 (cdr ids804))) (let ((atom-key812 (fluid-ref *mode*71))) (if (memv atom-key812 (quote (c))) (let ((proc813 (build-lambda90 src803 ids811 vars810 #f body-exp807))) (begin (maybe-name-value!88 f-name809 proc813) (for-each maybe-name-value!88 ids811 val-exps806) ((@ (language tree-il) make-letrec) src803 (list f-name809) (list f808) (list proc813) (build-application81 src803 (build-lexical-reference83 (quote fun) src803 f-name809 f808) val-exps806)))) (list (quote let) f808 (map list vars810 val-exps806) body-exp807)))))) (build-let94 (lambda (src814 ids815 vars816 val-exps817 body-exp818) (if (null? vars816) body-exp818 (let ((atom-key819 (fluid-ref *mode*71))) (if (memv atom-key819 (quote (c))) (begin (for-each maybe-name-value!88 ids815 val-exps817) ((@ (language tree-il) make-let) src814 ids815 vars816 val-exps817 body-exp818)) (list (quote let) (map list vars816 val-exps817) body-exp818)))))) (build-sequence93 (lambda (src820 exps821) (if (null? (cdr exps821)) (car exps821) (let ((atom-key822 (fluid-ref *mode*71))) (if (memv atom-key822 (quote (c))) ((@ (language tree-il) make-sequence) src820 exps821) (cons (quote begin) exps821)))))) (build-data92 (lambda (src823 exp824) (let ((atom-key825 (fluid-ref *mode*71))) (if (memv atom-key825 (quote (c))) ((@ (language tree-il) make-const) src823 exp824) (if (if (self-evaluating? exp824) (not (vector? exp824)) #f) exp824 (list (quote quote) exp824)))))) (build-primref91 (lambda (src826 name827) (if (equal? (module-name (current-module)) (quote (guile))) (let ((atom-key828 (fluid-ref *mode*71))) (if (memv atom-key828 (quote (c))) ((@ (language tree-il) make-toplevel-ref) src826 name827) name827)) (let ((atom-key829 (fluid-ref *mode*71))) (if (memv atom-key829 (quote (c))) ((@ (language tree-il) make-module-ref) src826 (quote (guile)) name827 #f) (list (quote @@) (quote (guile)) name827)))))) (build-lambda90 (lambda (src830 ids831 vars832 docstring833 exp834) (let ((atom-key835 (fluid-ref *mode*71))) (if (memv atom-key835 (quote (c))) ((@ (language tree-il) make-lambda) src830 ids831 vars832 (if docstring833 (list (cons (quote documentation) docstring833)) (quote ())) exp834) (cons (quote lambda) (cons vars832 (append (if docstring833 (list docstring833) (quote ())) (list exp834)))))))) (build-global-definition89 (lambda (source836 var837 exp838) (let ((atom-key839 (fluid-ref *mode*71))) (if (memv atom-key839 (quote (c))) (begin (maybe-name-value!88 var837 exp838) ((@ (language tree-il) make-toplevel-define) source836 var837 exp838)) (list (quote define) var837 exp838))))) (maybe-name-value!88 (lambda (name840 val841) (if ((@ (language tree-il) lambda?) val841) (let ((meta842 ((@ (language tree-il) lambda-meta) val841))) (if (not (assq (quote name) meta842)) ((setter (@ (language tree-il) lambda-meta)) val841 (acons (quote name) name840 meta842))))))) (build-global-assignment87 (lambda (source843 var844 exp845 mod846) (analyze-variable85 mod846 var844 (lambda (mod847 var848 public?849) (let ((atom-key850 (fluid-ref *mode*71))) (if (memv atom-key850 (quote (c))) ((@ (language tree-il) make-module-set) source843 mod847 var848 public?849 exp845) (list (quote set!) (list (if public?849 (quote @) (quote @@)) mod847 var848) exp845)))) (lambda (var851) (let ((atom-key852 (fluid-ref *mode*71))) (if (memv atom-key852 (quote (c))) ((@ (language tree-il) make-toplevel-set) source843 var851 exp845) (list (quote set!) var851 exp845))))))) (build-global-reference86 (lambda (source853 var854 mod855) (analyze-variable85 mod855 var854 (lambda (mod856 var857 public?858) (let ((atom-key859 (fluid-ref *mode*71))) (if (memv atom-key859 (quote (c))) ((@ (language tree-il) make-module-ref) source853 mod856 var857 public?858) (list (if public?858 (quote @) (quote @@)) mod856 var857)))) (lambda (var860) (let ((atom-key861 (fluid-ref *mode*71))) (if (memv atom-key861 (quote (c))) ((@ (language tree-il) make-toplevel-ref) source853 var860) var860)))))) (analyze-variable85 (lambda (mod862 var863 modref-cont864 bare-cont865) (if (not mod862) (bare-cont865 var863) (let ((kind866 (car mod862)) (mod867 (cdr mod862))) (if (memv kind866 (quote (public))) (modref-cont864 mod867 var863 #t) (if (memv kind866 (quote (private))) (if (not (equal? mod867 (module-name (current-module)))) (modref-cont864 mod867 var863 #f) (bare-cont865 var863)) (if (memv kind866 (quote (bare))) (bare-cont865 var863) (if (memv kind866 (quote (hygiene))) (if (if (not (equal? mod867 (module-name (current-module)))) (module-variable (resolve-module mod867) var863) #f) (modref-cont864 mod867 var863 #f) (bare-cont865 var863)) (syntax-violation #f "bad module kind" var863 mod867))))))))) (build-lexical-assignment84 (lambda (source868 name869 var870 exp871) (let ((atom-key872 (fluid-ref *mode*71))) (if (memv atom-key872 (quote (c))) ((@ (language tree-il) make-lexical-set) source868 name869 var870 exp871) (list (quote set!) var870 exp871))))) (build-lexical-reference83 (lambda (type873 source874 name875 var876) (let ((atom-key877 (fluid-ref *mode*71))) (if (memv atom-key877 (quote (c))) ((@ (language tree-il) make-lexical-ref) source874 name875 var876) var876)))) (build-conditional82 (lambda (source878 test-exp879 then-exp880 else-exp881) (let ((atom-key882 (fluid-ref *mode*71))) (if (memv atom-key882 (quote (c))) ((@ (language tree-il) make-conditional) source878 test-exp879 then-exp880 else-exp881) (if (equal? else-exp881 (quote (if #f #f))) (list (quote if) test-exp879 then-exp880) (list (quote if) test-exp879 then-exp880 else-exp881)))))) (build-application81 (lambda (source883 fun-exp884 arg-exps885) (let ((atom-key886 (fluid-ref *mode*71))) (if (memv atom-key886 (quote (c))) ((@ (language tree-il) make-application) source883 fun-exp884 arg-exps885) (cons fun-exp884 arg-exps885))))) (build-void80 (lambda (source887) (let ((atom-key888 (fluid-ref *mode*71))) (if (memv atom-key888 (quote (c))) ((@ (language tree-il) make-void) source887) (quote (if #f #f)))))) (get-global-definition-hook79 (lambda (symbol889 module890) (begin (if (if (not module890) (current-module) #f) (warn "module system is booted, we should have a module" symbol889)) (let ((v891 (module-variable (if module890 (resolve-module (cdr module890)) (current-module)) symbol889))) (if v891 (if (variable-bound? v891) (let ((val892 (variable-ref v891))) (if (macro? val892) (if (syncase-macro-type val892) (cons (syncase-macro-type val892) (syncase-macro-binding val892)) #f) #f)) #f) #f))))) (put-global-definition-hook78 (lambda (symbol893 type894 val895) (let ((existing896 (let ((v897 (module-variable (current-module) symbol893))) (if v897 (if (variable-bound? v897) (let ((val898 (variable-ref v897))) (if (macro? val898) (if (not (syncase-macro-type val898)) val898 #f) #f)) #f) #f)))) (module-define! (current-module) symbol893 (if existing896 (make-extended-syncase-macro existing896 type894 val895) (make-syncase-macro type894 val895)))))) (local-eval-hook77 (lambda (x899 mod900) (primitive-eval (list noexpand70 (let ((atom-key901 (fluid-ref *mode*71))) (if (memv atom-key901 (quote (c))) ((@ (language tree-il) tree-il->scheme) x899) x899)))))) (top-level-eval-hook76 (lambda (x902 mod903) (primitive-eval (list noexpand70 (let ((atom-key904 (fluid-ref *mode*71))) (if (memv atom-key904 (quote (c))) ((@ (language tree-il) tree-il->scheme) x902) x902)))))) (fx<75 <) (fx=74 =) (fx-73 -) (fx+72 +) (*mode*71 (make-fluid)) (noexpand70 "noexpand")) (begin (global-extend112 (quote local-syntax) (quote letrec-syntax) #t) (global-extend112 (quote local-syntax) (quote let-syntax) #f) (global-extend112 (quote core) (quote fluid-let-syntax) (lambda (e905 r906 w907 s908 mod909) ((lambda (tmp910) ((lambda (tmp911) (if (if tmp911 (apply (lambda (_912 var913 val914 e1915 e2916) (valid-bound-ids?139 var913)) tmp911) #f) (apply (lambda (_918 var919 val920 e1921 e2922) (let ((names923 (map (lambda (x924) (id-var-name136 x924 w907)) var919))) (begin (for-each (lambda (id926 n927) (let ((atom-key928 (binding-type106 (lookup111 n927 r906 mod909)))) (if (memv atom-key928 (quote (displaced-lexical))) (syntax-violation (quote fluid-let-syntax) "identifier out of context" e905 (source-wrap143 id926 w907 s908 mod909))))) var919 names923) (chi-body154 (cons e1921 e2922) (source-wrap143 e905 w907 s908 mod909) (extend-env108 names923 (let ((trans-r931 (macros-only-env110 r906))) (map (lambda (x932) (cons (quote macro) (eval-local-transformer157 (chi150 x932 trans-r931 w907 mod909) mod909))) val920)) r906) w907 mod909)))) tmp911) ((lambda (_934) (syntax-violation (quote fluid-let-syntax) "bad syntax" (source-wrap143 e905 w907 s908 mod909))) tmp910))) ($sc-dispatch tmp910 (quote (any #(each (any any)) any . each-any))))) e905))) (global-extend112 (quote core) (quote quote) (lambda (e935 r936 w937 s938 mod939) ((lambda (tmp940) ((lambda (tmp941) (if tmp941 (apply (lambda (_942 e943) (build-data92 s938 (strip161 e943 w937))) tmp941) ((lambda (_944) (syntax-violation (quote quote) "bad syntax" (source-wrap143 e935 w937 s938 mod939))) tmp940))) ($sc-dispatch tmp940 (quote (any any))))) e935))) (global-extend112 (quote core) (quote syntax) (letrec ((regen952 (lambda (x953) (let ((atom-key954 (car x953))) (if (memv atom-key954 (quote (ref))) (build-lexical-reference83 (quote value) #f (cadr x953) (cadr x953)) (if (memv atom-key954 (quote (primitive))) (build-primref91 #f (cadr x953)) (if (memv atom-key954 (quote (quote))) (build-data92 #f (cadr x953)) (if (memv atom-key954 (quote (lambda))) (build-lambda90 #f (cadr x953) (cadr x953) #f (regen952 (caddr x953))) (if (memv atom-key954 (quote (map))) (let ((ls955 (map regen952 (cdr x953)))) (build-application81 #f (build-primref91 #f (quote map)) ls955)) (build-application81 #f (build-primref91 #f (car x953)) (map regen952 (cdr x953))))))))))) (gen-vector951 (lambda (x956) (if (eq? (car x956) (quote list)) (cons (quote vector) (cdr x956)) (if (eq? (car x956) (quote quote)) (list (quote quote) (list->vector (cadr x956))) (list (quote list->vector) x956))))) (gen-append950 (lambda (x957 y958) (if (equal? y958 (quote (quote ()))) x957 (list (quote append) x957 y958)))) (gen-cons949 (lambda (x959 y960) (let ((atom-key961 (car y960))) (if (memv atom-key961 (quote (quote))) (if (eq? (car x959) (quote quote)) (list (quote quote) (cons (cadr x959) (cadr y960))) (if (eq? (cadr y960) (quote ())) (list (quote list) x959) (list (quote cons) x959 y960))) (if (memv atom-key961 (quote (list))) (cons (quote list) (cons x959 (cdr y960))) (list (quote cons) x959 y960)))))) (gen-map948 (lambda (e962 map-env963) (let ((formals964 (map cdr map-env963)) (actuals965 (map (lambda (x966) (list (quote ref) (car x966))) map-env963))) (if (eq? (car e962) (quote ref)) (car actuals965) (if (and-map (lambda (x967) (if (eq? (car x967) (quote ref)) (memq (cadr x967) formals964) #f)) (cdr e962)) (cons (quote map) (cons (list (quote primitive) (car e962)) (map (let ((r968 (map cons formals964 actuals965))) (lambda (x969) (cdr (assq (cadr x969) r968)))) (cdr e962)))) (cons (quote map) (cons (list (quote lambda) formals964 e962) actuals965))))))) (gen-mappend947 (lambda (e970 map-env971) (list (quote apply) (quote (primitive append)) (gen-map948 e970 map-env971)))) (gen-ref946 (lambda (src972 var973 level974 maps975) (if (fx=74 level974 0) (values var973 maps975) (if (null? maps975) (syntax-violation (quote syntax) "missing ellipsis" src972) (call-with-values (lambda () (gen-ref946 src972 var973 (fx-73 level974 1) (cdr maps975))) (lambda (outer-var976 outer-maps977) (let ((b978 (assq outer-var976 (car maps975)))) (if b978 (values (cdr b978) maps975) (let ((inner-var979 (gen-var162 (quote tmp)))) (values inner-var979 (cons (cons (cons outer-var976 inner-var979) (car maps975)) outer-maps977))))))))))) (gen-syntax945 (lambda (src980 e981 r982 maps983 ellipsis?984 mod985) (if (id?114 e981) (let ((label986 (id-var-name136 e981 (quote (()))))) (let ((b987 (lookup111 label986 r982 mod985))) (if (eq? (binding-type106 b987) (quote syntax)) (call-with-values (lambda () (let ((var.lev988 (binding-value107 b987))) (gen-ref946 src980 (car var.lev988) (cdr var.lev988) maps983))) (lambda (var989 maps990) (values (list (quote ref) var989) maps990))) (if (ellipsis?984 e981) (syntax-violation (quote syntax) "misplaced ellipsis" src980) (values (list (quote quote) e981) maps983))))) ((lambda (tmp991) ((lambda (tmp992) (if (if tmp992 (apply (lambda (dots993 e994) (ellipsis?984 dots993)) tmp992) #f) (apply (lambda (dots995 e996) (gen-syntax945 src980 e996 r982 maps983 (lambda (x997) #f) mod985)) tmp992) ((lambda (tmp998) (if (if tmp998 (apply (lambda (x999 dots1000 y1001) (ellipsis?984 dots1000)) tmp998) #f) (apply (lambda (x1002 dots1003 y1004) (letrec ((f1005 (lambda (y1006 k1007) ((lambda (tmp1011) ((lambda (tmp1012) (if (if tmp1012 (apply (lambda (dots1013 y1014) (ellipsis?984 dots1013)) tmp1012) #f) (apply (lambda (dots1015 y1016) (f1005 y1016 (lambda (maps1017) (call-with-values (lambda () (k1007 (cons (quote ()) maps1017))) (lambda (x1018 maps1019) (if (null? (car maps1019)) (syntax-violation (quote syntax) "extra ellipsis" src980) (values (gen-mappend947 x1018 (car maps1019)) (cdr maps1019)))))))) tmp1012) ((lambda (_1020) (call-with-values (lambda () (gen-syntax945 src980 y1006 r982 maps983 ellipsis?984 mod985)) (lambda (y1021 maps1022) (call-with-values (lambda () (k1007 maps1022)) (lambda (x1023 maps1024) (values (gen-append950 x1023 y1021) maps1024)))))) tmp1011))) ($sc-dispatch tmp1011 (quote (any . any))))) y1006)))) (f1005 y1004 (lambda (maps1008) (call-with-values (lambda () (gen-syntax945 src980 x1002 r982 (cons (quote ()) maps1008) ellipsis?984 mod985)) (lambda (x1009 maps1010) (if (null? (car maps1010)) (syntax-violation (quote syntax) "extra ellipsis" src980) (values (gen-map948 x1009 (car maps1010)) (cdr maps1010))))))))) tmp998) ((lambda (tmp1025) (if tmp1025 (apply (lambda (x1026 y1027) (call-with-values (lambda () (gen-syntax945 src980 x1026 r982 maps983 ellipsis?984 mod985)) (lambda (x1028 maps1029) (call-with-values (lambda () (gen-syntax945 src980 y1027 r982 maps1029 ellipsis?984 mod985)) (lambda (y1030 maps1031) (values (gen-cons949 x1028 y1030) maps1031)))))) tmp1025) ((lambda (tmp1032) (if tmp1032 (apply (lambda (e11033 e21034) (call-with-values (lambda () (gen-syntax945 src980 (cons e11033 e21034) r982 maps983 ellipsis?984 mod985)) (lambda (e1036 maps1037) (values (gen-vector951 e1036) maps1037)))) tmp1032) ((lambda (_1038) (values (list (quote quote) e981) maps983)) tmp991))) ($sc-dispatch tmp991 (quote #(vector (any . each-any))))))) ($sc-dispatch tmp991 (quote (any . any)))))) ($sc-dispatch tmp991 (quote (any any . any)))))) ($sc-dispatch tmp991 (quote (any any))))) e981))))) (lambda (e1039 r1040 w1041 s1042 mod1043) (let ((e1044 (source-wrap143 e1039 w1041 s1042 mod1043))) ((lambda (tmp1045) ((lambda (tmp1046) (if tmp1046 (apply (lambda (_1047 x1048) (call-with-values (lambda () (gen-syntax945 e1044 x1048 r1040 (quote ()) ellipsis?159 mod1043)) (lambda (e1049 maps1050) (regen952 e1049)))) tmp1046) ((lambda (_1051) (syntax-violation (quote syntax) "bad `syntax' form" e1044)) tmp1045))) ($sc-dispatch tmp1045 (quote (any any))))) e1044))))) (global-extend112 (quote core) (quote lambda) (lambda (e1052 r1053 w1054 s1055 mod1056) ((lambda (tmp1057) ((lambda (tmp1058) (if tmp1058 (apply (lambda (_1059 c1060) (chi-lambda-clause155 (source-wrap143 e1052 w1054 s1055 mod1056) #f c1060 r1053 w1054 mod1056 (lambda (names1061 vars1062 docstring1063 body1064) (build-lambda90 s1055 names1061 vars1062 docstring1063 body1064)))) tmp1058) (syntax-violation #f "source expression failed to match any pattern" tmp1057))) ($sc-dispatch tmp1057 (quote (any . any))))) e1052))) (global-extend112 (quote core) (quote let) (letrec ((chi-let1065 (lambda (e1066 r1067 w1068 s1069 mod1070 constructor1071 ids1072 vals1073 exps1074) (if (not (valid-bound-ids?139 ids1072)) (syntax-violation (quote let) "duplicate bound variable" e1066) (let ((labels1075 (gen-labels120 ids1072)) (new-vars1076 (map gen-var162 ids1072))) (let ((nw1077 (make-binding-wrap131 ids1072 labels1075 w1068)) (nr1078 (extend-var-env109 labels1075 new-vars1076 r1067))) (constructor1071 s1069 (map syntax->datum ids1072) new-vars1076 (map (lambda (x1079) (chi150 x1079 r1067 w1068 mod1070)) vals1073) (chi-body154 exps1074 (source-wrap143 e1066 nw1077 s1069 mod1070) nr1078 nw1077 mod1070)))))))) (lambda (e1080 r1081 w1082 s1083 mod1084) ((lambda (tmp1085) ((lambda (tmp1086) (if (if tmp1086 (apply (lambda (_1087 id1088 val1089 e11090 e21091) (and-map id?114 id1088)) tmp1086) #f) (apply (lambda (_1093 id1094 val1095 e11096 e21097) (chi-let1065 e1080 r1081 w1082 s1083 mod1084 build-let94 id1094 val1095 (cons e11096 e21097))) tmp1086) ((lambda (tmp1101) (if (if tmp1101 (apply (lambda (_1102 f1103 id1104 val1105 e11106 e21107) (if (id?114 f1103) (and-map id?114 id1104) #f)) tmp1101) #f) (apply (lambda (_1109 f1110 id1111 val1112 e11113 e21114) (chi-let1065 e1080 r1081 w1082 s1083 mod1084 build-named-let95 (cons f1110 id1111) val1112 (cons e11113 e21114))) tmp1101) ((lambda (_1118) (syntax-violation (quote let) "bad let" (source-wrap143 e1080 w1082 s1083 mod1084))) tmp1085))) ($sc-dispatch tmp1085 (quote (any any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp1085 (quote (any #(each (any any)) any . each-any))))) e1080)))) (global-extend112 (quote core) (quote letrec) (lambda (e1119 r1120 w1121 s1122 mod1123) ((lambda (tmp1124) ((lambda (tmp1125) (if (if tmp1125 (apply (lambda (_1126 id1127 val1128 e11129 e21130) (and-map id?114 id1127)) tmp1125) #f) (apply (lambda (_1132 id1133 val1134 e11135 e21136) (let ((ids1137 id1133)) (if (not (valid-bound-ids?139 ids1137)) (syntax-violation (quote letrec) "duplicate bound variable" e1119) (let ((labels1139 (gen-labels120 ids1137)) (new-vars1140 (map gen-var162 ids1137))) (let ((w1141 (make-binding-wrap131 ids1137 labels1139 w1121)) (r1142 (extend-var-env109 labels1139 new-vars1140 r1120))) (build-letrec96 s1122 (map syntax->datum ids1137) new-vars1140 (map (lambda (x1143) (chi150 x1143 r1142 w1141 mod1123)) val1134) (chi-body154 (cons e11135 e21136) (source-wrap143 e1119 w1141 s1122 mod1123) r1142 w1141 mod1123))))))) tmp1125) ((lambda (_1146) (syntax-violation (quote letrec) "bad letrec" (source-wrap143 e1119 w1121 s1122 mod1123))) tmp1124))) ($sc-dispatch tmp1124 (quote (any #(each (any any)) any . each-any))))) e1119))) (global-extend112 (quote core) (quote set!) (lambda (e1147 r1148 w1149 s1150 mod1151) ((lambda (tmp1152) ((lambda (tmp1153) (if (if tmp1153 (apply (lambda (_1154 id1155 val1156) (id?114 id1155)) tmp1153) #f) (apply (lambda (_1157 id1158 val1159) (let ((val1160 (chi150 val1159 r1148 w1149 mod1151)) (n1161 (id-var-name136 id1158 w1149))) (let ((b1162 (lookup111 n1161 r1148 mod1151))) (let ((atom-key1163 (binding-type106 b1162))) (if (memv atom-key1163 (quote (lexical))) (build-lexical-assignment84 s1150 (syntax->datum id1158) (binding-value107 b1162) val1160) (if (memv atom-key1163 (quote (global))) (build-global-assignment87 s1150 n1161 val1160 mod1151) (if (memv atom-key1163 (quote (displaced-lexical))) (syntax-violation (quote set!) "identifier out of context" (wrap142 id1158 w1149 mod1151)) (syntax-violation (quote set!) "bad set!" (source-wrap143 e1147 w1149 s1150 mod1151))))))))) tmp1153) ((lambda (tmp1164) (if tmp1164 (apply (lambda (_1165 head1166 tail1167 val1168) (call-with-values (lambda () (syntax-type148 head1166 r1148 (quote (())) #f #f mod1151)) (lambda (type1169 value1170 ee1171 ww1172 ss1173 modmod1174) (if (memv type1169 (quote (module-ref))) (let ((val1175 (chi150 val1168 r1148 w1149 mod1151))) (call-with-values (lambda () (value1170 (cons head1166 tail1167))) (lambda (id1177 mod1178) (build-global-assignment87 s1150 id1177 val1175 mod1178)))) (build-application81 s1150 (chi150 (list (quote #(syntax-object setter ((top) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type value ee ww ss modmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage #(_ head tail val) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(e r w s mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) head1166) r1148 w1149 mod1151) (map (lambda (e1179) (chi150 e1179 r1148 w1149 mod1151)) (append tail1167 (list val1168)))))))) tmp1164) ((lambda (_1181) (syntax-violation (quote set!) "bad set!" (source-wrap143 e1147 w1149 s1150 mod1151))) tmp1152))) ($sc-dispatch tmp1152 (quote (any (any . each-any) any)))))) ($sc-dispatch tmp1152 (quote (any any any))))) e1147))) (global-extend112 (quote module-ref) (quote @) (lambda (e1182) ((lambda (tmp1183) ((lambda (tmp1184) (if (if tmp1184 (apply (lambda (_1185 mod1186 id1187) (if (and-map id?114 mod1186) (id?114 id1187) #f)) tmp1184) #f) (apply (lambda (_1189 mod1190 id1191) (values (syntax->datum id1191) (syntax->datum (cons (quote #(syntax-object public ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod1190)))) tmp1184) (syntax-violation #f "source expression failed to match any pattern" tmp1183))) ($sc-dispatch tmp1183 (quote (any each-any any))))) e1182))) (global-extend112 (quote module-ref) (quote @@) (lambda (e1193) ((lambda (tmp1194) ((lambda (tmp1195) (if (if tmp1195 (apply (lambda (_1196 mod1197 id1198) (if (and-map id?114 mod1197) (id?114 id1198) #f)) tmp1195) #f) (apply (lambda (_1200 mod1201 id1202) (values (syntax->datum id1202) (syntax->datum (cons (quote #(syntax-object private ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod1201)))) tmp1195) (syntax-violation #f "source expression failed to match any pattern" tmp1194))) ($sc-dispatch tmp1194 (quote (any each-any any))))) e1193))) (global-extend112 (quote core) (quote if) (lambda (e1204 r1205 w1206 s1207 mod1208) ((lambda (tmp1209) ((lambda (tmp1210) (if tmp1210 (apply (lambda (_1211 test1212 then1213) (build-conditional82 s1207 (chi150 test1212 r1205 w1206 mod1208) (chi150 then1213 r1205 w1206 mod1208) (build-void80 #f))) tmp1210) ((lambda (tmp1214) (if tmp1214 (apply (lambda (_1215 test1216 then1217 else1218) (build-conditional82 s1207 (chi150 test1216 r1205 w1206 mod1208) (chi150 then1217 r1205 w1206 mod1208) (chi150 else1218 r1205 w1206 mod1208))) tmp1214) (syntax-violation #f "source expression failed to match any pattern" tmp1209))) ($sc-dispatch tmp1209 (quote (any any any any)))))) ($sc-dispatch tmp1209 (quote (any any any))))) e1204))) (global-extend112 (quote begin) (quote begin) (quote ())) (global-extend112 (quote define) (quote define) (quote ())) (global-extend112 (quote define-syntax) (quote define-syntax) (quote ())) (global-extend112 (quote eval-when) (quote eval-when) (quote ())) (global-extend112 (quote core) (quote syntax-case) (letrec ((gen-syntax-case1222 (lambda (x1223 keys1224 clauses1225 r1226 mod1227) (if (null? clauses1225) (build-application81 #f (build-primref91 #f (quote syntax-violation)) (list (build-data92 #f #f) (build-data92 #f "source expression failed to match any pattern") x1223)) ((lambda (tmp1228) ((lambda (tmp1229) (if tmp1229 (apply (lambda (pat1230 exp1231) (if (if (id?114 pat1230) (and-map (lambda (x1232) (not (free-id=?137 pat1230 x1232))) (cons (quote #(syntax-object ... ((top) #(ribcage #(pat exp) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x keys clauses r mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (gen-syntax-case gen-clause build-dispatch-call convert-pattern) ((top) (top) (top) (top)) ("i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition maybe-name-value! build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application build-void get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) keys1224)) #f) (let ((labels1233 (list (gen-label119))) (var1234 (gen-var162 pat1230))) (build-application81 #f (build-lambda90 #f (list (syntax->datum pat1230)) (list var1234) #f (chi150 exp1231 (extend-env108 labels1233 (list (cons (quote syntax) (cons var1234 0))) r1226) (make-binding-wrap131 (list pat1230) labels1233 (quote (()))) mod1227)) (list x1223))) (gen-clause1221 x1223 keys1224 (cdr clauses1225) r1226 pat1230 #t exp1231 mod1227))) tmp1229) ((lambda (tmp1235) (if tmp1235 (apply (lambda (pat1236 fender1237 exp1238) (gen-clause1221 x1223 keys1224 (cdr clauses1225) r1226 pat1236 fender1237 exp1238 mod1227)) tmp1235) ((lambda (_1239) (syntax-violation (quote syntax-case) "invalid clause" (car clauses1225))) tmp1228))) ($sc-dispatch tmp1228 (quote (any any any)))))) ($sc-dispatch tmp1228 (quote (any any))))) (car clauses1225))))) (gen-clause1221 (lambda (x1240 keys1241 clauses1242 r1243 pat1244 fender1245 exp1246 mod1247) (call-with-values (lambda () (convert-pattern1219 pat1244 keys1241)) (lambda (p1248 pvars1249) (if (not (distinct-bound-ids?140 (map car pvars1249))) (syntax-violation (quote syntax-case) "duplicate pattern variable" pat1244) (if (not (and-map (lambda (x1250) (not (ellipsis?159 (car x1250)))) pvars1249)) (syntax-violation (quote syntax-case) "misplaced ellipsis" pat1244) (let ((y1251 (gen-var162 (quote tmp)))) (build-application81 #f (build-lambda90 #f (list (quote tmp)) (list y1251) #f (let ((y1252 (build-lexical-reference83 (quote value) #f (quote tmp) y1251))) (build-conditional82 #f ((lambda (tmp1253) ((lambda (tmp1254) (if tmp1254 (apply (lambda () y1252) tmp1254) ((lambda (_1255) (build-conditional82 #f y1252 (build-dispatch-call1220 pvars1249 fender1245 y1252 r1243 mod1247) (build-data92 #f #f))) tmp1253))) ($sc-dispatch tmp1253 (quote #(atom #t))))) fender1245) (build-dispatch-call1220 pvars1249 exp1246 y1252 r1243 mod1247) (gen-syntax-case1222 x1240 keys1241 clauses1242 r1243 mod1247)))) (list (if (eq? p1248 (quote any)) (build-application81 #f (build-primref91 #f (quote list)) (list x1240)) (build-application81 #f (build-primref91 #f (quote $sc-dispatch)) (list x1240 (build-data92 #f p1248))))))))))))) (build-dispatch-call1220 (lambda (pvars1256 exp1257 y1258 r1259 mod1260) (let ((ids1261 (map car pvars1256)) (levels1262 (map cdr pvars1256))) (let ((labels1263 (gen-labels120 ids1261)) (new-vars1264 (map gen-var162 ids1261))) (build-application81 #f (build-primref91 #f (quote apply)) (list (build-lambda90 #f (map syntax->datum ids1261) new-vars1264 #f (chi150 exp1257 (extend-env108 labels1263 (map (lambda (var1265 level1266) (cons (quote syntax) (cons var1265 level1266))) new-vars1264 (map cdr pvars1256)) r1259) (make-binding-wrap131 ids1261 labels1263 (quote (()))) mod1260)) y1258)))))) (convert-pattern1219 (lambda (pattern1267 keys1268) (letrec ((cvt1269 (lambda (p1270 n1271 ids1272) (if (id?114 p1270) (if (bound-id-member?141 p1270 keys1268) (values (vector (quote free-id) p1270) ids1272) (values (quote any) (cons (cons p1270 n1271) ids1272))) ((lambda (tmp1273) ((lambda (tmp1274) (if (if tmp1274 (apply (lambda (x1275 dots1276) (ellipsis?159 dots1276)) tmp1274) #f) (apply (lambda (x1277 dots1278) (call-with-values (lambda () (cvt1269 x1277 (fx+72 n1271 1) ids1272)) (lambda (p1279 ids1280) (values (if (eq? p1279 (quote any)) (quote each-any) (vector (quote each) p1279)) ids1280)))) tmp1274) ((lambda (tmp1281) (if tmp1281 (apply (lambda (x1282 y1283) (call-with-values (lambda () (cvt1269 y1283 n1271 ids1272)) (lambda (y1284 ids1285) (call-with-values (lambda () (cvt1269 x1282 n1271 ids1285)) (lambda (x1286 ids1287) (values (cons x1286 y1284) ids1287)))))) tmp1281) ((lambda (tmp1288) (if tmp1288 (apply (lambda () (values (quote ()) ids1272)) tmp1288) ((lambda (tmp1289) (if tmp1289 (apply (lambda (x1290) (call-with-values (lambda () (cvt1269 x1290 n1271 ids1272)) (lambda (p1292 ids1293) (values (vector (quote vector) p1292) ids1293)))) tmp1289) ((lambda (x1294) (values (vector (quote atom) (strip161 p1270 (quote (())))) ids1272)) tmp1273))) ($sc-dispatch tmp1273 (quote #(vector each-any)))))) ($sc-dispatch tmp1273 (quote ()))))) ($sc-dispatch tmp1273 (quote (any . any)))))) ($sc-dispatch tmp1273 (quote (any any))))) p1270))))) (cvt1269 pattern1267 0 (quote ())))))) (lambda (e1295 r1296 w1297 s1298 mod1299) (let ((e1300 (source-wrap143 e1295 w1297 s1298 mod1299))) ((lambda (tmp1301) ((lambda (tmp1302) (if tmp1302 (apply (lambda (_1303 val1304 key1305 m1306) (if (and-map (lambda (x1307) (if (id?114 x1307) (not (ellipsis?159 x1307)) #f)) key1305) (let ((x1309 (gen-var162 (quote tmp)))) (build-application81 s1298 (build-lambda90 #f (list (quote tmp)) (list x1309) #f (gen-syntax-case1222 (build-lexical-reference83 (quote value) #f (quote tmp) x1309) key1305 m1306 r1296 mod1299)) (list (chi150 val1304 r1296 (quote (())) mod1299)))) (syntax-violation (quote syntax-case) "invalid literals list" e1300))) tmp1302) (syntax-violation #f "source expression failed to match any pattern" tmp1301))) ($sc-dispatch tmp1301 (quote (any any each-any . each-any))))) e1300))))) (set! sc-expand (lambda (x1313 . rest1312) (if (if (pair? x1313) (equal? (car x1313) noexpand70) #f) (cadr x1313) (let ((m1314 (if (null? rest1312) (quote e) (car rest1312))) (esew1315 (if (let ((t1316 (null? rest1312))) (if t1316 t1316 (null? (cdr rest1312)))) (quote (eval)) (cadr rest1312)))) (with-fluid* *mode*71 m1314 (lambda () (chi-top149 x1313 (quote ()) (quote ((top))) m1314 esew1315 (cons (quote hygiene) (module-name (current-module)))))))))) (set! identifier? (lambda (x1317) (nonsymbol-id?113 x1317))) (set! datum->syntax (lambda (id1318 datum1319) (make-syntax-object97 datum1319 (syntax-object-wrap100 id1318) #f))) (set! syntax->datum (lambda (x1320) (strip161 x1320 (quote (()))))) (set! generate-temporaries (lambda (ls1321) (begin (let ((x1322 ls1321)) (if (not (list? x1322)) (syntax-violation (quote generate-temporaries) "invalid argument" x1322))) (map (lambda (x1323) (wrap142 (gensym) (quote ((top))) #f)) ls1321)))) (set! free-identifier=? (lambda (x1324 y1325) (begin (let ((x1326 x1324)) (if (not (nonsymbol-id?113 x1326)) (syntax-violation (quote free-identifier=?) "invalid argument" x1326))) (let ((x1327 y1325)) (if (not (nonsymbol-id?113 x1327)) (syntax-violation (quote free-identifier=?) "invalid argument" x1327))) (free-id=?137 x1324 y1325)))) (set! bound-identifier=? (lambda (x1328 y1329) (begin (let ((x1330 x1328)) (if (not (nonsymbol-id?113 x1330)) (syntax-violation (quote bound-identifier=?) "invalid argument" x1330))) (let ((x1331 y1329)) (if (not (nonsymbol-id?113 x1331)) (syntax-violation (quote bound-identifier=?) "invalid argument" x1331))) (bound-id=?138 x1328 y1329)))) (set! syntax-violation (lambda (who1335 message1334 form1333 . subform1332) (begin (let ((x1336 who1335)) (if (not ((lambda (x1337) (let ((t1338 (not x1337))) (if t1338 t1338 (let ((t1339 (string? x1337))) (if t1339 t1339 (symbol? x1337)))))) x1336)) (syntax-violation (quote syntax-violation) "invalid argument" x1336))) (let ((x1340 message1334)) (if (not (string? x1340)) (syntax-violation (quote syntax-violation) "invalid argument" x1340))) (scm-error (quote syntax-error) (quote sc-expand) (string-append (if who1335 "~a: " "") "~a " (if (null? subform1332) "in ~a" "in subform `~s' of `~s'")) (let ((tail1341 (cons message1334 (map (lambda (x1342) (strip161 x1342 (quote (())))) (append subform1332 (list form1333)))))) (if who1335 (cons who1335 tail1341) tail1341)) #f)))) (letrec ((match1347 (lambda (e1348 p1349 w1350 r1351 mod1352) (if (not r1351) #f (if (eq? p1349 (quote any)) (cons (wrap142 e1348 w1350 mod1352) r1351) (if (syntax-object?98 e1348) (match*1346 (let ((e1353 (syntax-object-expression99 e1348))) (if (annotation? e1353) (annotation-expression e1353) e1353)) p1349 (join-wraps133 w1350 (syntax-object-wrap100 e1348)) r1351 (syntax-object-module101 e1348)) (match*1346 (let ((e1354 e1348)) (if (annotation? e1354) (annotation-expression e1354) e1354)) p1349 w1350 r1351 mod1352)))))) (match*1346 (lambda (e1355 p1356 w1357 r1358 mod1359) (if (null? p1356) (if (null? e1355) r1358 #f) (if (pair? p1356) (if (pair? e1355) (match1347 (car e1355) (car p1356) w1357 (match1347 (cdr e1355) (cdr p1356) w1357 r1358 mod1359) mod1359) #f) (if (eq? p1356 (quote each-any)) (let ((l1360 (match-each-any1344 e1355 w1357 mod1359))) (if l1360 (cons l1360 r1358) #f)) (let ((atom-key1361 (vector-ref p1356 0))) (if (memv atom-key1361 (quote (each))) (if (null? e1355) (match-empty1345 (vector-ref p1356 1) r1358) (let ((l1362 (match-each1343 e1355 (vector-ref p1356 1) w1357 mod1359))) (if l1362 (letrec ((collect1363 (lambda (l1364) (if (null? (car l1364)) r1358 (cons (map car l1364) (collect1363 (map cdr l1364))))))) (collect1363 l1362)) #f))) (if (memv atom-key1361 (quote (free-id))) (if (id?114 e1355) (if (free-id=?137 (wrap142 e1355 w1357 mod1359) (vector-ref p1356 1)) r1358 #f) #f) (if (memv atom-key1361 (quote (atom))) (if (equal? (vector-ref p1356 1) (strip161 e1355 w1357)) r1358 #f) (if (memv atom-key1361 (quote (vector))) (if (vector? e1355) (match1347 (vector->list e1355) (vector-ref p1356 1) w1357 r1358 mod1359) #f))))))))))) (match-empty1345 (lambda (p1365 r1366) (if (null? p1365) r1366 (if (eq? p1365 (quote any)) (cons (quote ()) r1366) (if (pair? p1365) (match-empty1345 (car p1365) (match-empty1345 (cdr p1365) r1366)) (if (eq? p1365 (quote each-any)) (cons (quote ()) r1366) (let ((atom-key1367 (vector-ref p1365 0))) (if (memv atom-key1367 (quote (each))) (match-empty1345 (vector-ref p1365 1) r1366) (if (memv atom-key1367 (quote (free-id atom))) r1366 (if (memv atom-key1367 (quote (vector))) (match-empty1345 (vector-ref p1365 1) r1366))))))))))) (match-each-any1344 (lambda (e1368 w1369 mod1370) (if (annotation? e1368) (match-each-any1344 (annotation-expression e1368) w1369 mod1370) (if (pair? e1368) (let ((l1371 (match-each-any1344 (cdr e1368) w1369 mod1370))) (if l1371 (cons (wrap142 (car e1368) w1369 mod1370) l1371) #f)) (if (null? e1368) (quote ()) (if (syntax-object?98 e1368) (match-each-any1344 (syntax-object-expression99 e1368) (join-wraps133 w1369 (syntax-object-wrap100 e1368)) mod1370) #f)))))) (match-each1343 (lambda (e1372 p1373 w1374 mod1375) (if (annotation? e1372) (match-each1343 (annotation-expression e1372) p1373 w1374 mod1375) (if (pair? e1372) (let ((first1376 (match1347 (car e1372) p1373 w1374 (quote ()) mod1375))) (if first1376 (let ((rest1377 (match-each1343 (cdr e1372) p1373 w1374 mod1375))) (if rest1377 (cons first1376 rest1377) #f)) #f)) (if (null? e1372) (quote ()) (if (syntax-object?98 e1372) (match-each1343 (syntax-object-expression99 e1372) p1373 (join-wraps133 w1374 (syntax-object-wrap100 e1372)) (syntax-object-module101 e1372)) #f))))))) (set! $sc-dispatch (lambda (e1378 p1379) (if (eq? p1379 (quote any)) (list e1378) (if (syntax-object?98 e1378) (match*1346 (let ((e1380 (syntax-object-expression99 e1378))) (if (annotation? e1380) (annotation-expression e1380) e1380)) p1379 (syntax-object-wrap100 e1378) (quote ()) (syntax-object-module101 e1378)) (match*1346 (let ((e1381 e1378)) (if (annotation? e1381) (annotation-expression e1381) e1381)) p1379 (quote (())) (quote ()) #f)))))))))
(define with-syntax (make-syncase-macro (quote macro) (lambda (x1382) ((lambda (tmp1383) ((lambda (tmp1384) (if tmp1384 (apply (lambda (_1385 e11386 e21387) (cons (quote #(syntax-object begin ((top) #(ribcage #(_ e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11386 e21387))) tmp1384) ((lambda (tmp1389) (if tmp1389 (apply (lambda (_1390 out1391 in1392 e11393 e21394) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in1392 (quote ()) (list out1391 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11393 e21394))))) tmp1389) ((lambda (tmp1396) (if tmp1396 (apply (lambda (_1397 out1398 in1399 e11400 e21401) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object list ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in1399) (quote ()) (list out1398 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11400 e21401))))) tmp1396) (syntax-violation #f "source expression failed to match any pattern" tmp1383))) ($sc-dispatch tmp1383 (quote (any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp1383 (quote (any ((any any)) any . each-any)))))) ($sc-dispatch tmp1383 (quote (any () any . each-any))))) x1382))))
(define syntax-rules (make-syncase-macro (quote macro) (lambda (x1405) ((lambda (tmp1406) ((lambda (tmp1407) (if tmp1407 (apply (lambda (_1408 k1409 keyword1410 pattern1411 template1412) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (cons (quote #(syntax-object syntax-case ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons k1409 (map (lambda (tmp1415 tmp1414) (list (cons (quote #(syntax-object dummy ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp1414) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp1415))) template1412 pattern1411)))))) tmp1407) (syntax-violation #f "source expression failed to match any pattern" tmp1406))) ($sc-dispatch tmp1406 (quote (any each-any . #(each ((any . any) any))))))) x1405))))
(define let* (make-extended-syncase-macro (module-ref (current-module) (quote let*)) (quote macro) (lambda (x1416) ((lambda (tmp1417) ((lambda (tmp1418) (if (if tmp1418 (apply (lambda (let*1419 x1420 v1421 e11422 e21423) (and-map identifier? x1420)) tmp1418) #f) (apply (lambda (let*1425 x1426 v1427 e11428 e21429) (letrec ((f1430 (lambda (bindings1431) (if (null? bindings1431) (cons (quote #(syntax-object let ((top) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote ()) (cons e11428 e21429))) ((lambda (tmp1435) ((lambda (tmp1436) (if tmp1436 (apply (lambda (body1437 binding1438) (list (quote #(syntax-object let ((top) #(ribcage #(body binding) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list binding1438) body1437)) tmp1436) (syntax-violation #f "source expression failed to match any pattern" tmp1435))) ($sc-dispatch tmp1435 (quote (any any))))) (list (f1430 (cdr bindings1431)) (car bindings1431))))))) (f1430 (map list x1426 v1427)))) tmp1418) (syntax-violation #f "source expression failed to match any pattern" tmp1417))) ($sc-dispatch tmp1417 (quote (any #(each (any any)) any . each-any))))) x1416))))
(define do (make-extended-syncase-macro (module-ref (current-module) (quote do)) (quote macro) (lambda (orig-x1439) ((lambda (tmp1440) ((lambda (tmp1441) (if tmp1441 (apply (lambda (_1442 var1443 init1444 step1445 e01446 e11447 c1448) ((lambda (tmp1449) ((lambda (tmp1450) (if tmp1450 (apply (lambda (step1451) ((lambda (tmp1452) ((lambda (tmp1453) (if tmp1453 (apply (lambda () (list (quote #(syntax-object let ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var1443 init1444) (list (quote #(syntax-object if ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object not ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e01446) (cons (quote #(syntax-object begin ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c1448 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step1451))))))) tmp1453) ((lambda (tmp1458) (if tmp1458 (apply (lambda (e11459 e21460) (list (quote #(syntax-object let ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var1443 init1444) (list (quote #(syntax-object if ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e01446 (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (cons e11459 e21460)) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c1448 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step1451))))))) tmp1458) (syntax-violation #f "source expression failed to match any pattern" tmp1452))) ($sc-dispatch tmp1452 (quote (any . each-any)))))) ($sc-dispatch tmp1452 (quote ())))) e11447)) tmp1450) (syntax-violation #f "source expression failed to match any pattern" tmp1449))) ($sc-dispatch tmp1449 (quote each-any)))) (map (lambda (v1467 s1468) ((lambda (tmp1469) ((lambda (tmp1470) (if tmp1470 (apply (lambda () v1467) tmp1470) ((lambda (tmp1471) (if tmp1471 (apply (lambda (e1472) e1472) tmp1471) ((lambda (_1473) (syntax-violation (quote do) "bad step expression" orig-x1439 s1468)) tmp1469))) ($sc-dispatch tmp1469 (quote (any)))))) ($sc-dispatch tmp1469 (quote ())))) s1468)) var1443 step1445))) tmp1441) (syntax-violation #f "source expression failed to match any pattern" tmp1440))) ($sc-dispatch tmp1440 (quote (any #(each (any any . any)) (any . each-any) . each-any))))) orig-x1439))))
(define quasiquote (make-extended-syncase-macro (module-ref (current-module) (quote quasiquote)) (quote macro) (letrec ((quasicons1476 (lambda (x1480 y1481) ((lambda (tmp1482) ((lambda (tmp1483) (if tmp1483 (apply (lambda (x1484 y1485) ((lambda (tmp1486) ((lambda (tmp1487) (if tmp1487 (apply (lambda (dy1488) ((lambda (tmp1489) ((lambda (tmp1490) (if tmp1490 (apply (lambda (dx1491) (list (quote #(syntax-object quote ((top) #(ribcage #(dx) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons dx1491 dy1488))) tmp1490) ((lambda (_1492) (if (null? dy1488) (list (quote #(syntax-object list ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1484) (list (quote #(syntax-object cons ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1484 y1485))) tmp1489))) ($sc-dispatch tmp1489 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) x1484)) tmp1487) ((lambda (tmp1493) (if tmp1493 (apply (lambda (stuff1494) (cons (quote #(syntax-object list ((top) #(ribcage #(stuff) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons x1484 stuff1494))) tmp1493) ((lambda (else1495) (list (quote #(syntax-object cons ((top) #(ribcage #(else) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1484 y1485)) tmp1486))) ($sc-dispatch tmp1486 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . any)))))) ($sc-dispatch tmp1486 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) y1485)) tmp1483) (syntax-violation #f "source expression failed to match any pattern" tmp1482))) ($sc-dispatch tmp1482 (quote (any any))))) (list x1480 y1481)))) (quasiappend1477 (lambda (x1496 y1497) ((lambda (tmp1498) ((lambda (tmp1499) (if tmp1499 (apply (lambda (x1500 y1501) ((lambda (tmp1502) ((lambda (tmp1503) (if tmp1503 (apply (lambda () x1500) tmp1503) ((lambda (_1504) (list (quote #(syntax-object append ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1500 y1501)) tmp1502))) ($sc-dispatch tmp1502 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) ()))))) y1501)) tmp1499) (syntax-violation #f "source expression failed to match any pattern" tmp1498))) ($sc-dispatch tmp1498 (quote (any any))))) (list x1496 y1497)))) (quasivector1478 (lambda (x1505) ((lambda (tmp1506) ((lambda (x1507) ((lambda (tmp1508) ((lambda (tmp1509) (if tmp1509 (apply (lambda (x1510) (list (quote #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (list->vector x1510))) tmp1509) ((lambda (tmp1512) (if tmp1512 (apply (lambda (x1513) (cons (quote #(syntax-object vector ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1513)) tmp1512) ((lambda (_1515) (list (quote #(syntax-object list->vector ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1507)) tmp1508))) ($sc-dispatch tmp1508 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . each-any)))))) ($sc-dispatch tmp1508 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) each-any))))) x1507)) tmp1506)) x1505))) (quasi1479 (lambda (p1516 lev1517) ((lambda (tmp1518) ((lambda (tmp1519) (if tmp1519 (apply (lambda (p1520) (if (= lev1517 0) p1520 (quasicons1476 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1479 (list p1520) (- lev1517 1))))) tmp1519) ((lambda (tmp1521) (if (if tmp1521 (apply (lambda (args1522) (= lev1517 0)) tmp1521) #f) (apply (lambda (args1523) (syntax-violation (quote unquote) "unquote takes exactly one argument" p1516 (cons (quote #(syntax-object unquote ((top) #(ribcage #(args) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) args1523))) tmp1521) ((lambda (tmp1524) (if tmp1524 (apply (lambda (p1525 q1526) (if (= lev1517 0) (quasiappend1477 p1525 (quasi1479 q1526 lev1517)) (quasicons1476 (quasicons1476 (quote (#(syntax-object quote ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote-splicing ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1479 (list p1525) (- lev1517 1))) (quasi1479 q1526 lev1517)))) tmp1524) ((lambda (tmp1527) (if (if tmp1527 (apply (lambda (args1528 q1529) (= lev1517 0)) tmp1527) #f) (apply (lambda (args1530 q1531) (syntax-violation (quote unquote-splicing) "unquote-splicing takes exactly one argument" p1516 (cons (quote #(syntax-object unquote-splicing ((top) #(ribcage #(args q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) args1530))) tmp1527) ((lambda (tmp1532) (if tmp1532 (apply (lambda (p1533) (quasicons1476 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object quasiquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1479 (list p1533) (+ lev1517 1)))) tmp1532) ((lambda (tmp1534) (if tmp1534 (apply (lambda (p1535 q1536) (quasicons1476 (quasi1479 p1535 lev1517) (quasi1479 q1536 lev1517))) tmp1534) ((lambda (tmp1537) (if tmp1537 (apply (lambda (x1538) (quasivector1478 (quasi1479 x1538 lev1517))) tmp1537) ((lambda (p1540) (list (quote #(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) p1540)) tmp1518))) ($sc-dispatch tmp1518 (quote #(vector each-any)))))) ($sc-dispatch tmp1518 (quote (any . any)))))) ($sc-dispatch tmp1518 (quote (#(free-id #(syntax-object quasiquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any)))))) ($sc-dispatch tmp1518 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . any) . any)))))) ($sc-dispatch tmp1518 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any) . any)))))) ($sc-dispatch tmp1518 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . any)))))) ($sc-dispatch tmp1518 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) p1516)))) (lambda (x1541) ((lambda (tmp1542) ((lambda (tmp1543) (if tmp1543 (apply (lambda (_1544 e1545) (quasi1479 e1545 0)) tmp1543) (syntax-violation #f "source expression failed to match any pattern" tmp1542))) ($sc-dispatch tmp1542 (quote (any any))))) x1541)))))
(define include (make-syncase-macro (quote macro) (lambda (x1546) (letrec ((read-file1547 (lambda (fn1548 k1549) (let ((p1550 (open-input-file fn1548))) (letrec ((f1551 (lambda (x1552) (if (eof-object? x1552) (begin (close-input-port p1550) (quote ())) (cons (datum->syntax k1549 x1552) (f1551 (read p1550))))))) (f1551 (read p1550))))))) ((lambda (tmp1553) ((lambda (tmp1554) (if tmp1554 (apply (lambda (k1555 filename1556) (let ((fn1557 (syntax->datum filename1556))) ((lambda (tmp1558) ((lambda (tmp1559) (if tmp1559 (apply (lambda (exp1560) (cons (quote #(syntax-object begin ((top) #(ribcage #(exp) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(fn) #((top)) #("i")) #(ribcage #(k filename) #((top) (top)) #("i" "i")) #(ribcage (read-file) ((top)) ("i")) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) exp1560)) tmp1559) (syntax-violation #f "source expression failed to match any pattern" tmp1558))) ($sc-dispatch tmp1558 (quote each-any)))) (read-file1547 fn1557 k1555)))) tmp1554) (syntax-violation #f "source expression failed to match any pattern" tmp1553))) ($sc-dispatch tmp1553 (quote (any any))))) x1546)))))
(define unquote (make-syncase-macro (quote macro) (lambda (x1562) ((lambda (tmp1563) ((lambda (tmp1564) (if tmp1564 (apply (lambda (_1565 e1566) (syntax-violation (quote unquote) "expression not valid outside of quasiquote" x1562)) tmp1564) (syntax-violation #f "source expression failed to match any pattern" tmp1563))) ($sc-dispatch tmp1563 (quote (any any))))) x1562))))
(define unquote-splicing (make-syncase-macro (quote macro) (lambda (x1567) ((lambda (tmp1568) ((lambda (tmp1569) (if tmp1569 (apply (lambda (_1570 e1571) (syntax-violation (quote unquote-splicing) "expression not valid outside of quasiquote" x1567)) tmp1569) (syntax-violation #f "source expression failed to match any pattern" tmp1568))) ($sc-dispatch tmp1568 (quote (any any))))) x1567))))
(define case (make-extended-syncase-macro (module-ref (current-module) (quote case)) (quote macro) (lambda (x1572) ((lambda (tmp1573) ((lambda (tmp1574) (if tmp1574 (apply (lambda (_1575 e1576 m11577 m21578) ((lambda (tmp1579) ((lambda (body1580) (list (quote #(syntax-object let ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (list (quote #(syntax-object t ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e1576)) body1580)) tmp1579)) (letrec ((f1581 (lambda (clause1582 clauses1583) (if (null? clauses1583) ((lambda (tmp1585) ((lambda (tmp1586) (if tmp1586 (apply (lambda (e11587 e21588) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11587 e21588))) tmp1586) ((lambda (tmp1590) (if tmp1590 (apply (lambda (k1591 e11592 e21593) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k1591)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11592 e21593)))) tmp1590) ((lambda (_1596) (syntax-violation (quote case) "bad clause" x1572 clause1582)) tmp1585))) ($sc-dispatch tmp1585 (quote (each-any any . each-any)))))) ($sc-dispatch tmp1585 (quote (#(free-id #(syntax-object else ((top) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) any . each-any))))) clause1582) ((lambda (tmp1597) ((lambda (rest1598) ((lambda (tmp1599) ((lambda (tmp1600) (if tmp1600 (apply (lambda (k1601 e11602 e21603) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k1601)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11602 e21603)) rest1598)) tmp1600) ((lambda (_1606) (syntax-violation (quote case) "bad clause" x1572 clause1582)) tmp1599))) ($sc-dispatch tmp1599 (quote (each-any any . each-any))))) clause1582)) tmp1597)) (f1581 (car clauses1583) (cdr clauses1583))))))) (f1581 m11577 m21578)))) tmp1574) (syntax-violation #f "source expression failed to match any pattern" tmp1573))) ($sc-dispatch tmp1573 (quote (any any any . each-any))))) x1572))))
(define identifier-syntax (make-syncase-macro (quote macro) (lambda (x1607) ((lambda (tmp1608) ((lambda (tmp1609) (if tmp1609 (apply (lambda (_1610 e1611) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote ()) (list (quote #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object identifier? ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) (#(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e1611)) (list (cons _1610 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e1611 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))))))))) tmp1609) (syntax-violation #f "source expression failed to match any pattern" tmp1608))) ($sc-dispatch tmp1608 (quote (any any))))) x1607))))
