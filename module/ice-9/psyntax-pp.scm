(eval-when (compile) (set-current-module (resolve-module (quote (guile)))))
(if #f #f)
(letrec ((and-map*17 (lambda (f57 first56 . rest55) (or (null? first56) (if (null? rest55) (let andmap58 ((first59 first56)) (let ((x60 (car first59)) (first61 (cdr first59))) (if (null? first61) (f57 x60) (and (f57 x60) (andmap58 first61))))) (let andmap62 ((first63 first56) (rest64 rest55)) (let ((x65 (car first63)) (xr66 (map car rest64)) (first67 (cdr first63)) (rest68 (map cdr rest64))) (if (null? first67) (apply f57 (cons x65 xr66)) (and (apply f57 (cons x65 xr66)) (andmap62 first67 rest68)))))))))) (letrec ((lambda-var-list153 (lambda (vars343) (let lvl344 ((vars345 vars343) (ls346 (quote ())) (w347 (quote (())))) (cond ((pair? vars345) (lvl344 (cdr vars345) (cons (wrap132 (car vars345) w347 #f) ls346) w347)) ((id?104 vars345) (cons (wrap132 vars345 w347 #f) ls346)) ((null? vars345) ls346) ((syntax-object?88 vars345) (lvl344 (syntax-object-expression89 vars345) ls346 (join-wraps123 w347 (syntax-object-wrap90 vars345)))) ((annotation? vars345) (lvl344 (annotation-expression vars345) ls346 w347)) (else (cons vars345 ls346)))))) (gen-var152 (lambda (id348) (let ((id349 (if (syntax-object?88 id348) (syntax-object-expression89 id348) id348))) (if (annotation? id349) (build-annotated79 (annotation-source id349) (gensym (symbol->string (annotation-expression id349)))) (build-annotated79 #f (gensym (symbol->string id349))))))) (strip151 (lambda (x350 w351) (if (memq (quote top) (wrap-marks107 w351)) (if (or (annotation? x350) (and (pair? x350) (annotation? (car x350)))) (strip-annotation150 x350 #f) x350) (let f352 ((x353 x350)) (cond ((syntax-object?88 x353) (strip151 (syntax-object-expression89 x353) (syntax-object-wrap90 x353))) ((pair? x353) (let ((a354 (f352 (car x353))) (d355 (f352 (cdr x353)))) (if (and (eq? a354 (car x353)) (eq? d355 (cdr x353))) x353 (cons a354 d355)))) ((vector? x353) (let ((old356 (vector->list x353))) (let ((new357 (map f352 old356))) (if (and-map*17 eq? old356 new357) x353 (list->vector new357))))) (else x353)))))) (strip-annotation150 (lambda (x358 parent359) (cond ((pair? x358) (let ((new360 (cons #f #f))) (begin (if parent359 (set-annotation-stripped! parent359 new360)) (set-car! new360 (strip-annotation150 (car x358) #f)) (set-cdr! new360 (strip-annotation150 (cdr x358) #f)) new360))) ((annotation? x358) (or (annotation-stripped x358) (strip-annotation150 (annotation-expression x358) x358))) ((vector? x358) (let ((new361 (make-vector (vector-length x358)))) (begin (if parent359 (set-annotation-stripped! parent359 new361)) (let loop362 ((i363 (- (vector-length x358) 1))) (unless (fx<74 i363 0) (vector-set! new361 i363 (strip-annotation150 (vector-ref x358 i363) #f)) (loop362 (fx-72 i363 1)))) new361))) (else x358)))) (ellipsis?149 (lambda (x364) (and (nonsymbol-id?103 x364) (free-id=?127 x364 (quote #(syntax-object ... ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))))))) (chi-void148 (lambda () (build-annotated79 #f (cons (build-annotated79 #f (quote if)) (quote (#f #f)))))) (eval-local-transformer147 (lambda (expanded365 mod366) (let ((p367 (local-eval-hook76 expanded365 mod366))) (if (procedure? p367) p367 (syntax-violation #f "nonprocedure transformer" p367))))) (chi-local-syntax146 (lambda (rec?368 e369 r370 w371 s372 mod373 k374) ((lambda (tmp375) ((lambda (tmp376) (if tmp376 (apply (lambda (_377 id378 val379 e1380 e2381) (let ((ids382 id378)) (if (not (valid-bound-ids?129 ids382)) (syntax-violation #f "duplicate bound keyword" e369) (let ((labels384 (gen-labels110 ids382))) (let ((new-w385 (make-binding-wrap121 ids382 labels384 w371))) (k374 (cons e1380 e2381) (extend-env98 labels384 (let ((w387 (if rec?368 new-w385 w371)) (trans-r388 (macros-only-env100 r370))) (map (lambda (x389) (cons (quote macro) (eval-local-transformer147 (chi140 x389 trans-r388 w387 mod373) mod373))) val379)) r370) new-w385 s372 mod373)))))) tmp376) ((lambda (_391) (syntax-violation #f "bad local syntax definition" (source-wrap133 e369 w371 s372 mod373))) tmp375))) ($sc-dispatch tmp375 (quote (any #(each (any any)) any . each-any))))) e369))) (chi-lambda-clause145 (lambda (e392 docstring393 c394 r395 w396 mod397 k398) ((lambda (tmp399) ((lambda (tmp400) (if (if tmp400 (apply (lambda (args401 doc402 e1403 e2404) (and (string? (syntax->datum doc402)) (not docstring393))) tmp400) #f) (apply (lambda (args405 doc406 e1407 e2408) (chi-lambda-clause145 e392 doc406 (cons args405 (cons e1407 e2408)) r395 w396 mod397 k398)) tmp400) ((lambda (tmp410) (if tmp410 (apply (lambda (id411 e1412 e2413) (let ((ids414 id411)) (if (not (valid-bound-ids?129 ids414)) (syntax-violation (quote lambda) "invalid parameter list" e392) (let ((labels416 (gen-labels110 ids414)) (new-vars417 (map gen-var152 ids414))) (k398 new-vars417 docstring393 (chi-body144 (cons e1412 e2413) e392 (extend-var-env99 labels416 new-vars417 r395) (make-binding-wrap121 ids414 labels416 w396) mod397)))))) tmp410) ((lambda (tmp419) (if tmp419 (apply (lambda (ids420 e1421 e2422) (let ((old-ids423 (lambda-var-list153 ids420))) (if (not (valid-bound-ids?129 old-ids423)) (syntax-violation (quote lambda) "invalid parameter list" e392) (let ((labels424 (gen-labels110 old-ids423)) (new-vars425 (map gen-var152 old-ids423))) (k398 (let f426 ((ls1427 (cdr new-vars425)) (ls2428 (car new-vars425))) (if (null? ls1427) ls2428 (f426 (cdr ls1427) (cons (car ls1427) ls2428)))) docstring393 (chi-body144 (cons e1421 e2422) e392 (extend-var-env99 labels424 new-vars425 r395) (make-binding-wrap121 old-ids423 labels424 w396) mod397)))))) tmp419) ((lambda (_430) (syntax-violation (quote lambda) "bad lambda" e392)) tmp399))) ($sc-dispatch tmp399 (quote (any any . each-any)))))) ($sc-dispatch tmp399 (quote (each-any any . each-any)))))) ($sc-dispatch tmp399 (quote (any any any . each-any))))) c394))) (chi-body144 (lambda (body431 outer-form432 r433 w434 mod435) (let ((r436 (cons (quote ("placeholder" placeholder)) r433))) (let ((ribcage437 (make-ribcage111 (quote ()) (quote ()) (quote ())))) (let ((w438 (make-wrap106 (wrap-marks107 w434) (cons ribcage437 (wrap-subst108 w434))))) (let parse439 ((body440 (map (lambda (x446) (cons r436 (wrap132 x446 w438 mod435))) body431)) (ids441 (quote ())) (labels442 (quote ())) (vars443 (quote ())) (vals444 (quote ())) (bindings445 (quote ()))) (if (null? body440) (syntax-violation #f "no expressions in body" outer-form432) (let ((e447 (cdar body440)) (er448 (caar body440))) (call-with-values (lambda () (syntax-type138 e447 er448 (quote (())) #f ribcage437 mod435)) (lambda (type449 value450 e451 w452 s453 mod454) (let ((t455 type449)) (if (memv t455 (quote (define-form))) (let ((id456 (wrap132 value450 w452 mod454)) (label457 (gen-label109))) (let ((var458 (gen-var152 id456))) (begin (extend-ribcage!120 ribcage437 id456 label457) (parse439 (cdr body440) (cons id456 ids441) (cons label457 labels442) (cons var458 vars443) (cons (cons er448 (wrap132 e451 w452 mod454)) vals444) (cons (cons (quote lexical) var458) bindings445))))) (if (memv t455 (quote (define-syntax-form))) (let ((id459 (wrap132 value450 w452 mod454)) (label460 (gen-label109))) (begin (extend-ribcage!120 ribcage437 id459 label460) (parse439 (cdr body440) (cons id459 ids441) (cons label460 labels442) vars443 vals444 (cons (cons (quote macro) (cons er448 (wrap132 e451 w452 mod454))) bindings445)))) (if (memv t455 (quote (begin-form))) ((lambda (tmp461) ((lambda (tmp462) (if tmp462 (apply (lambda (_463 e1464) (parse439 (let f465 ((forms466 e1464)) (if (null? forms466) (cdr body440) (cons (cons er448 (wrap132 (car forms466) w452 mod454)) (f465 (cdr forms466))))) ids441 labels442 vars443 vals444 bindings445)) tmp462) (syntax-violation #f "source expression failed to match any pattern" tmp461))) ($sc-dispatch tmp461 (quote (any . each-any))))) e451) (if (memv t455 (quote (local-syntax-form))) (chi-local-syntax146 value450 e451 er448 w452 s453 mod454 (lambda (forms468 er469 w470 s471 mod472) (parse439 (let f473 ((forms474 forms468)) (if (null? forms474) (cdr body440) (cons (cons er469 (wrap132 (car forms474) w470 mod472)) (f473 (cdr forms474))))) ids441 labels442 vars443 vals444 bindings445))) (if (null? ids441) (build-sequence83 #f (map (lambda (x475) (chi140 (cdr x475) (car x475) (quote (())) mod454)) (cons (cons er448 (source-wrap133 e451 w452 s453 mod454)) (cdr body440)))) (begin (if (not (valid-bound-ids?129 ids441)) (syntax-violation #f "invalid or duplicate identifier in definition" outer-form432)) (let loop476 ((bs477 bindings445) (er-cache478 #f) (r-cache479 #f)) (if (not (null? bs477)) (let ((b480 (car bs477))) (if (eq? (car b480) (quote macro)) (let ((er481 (cadr b480))) (let ((r-cache482 (if (eq? er481 er-cache478) r-cache479 (macros-only-env100 er481)))) (begin (set-cdr! b480 (eval-local-transformer147 (chi140 (cddr b480) r-cache482 (quote (())) mod454) mod454)) (loop476 (cdr bs477) er481 r-cache482)))) (loop476 (cdr bs477) er-cache478 r-cache479))))) (set-cdr! r436 (extend-env98 labels442 bindings445 (cdr r436))) (build-letrec86 #f vars443 (map (lambda (x483) (chi140 (cdr x483) (car x483) (quote (())) mod454)) vals444) (build-sequence83 #f (map (lambda (x484) (chi140 (cdr x484) (car x484) (quote (())) mod454)) (cons (cons er448 (source-wrap133 e451 w452 s453 mod454)) (cdr body440)))))))))))))))))))))) (chi-macro143 (lambda (p485 e486 r487 w488 rib489 mod490) (letrec ((rebuild-macro-output491 (lambda (x492 m493) (cond ((pair? x492) (cons (rebuild-macro-output491 (car x492) m493) (rebuild-macro-output491 (cdr x492) m493))) ((syntax-object?88 x492) (let ((w494 (syntax-object-wrap90 x492))) (let ((ms495 (wrap-marks107 w494)) (s496 (wrap-subst108 w494))) (if (and (pair? ms495) (eq? (car ms495) #f)) (make-syntax-object87 (syntax-object-expression89 x492) (make-wrap106 (cdr ms495) (if rib489 (cons rib489 (cdr s496)) (cdr s496))) (syntax-object-module91 x492)) (make-syntax-object87 (syntax-object-expression89 x492) (make-wrap106 (cons m493 ms495) (if rib489 (cons rib489 (cons (quote shift) s496)) (cons (quote shift) s496))) (let ((pmod497 (procedure-module p485))) (if pmod497 (cons (quote hygiene) (module-name pmod497)) (quote (hygiene guile))))))))) ((vector? x492) (let ((n498 (vector-length x492))) (let ((v499 (make-vector n498))) (let doloop500 ((i501 0)) (if (fx=73 i501 n498) v499 (begin (vector-set! v499 i501 (rebuild-macro-output491 (vector-ref x492 i501) m493)) (doloop500 (fx+71 i501 1)))))))) ((symbol? x492) (syntax-violation #f "encountered raw symbol in macro output" (source-wrap133 e486 w488 s mod490) x492)) (else x492))))) (rebuild-macro-output491 (p485 (wrap132 e486 (anti-mark119 w488) mod490)) (string #\m))))) (chi-application142 (lambda (x502 e503 r504 w505 s506 mod507) ((lambda (tmp508) ((lambda (tmp509) (if tmp509 (apply (lambda (e0510 e1511) (build-annotated79 s506 (cons x502 (map (lambda (e512) (chi140 e512 r504 w505 mod507)) e1511)))) tmp509) (syntax-violation #f "source expression failed to match any pattern" tmp508))) ($sc-dispatch tmp508 (quote (any . each-any))))) e503))) (chi-expr141 (lambda (type514 value515 e516 r517 w518 s519 mod520) (let ((t521 type514)) (if (memv t521 (quote (lexical))) (build-annotated79 s519 value515) (if (memv t521 (quote (core external-macro))) (value515 e516 r517 w518 s519 mod520) (if (memv t521 (quote (module-ref))) (call-with-values (lambda () (value515 e516)) (lambda (id522 mod523) (build-global-reference80 s519 id522 mod523))) (if (memv t521 (quote (lexical-call))) (chi-application142 (build-annotated79 (source-annotation95 (car e516)) value515) e516 r517 w518 s519 mod520) (if (memv t521 (quote (global-call))) (chi-application142 (build-global-reference80 (source-annotation95 (car e516)) value515 (if (syntax-object?88 (car e516)) (syntax-object-module91 (car e516)) mod520)) e516 r517 w518 s519 mod520) (if (memv t521 (quote (constant))) (build-data82 s519 (strip151 (source-wrap133 e516 w518 s519 mod520) (quote (())))) (if (memv t521 (quote (global))) (build-global-reference80 s519 value515 mod520) (if (memv t521 (quote (call))) (chi-application142 (chi140 (car e516) r517 w518 mod520) e516 r517 w518 s519 mod520) (if (memv t521 (quote (begin-form))) ((lambda (tmp524) ((lambda (tmp525) (if tmp525 (apply (lambda (_526 e1527 e2528) (chi-sequence134 (cons e1527 e2528) r517 w518 s519 mod520)) tmp525) (syntax-violation #f "source expression failed to match any pattern" tmp524))) ($sc-dispatch tmp524 (quote (any any . each-any))))) e516) (if (memv t521 (quote (local-syntax-form))) (chi-local-syntax146 value515 e516 r517 w518 s519 mod520 chi-sequence134) (if (memv t521 (quote (eval-when-form))) ((lambda (tmp530) ((lambda (tmp531) (if tmp531 (apply (lambda (_532 x533 e1534 e2535) (let ((when-list536 (chi-when-list137 e516 x533 w518))) (if (memq (quote eval) when-list536) (chi-sequence134 (cons e1534 e2535) r517 w518 s519 mod520) (chi-void148)))) tmp531) (syntax-violation #f "source expression failed to match any pattern" tmp530))) ($sc-dispatch tmp530 (quote (any each-any any . each-any))))) e516) (if (memv t521 (quote (define-form define-syntax-form))) (syntax-violation #f "definition in expression context" e516 (wrap132 value515 w518 mod520)) (if (memv t521 (quote (syntax))) (syntax-violation #f "reference to pattern variable outside syntax form" (source-wrap133 e516 w518 s519 mod520)) (if (memv t521 (quote (displaced-lexical))) (syntax-violation #f "reference to identifier outside its scope" (source-wrap133 e516 w518 s519 mod520)) (syntax-violation #f "unexpected syntax" (source-wrap133 e516 w518 s519 mod520))))))))))))))))))) (chi140 (lambda (e539 r540 w541 mod542) (call-with-values (lambda () (syntax-type138 e539 r540 w541 #f #f mod542)) (lambda (type543 value544 e545 w546 s547 mod548) (chi-expr141 type543 value544 e545 r540 w546 s547 mod548))))) (chi-top139 (lambda (e549 r550 w551 m552 esew553 mod554) (call-with-values (lambda () (syntax-type138 e549 r550 w551 #f #f mod554)) (lambda (type562 value563 e564 w565 s566 mod567) (let ((t568 type562)) (if (memv t568 (quote (begin-form))) ((lambda (tmp569) ((lambda (tmp570) (if tmp570 (apply (lambda (_571) (chi-void148)) tmp570) ((lambda (tmp572) (if tmp572 (apply (lambda (_573 e1574 e2575) (chi-top-sequence135 (cons e1574 e2575) r550 w565 s566 m552 esew553 mod567)) tmp572) (syntax-violation #f "source expression failed to match any pattern" tmp569))) ($sc-dispatch tmp569 (quote (any any . each-any)))))) ($sc-dispatch tmp569 (quote (any))))) e564) (if (memv t568 (quote (local-syntax-form))) (chi-local-syntax146 value563 e564 r550 w565 s566 mod567 (lambda (body577 r578 w579 s580 mod581) (chi-top-sequence135 body577 r578 w579 s580 m552 esew553 mod581))) (if (memv t568 (quote (eval-when-form))) ((lambda (tmp582) ((lambda (tmp583) (if tmp583 (apply (lambda (_584 x585 e1586 e2587) (let ((when-list588 (chi-when-list137 e564 x585 w565)) (body589 (cons e1586 e2587))) (cond ((eq? m552 (quote e)) (if (memq (quote eval) when-list588) (chi-top-sequence135 body589 r550 w565 s566 (quote e) (quote (eval)) mod567) (chi-void148))) ((memq (quote load) when-list588) (if (or (memq (quote compile) when-list588) (and (eq? m552 (quote c&e)) (memq (quote eval) when-list588))) (chi-top-sequence135 body589 r550 w565 s566 (quote c&e) (quote (compile load)) mod567) (if (memq m552 (quote (c c&e))) (chi-top-sequence135 body589 r550 w565 s566 (quote c) (quote (load)) mod567) (chi-void148)))) ((or (memq (quote compile) when-list588) (and (eq? m552 (quote c&e)) (memq (quote eval) when-list588))) (top-level-eval-hook75 (chi-top-sequence135 body589 r550 w565 s566 (quote e) (quote (eval)) mod567) mod567) (chi-void148)) (else (chi-void148))))) tmp583) (syntax-violation #f "source expression failed to match any pattern" tmp582))) ($sc-dispatch tmp582 (quote (any each-any any . each-any))))) e564) (if (memv t568 (quote (define-syntax-form))) (let ((n592 (id-var-name126 value563 w565)) (r593 (macros-only-env100 r550))) (let ((t594 m552)) (if (memv t594 (quote (c))) (if (memq (quote compile) esew553) (let ((e595 (chi-install-global136 n592 (chi140 e564 r593 w565 mod567)))) (begin (top-level-eval-hook75 e595 mod567) (if (memq (quote load) esew553) e595 (chi-void148)))) (if (memq (quote load) esew553) (chi-install-global136 n592 (chi140 e564 r593 w565 mod567)) (chi-void148))) (if (memv t594 (quote (c&e))) (let ((e596 (chi-install-global136 n592 (chi140 e564 r593 w565 mod567)))) (begin (top-level-eval-hook75 e596 mod567) e596)) (begin (if (memq (quote eval) esew553) (top-level-eval-hook75 (chi-install-global136 n592 (chi140 e564 r593 w565 mod567)) mod567)) (chi-void148)))))) (if (memv t568 (quote (define-form))) (let ((n597 (id-var-name126 value563 w565))) (let ((type598 (binding-type96 (lookup101 n597 r550 mod567)))) (let ((t599 type598)) (if (memv t599 (quote (global core macro module-ref))) (let ((x600 (build-annotated79 s566 (list (quote define) n597 (chi140 e564 r550 w565 mod567))))) (begin (if (eq? m552 (quote c&e)) (top-level-eval-hook75 x600 mod567)) x600)) (if (memv t599 (quote (displaced-lexical))) (syntax-violation #f "identifier out of context" e564 (wrap132 value563 w565 mod567)) (syntax-violation #f "cannot define keyword at top level" e564 (wrap132 value563 w565 mod567))))))) (let ((x601 (chi-expr141 type562 value563 e564 r550 w565 s566 mod567))) (begin (if (eq? m552 (quote c&e)) (top-level-eval-hook75 x601 mod567)) x601)))))))))))) (syntax-type138 (lambda (e602 r603 w604 s605 rib606 mod607) (cond ((symbol? e602) (let ((n608 (id-var-name126 e602 w604))) (let ((b609 (lookup101 n608 r603 mod607))) (let ((type610 (binding-type96 b609))) (let ((t611 type610)) (if (memv t611 (quote (lexical))) (values type610 (binding-value97 b609) e602 w604 s605 mod607) (if (memv t611 (quote (global))) (values type610 n608 e602 w604 s605 mod607) (if (memv t611 (quote (macro))) (syntax-type138 (chi-macro143 (binding-value97 b609) e602 r603 w604 rib606 mod607) r603 (quote (())) s605 rib606 mod607) (values type610 (binding-value97 b609) e602 w604 s605 mod607))))))))) ((pair? e602) (let ((first612 (car e602))) (if (id?104 first612) (let ((n613 (id-var-name126 first612 w604))) (let ((b614 (lookup101 n613 r603 (or (and (syntax-object?88 first612) (syntax-object-module91 first612)) mod607)))) (let ((type615 (binding-type96 b614))) (let ((t616 type615)) (if (memv t616 (quote (lexical))) (values (quote lexical-call) (binding-value97 b614) e602 w604 s605 mod607) (if (memv t616 (quote (global))) (values (quote global-call) n613 e602 w604 s605 mod607) (if (memv t616 (quote (macro))) (syntax-type138 (chi-macro143 (binding-value97 b614) e602 r603 w604 rib606 mod607) r603 (quote (())) s605 rib606 mod607) (if (memv t616 (quote (core external-macro module-ref))) (values type615 (binding-value97 b614) e602 w604 s605 mod607) (if (memv t616 (quote (local-syntax))) (values (quote local-syntax-form) (binding-value97 b614) e602 w604 s605 mod607) (if (memv t616 (quote (begin))) (values (quote begin-form) #f e602 w604 s605 mod607) (if (memv t616 (quote (eval-when))) (values (quote eval-when-form) #f e602 w604 s605 mod607) (if (memv t616 (quote (define))) ((lambda (tmp617) ((lambda (tmp618) (if (if tmp618 (apply (lambda (_619 name620 val621) (id?104 name620)) tmp618) #f) (apply (lambda (_622 name623 val624) (values (quote define-form) name623 val624 w604 s605 mod607)) tmp618) ((lambda (tmp625) (if (if tmp625 (apply (lambda (_626 name627 args628 e1629 e2630) (and (id?104 name627) (valid-bound-ids?129 (lambda-var-list153 args628)))) tmp625) #f) (apply (lambda (_631 name632 args633 e1634 e2635) (values (quote define-form) (wrap132 name632 w604 mod607) (cons (quote #(syntax-object lambda ((top) #(ribcage #(_ name args e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) (wrap132 (cons args633 (cons e1634 e2635)) w604 mod607)) (quote (())) s605 mod607)) tmp625) ((lambda (tmp637) (if (if tmp637 (apply (lambda (_638 name639) (id?104 name639)) tmp637) #f) (apply (lambda (_640 name641) (values (quote define-form) (wrap132 name641 w604 mod607) (quote (#(syntax-object if ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)) #(syntax-object #f ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)) #(syntax-object #f ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote (())) s605 mod607)) tmp637) (syntax-violation #f "source expression failed to match any pattern" tmp617))) ($sc-dispatch tmp617 (quote (any any)))))) ($sc-dispatch tmp617 (quote (any (any . any) any . each-any)))))) ($sc-dispatch tmp617 (quote (any any any))))) e602) (if (memv t616 (quote (define-syntax))) ((lambda (tmp642) ((lambda (tmp643) (if (if tmp643 (apply (lambda (_644 name645 val646) (id?104 name645)) tmp643) #f) (apply (lambda (_647 name648 val649) (values (quote define-syntax-form) name648 val649 w604 s605 mod607)) tmp643) (syntax-violation #f "source expression failed to match any pattern" tmp642))) ($sc-dispatch tmp642 (quote (any any any))))) e602) (values (quote call) #f e602 w604 s605 mod607)))))))))))))) (values (quote call) #f e602 w604 s605 mod607)))) ((syntax-object?88 e602) (syntax-type138 (syntax-object-expression89 e602) r603 (join-wraps123 w604 (syntax-object-wrap90 e602)) #f rib606 (or (syntax-object-module91 e602) mod607))) ((annotation? e602) (syntax-type138 (annotation-expression e602) r603 w604 (annotation-source e602) rib606 mod607)) ((self-evaluating? e602) (values (quote constant) #f e602 w604 s605 mod607)) (else (values (quote other) #f e602 w604 s605 mod607))))) (chi-when-list137 (lambda (e650 when-list651 w652) (let f653 ((when-list654 when-list651) (situations655 (quote ()))) (if (null? when-list654) situations655 (f653 (cdr when-list654) (cons (let ((x656 (car when-list654))) (cond ((free-id=?127 x656 (quote #(syntax-object compile ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote compile)) ((free-id=?127 x656 (quote #(syntax-object load ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote load)) ((free-id=?127 x656 (quote #(syntax-object eval ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote eval)) (else (syntax-violation (quote eval-when) "invalid situation" e650 (wrap132 x656 w652 #f))))) situations655)))))) (chi-install-global136 (lambda (name657 e658) (build-annotated79 #f (list (build-annotated79 #f (quote define)) name657 (if (let ((v659 (module-variable (current-module) name657))) (and v659 (variable-bound? v659) (macro? (variable-ref v659)) (not (eq? (macro-type (variable-ref v659)) (quote syncase-macro))))) (build-annotated79 #f (list (build-annotated79 #f (quote make-extended-syncase-macro)) (build-annotated79 #f (list (build-annotated79 #f (quote module-ref)) (build-annotated79 #f (quote (current-module))) (build-data82 #f name657))) (build-data82 #f (quote macro)) e658)) (build-annotated79 #f (list (build-annotated79 #f (quote make-syncase-macro)) (build-data82 #f (quote macro)) e658))))))) (chi-top-sequence135 (lambda (body660 r661 w662 s663 m664 esew665 mod666) (build-sequence83 s663 (let dobody667 ((body668 body660) (r669 r661) (w670 w662) (m671 m664) (esew672 esew665) (mod673 mod666)) (if (null? body668) (quote ()) (let ((first674 (chi-top139 (car body668) r669 w670 m671 esew672 mod673))) (cons first674 (dobody667 (cdr body668) r669 w670 m671 esew672 mod673)))))))) (chi-sequence134 (lambda (body675 r676 w677 s678 mod679) (build-sequence83 s678 (let dobody680 ((body681 body675) (r682 r676) (w683 w677) (mod684 mod679)) (if (null? body681) (quote ()) (let ((first685 (chi140 (car body681) r682 w683 mod684))) (cons first685 (dobody680 (cdr body681) r682 w683 mod684)))))))) (source-wrap133 (lambda (x686 w687 s688 defmod689) (wrap132 (if s688 (make-annotation x686 s688 #f) x686) w687 defmod689))) (wrap132 (lambda (x690 w691 defmod692) (cond ((and (null? (wrap-marks107 w691)) (null? (wrap-subst108 w691))) x690) ((syntax-object?88 x690) (make-syntax-object87 (syntax-object-expression89 x690) (join-wraps123 w691 (syntax-object-wrap90 x690)) (syntax-object-module91 x690))) ((null? x690) x690) (else (make-syntax-object87 x690 w691 defmod692))))) (bound-id-member?131 (lambda (x693 list694) (and (not (null? list694)) (or (bound-id=?128 x693 (car list694)) (bound-id-member?131 x693 (cdr list694)))))) (distinct-bound-ids?130 (lambda (ids695) (let distinct?696 ((ids697 ids695)) (or (null? ids697) (and (not (bound-id-member?131 (car ids697) (cdr ids697))) (distinct?696 (cdr ids697))))))) (valid-bound-ids?129 (lambda (ids698) (and (let all-ids?699 ((ids700 ids698)) (or (null? ids700) (and (id?104 (car ids700)) (all-ids?699 (cdr ids700))))) (distinct-bound-ids?130 ids698)))) (bound-id=?128 (lambda (i701 j702) (if (and (syntax-object?88 i701) (syntax-object?88 j702)) (and (eq? (let ((e703 (syntax-object-expression89 i701))) (if (annotation? e703) (annotation-expression e703) e703)) (let ((e704 (syntax-object-expression89 j702))) (if (annotation? e704) (annotation-expression e704) e704))) (same-marks?125 (wrap-marks107 (syntax-object-wrap90 i701)) (wrap-marks107 (syntax-object-wrap90 j702)))) (eq? (let ((e705 i701)) (if (annotation? e705) (annotation-expression e705) e705)) (let ((e706 j702)) (if (annotation? e706) (annotation-expression e706) e706)))))) (free-id=?127 (lambda (i707 j708) (and (eq? (let ((x709 i707)) (let ((e710 (if (syntax-object?88 x709) (syntax-object-expression89 x709) x709))) (if (annotation? e710) (annotation-expression e710) e710))) (let ((x711 j708)) (let ((e712 (if (syntax-object?88 x711) (syntax-object-expression89 x711) x711))) (if (annotation? e712) (annotation-expression e712) e712)))) (eq? (id-var-name126 i707 (quote (()))) (id-var-name126 j708 (quote (()))))))) (id-var-name126 (lambda (id713 w714) (letrec ((search-vector-rib717 (lambda (sym723 subst724 marks725 symnames726 ribcage727) (let ((n728 (vector-length symnames726))) (let f729 ((i730 0)) (cond ((fx=73 i730 n728) (search715 sym723 (cdr subst724) marks725)) ((and (eq? (vector-ref symnames726 i730) sym723) (same-marks?125 marks725 (vector-ref (ribcage-marks114 ribcage727) i730))) (values (vector-ref (ribcage-labels115 ribcage727) i730) marks725)) (else (f729 (fx+71 i730 1)))))))) (search-list-rib716 (lambda (sym731 subst732 marks733 symnames734 ribcage735) (let f736 ((symnames737 symnames734) (i738 0)) (cond ((null? symnames737) (search715 sym731 (cdr subst732) marks733)) ((and (eq? (car symnames737) sym731) (same-marks?125 marks733 (list-ref (ribcage-marks114 ribcage735) i738))) (values (list-ref (ribcage-labels115 ribcage735) i738) marks733)) (else (f736 (cdr symnames737) (fx+71 i738 1))))))) (search715 (lambda (sym739 subst740 marks741) (if (null? subst740) (values #f marks741) (let ((fst742 (car subst740))) (if (eq? fst742 (quote shift)) (search715 sym739 (cdr subst740) (cdr marks741)) (let ((symnames743 (ribcage-symnames113 fst742))) (if (vector? symnames743) (search-vector-rib717 sym739 subst740 marks741 symnames743 fst742) (search-list-rib716 sym739 subst740 marks741 symnames743 fst742))))))))) (cond ((symbol? id713) (or (call-with-values (lambda () (search715 id713 (wrap-subst108 w714) (wrap-marks107 w714))) (lambda (x745 . ignore744) x745)) id713)) ((syntax-object?88 id713) (let ((id746 (let ((e748 (syntax-object-expression89 id713))) (if (annotation? e748) (annotation-expression e748) e748))) (w1747 (syntax-object-wrap90 id713))) (let ((marks749 (join-marks124 (wrap-marks107 w714) (wrap-marks107 w1747)))) (call-with-values (lambda () (search715 id746 (wrap-subst108 w714) marks749)) (lambda (new-id750 marks751) (or new-id750 (call-with-values (lambda () (search715 id746 (wrap-subst108 w1747) marks751)) (lambda (x753 . ignore752) x753)) id746)))))) ((annotation? id713) (let ((id754 (let ((e755 id713)) (if (annotation? e755) (annotation-expression e755) e755)))) (or (call-with-values (lambda () (search715 id754 (wrap-subst108 w714) (wrap-marks107 w714))) (lambda (x757 . ignore756) x757)) id754))) (else (syntax-violation (quote id-var-name) "invalid id" id713)))))) (same-marks?125 (lambda (x758 y759) (or (eq? x758 y759) (and (not (null? x758)) (not (null? y759)) (eq? (car x758) (car y759)) (same-marks?125 (cdr x758) (cdr y759)))))) (join-marks124 (lambda (m1760 m2761) (smart-append122 m1760 m2761))) (join-wraps123 (lambda (w1762 w2763) (let ((m1764 (wrap-marks107 w1762)) (s1765 (wrap-subst108 w1762))) (if (null? m1764) (if (null? s1765) w2763 (make-wrap106 (wrap-marks107 w2763) (smart-append122 s1765 (wrap-subst108 w2763)))) (make-wrap106 (smart-append122 m1764 (wrap-marks107 w2763)) (smart-append122 s1765 (wrap-subst108 w2763))))))) (smart-append122 (lambda (m1766 m2767) (if (null? m2767) m1766 (append m1766 m2767)))) (make-binding-wrap121 (lambda (ids768 labels769 w770) (if (null? ids768) w770 (make-wrap106 (wrap-marks107 w770) (cons (let ((labelvec771 (list->vector labels769))) (let ((n772 (vector-length labelvec771))) (let ((symnamevec773 (make-vector n772)) (marksvec774 (make-vector n772))) (begin (let f775 ((ids776 ids768) (i777 0)) (if (not (null? ids776)) (call-with-values (lambda () (id-sym-name&marks105 (car ids776) w770)) (lambda (symname778 marks779) (begin (vector-set! symnamevec773 i777 symname778) (vector-set! marksvec774 i777 marks779) (f775 (cdr ids776) (fx+71 i777 1))))))) (make-ribcage111 symnamevec773 marksvec774 labelvec771))))) (wrap-subst108 w770)))))) (extend-ribcage!120 (lambda (ribcage780 id781 label782) (begin (set-ribcage-symnames!116 ribcage780 (cons (let ((e783 (syntax-object-expression89 id781))) (if (annotation? e783) (annotation-expression e783) e783)) (ribcage-symnames113 ribcage780))) (set-ribcage-marks!117 ribcage780 (cons (wrap-marks107 (syntax-object-wrap90 id781)) (ribcage-marks114 ribcage780))) (set-ribcage-labels!118 ribcage780 (cons label782 (ribcage-labels115 ribcage780)))))) (anti-mark119 (lambda (w784) (make-wrap106 (cons #f (wrap-marks107 w784)) (cons (quote shift) (wrap-subst108 w784))))) (set-ribcage-labels!118 (lambda (x785 update786) (vector-set! x785 3 update786))) (set-ribcage-marks!117 (lambda (x787 update788) (vector-set! x787 2 update788))) (set-ribcage-symnames!116 (lambda (x789 update790) (vector-set! x789 1 update790))) (ribcage-labels115 (lambda (x791) (vector-ref x791 3))) (ribcage-marks114 (lambda (x792) (vector-ref x792 2))) (ribcage-symnames113 (lambda (x793) (vector-ref x793 1))) (ribcage?112 (lambda (x794) (and (vector? x794) (= (vector-length x794) 4) (eq? (vector-ref x794 0) (quote ribcage))))) (make-ribcage111 (lambda (symnames795 marks796 labels797) (vector (quote ribcage) symnames795 marks796 labels797))) (gen-labels110 (lambda (ls798) (if (null? ls798) (quote ()) (cons (gen-label109) (gen-labels110 (cdr ls798)))))) (gen-label109 (lambda () (string #\i))) (wrap-subst108 cdr) (wrap-marks107 car) (make-wrap106 cons) (id-sym-name&marks105 (lambda (x799 w800) (if (syntax-object?88 x799) (values (let ((e801 (syntax-object-expression89 x799))) (if (annotation? e801) (annotation-expression e801) e801)) (join-marks124 (wrap-marks107 w800) (wrap-marks107 (syntax-object-wrap90 x799)))) (values (let ((e802 x799)) (if (annotation? e802) (annotation-expression e802) e802)) (wrap-marks107 w800))))) (id?104 (lambda (x803) (cond ((symbol? x803) #t) ((syntax-object?88 x803) (symbol? (let ((e804 (syntax-object-expression89 x803))) (if (annotation? e804) (annotation-expression e804) e804)))) ((annotation? x803) (symbol? (annotation-expression x803))) (else #f)))) (nonsymbol-id?103 (lambda (x805) (and (syntax-object?88 x805) (symbol? (let ((e806 (syntax-object-expression89 x805))) (if (annotation? e806) (annotation-expression e806) e806)))))) (global-extend102 (lambda (type807 sym808 val809) (put-global-definition-hook77 sym808 type807 val809))) (lookup101 (lambda (x810 r811 mod812) (cond ((assq x810 r811) => cdr) ((symbol? x810) (or (get-global-definition-hook78 x810 mod812) (quote (global)))) (else (quote (displaced-lexical)))))) (macros-only-env100 (lambda (r813) (if (null? r813) (quote ()) (let ((a814 (car r813))) (if (eq? (cadr a814) (quote macro)) (cons a814 (macros-only-env100 (cdr r813))) (macros-only-env100 (cdr r813))))))) (extend-var-env99 (lambda (labels815 vars816 r817) (if (null? labels815) r817 (extend-var-env99 (cdr labels815) (cdr vars816) (cons (cons (car labels815) (cons (quote lexical) (car vars816))) r817))))) (extend-env98 (lambda (labels818 bindings819 r820) (if (null? labels818) r820 (extend-env98 (cdr labels818) (cdr bindings819) (cons (cons (car labels818) (car bindings819)) r820))))) (binding-value97 cdr) (binding-type96 car) (source-annotation95 (lambda (x821) (cond ((annotation? x821) (annotation-source x821)) ((syntax-object?88 x821) (source-annotation95 (syntax-object-expression89 x821))) (else #f)))) (set-syntax-object-module!94 (lambda (x822 update823) (vector-set! x822 3 update823))) (set-syntax-object-wrap!93 (lambda (x824 update825) (vector-set! x824 2 update825))) (set-syntax-object-expression!92 (lambda (x826 update827) (vector-set! x826 1 update827))) (syntax-object-module91 (lambda (x828) (vector-ref x828 3))) (syntax-object-wrap90 (lambda (x829) (vector-ref x829 2))) (syntax-object-expression89 (lambda (x830) (vector-ref x830 1))) (syntax-object?88 (lambda (x831) (and (vector? x831) (= (vector-length x831) 4) (eq? (vector-ref x831 0) (quote syntax-object))))) (make-syntax-object87 (lambda (expression832 wrap833 module834) (vector (quote syntax-object) expression832 wrap833 module834))) (build-letrec86 (lambda (src835 vars836 val-exps837 body-exp838) (if (null? vars836) (build-annotated79 src835 body-exp838) (build-annotated79 src835 (list (quote letrec) (map list vars836 val-exps837) body-exp838))))) (build-named-let85 (lambda (src839 vars840 val-exps841 body-exp842) (if (null? vars840) (build-annotated79 src839 body-exp842) (build-annotated79 src839 (list (quote let) (car vars840) (map list (cdr vars840) val-exps841) body-exp842))))) (build-let84 (lambda (src843 vars844 val-exps845 body-exp846) (if (null? vars844) (build-annotated79 src843 body-exp846) (build-annotated79 src843 (list (quote let) (map list vars844 val-exps845) body-exp846))))) (build-sequence83 (lambda (src847 exps848) (if (null? (cdr exps848)) (build-annotated79 src847 (car exps848)) (build-annotated79 src847 (cons (quote begin) exps848))))) (build-data82 (lambda (src849 exp850) (if (and (self-evaluating? exp850) (not (vector? exp850))) (build-annotated79 src849 exp850) (build-annotated79 src849 (list (quote quote) exp850))))) (build-global-assignment81 (lambda (source851 var852 exp853 mod854) (let ((ref855 (build-global-reference80 source851 var852 mod854))) (build-annotated79 source851 (list (quote set!) ref855 exp853))))) (build-global-reference80 (lambda (source856 var857 mod858) (build-annotated79 source856 (if (not mod858) var857 (let ((make-module-ref859 (let ((t862 (fluid-ref *mode*70))) (if (memv t862 (quote (c))) (@ (ice-9 expand-support) make-module-ref) (lambda (mod863 var864 public?865) (list (if public?865 (quote @) (quote @@)) mod863 var864))))) (kind860 (car mod858)) (mod861 (cdr mod858))) (let ((t866 kind860)) (if (memv t866 (quote (public))) (make-module-ref859 mod861 var857 #t) (if (memv t866 (quote (private))) (if (not (equal? mod861 (module-name (current-module)))) (make-module-ref859 mod861 var857 #f) var857) (if (memv t866 (quote (bare))) var857 (if (memv t866 (quote (hygiene))) (if (and (not (equal? mod861 (module-name (current-module)))) (module-variable (resolve-module mod861) var857)) (make-module-ref859 mod861 var857 #f) var857) (syntax-violation #f "bad module kind" var857 mod861))))))))))) (build-annotated79 (lambda (src867 exp868) (if (and src867 (not (annotation? exp868))) (make-annotation exp868 src867 #t) exp868))) (get-global-definition-hook78 (lambda (symbol869 module870) (begin (if (and (not module870) (current-module)) (warn "module system is booted, we should have a module" symbol869)) (let ((v871 (module-variable (if module870 (resolve-module (cdr module870)) (current-module)) symbol869))) (and v871 (variable-bound? v871) (let ((val872 (variable-ref v871))) (and (macro? val872) (syncase-macro-type val872) (cons (syncase-macro-type val872) (syncase-macro-binding val872))))))))) (put-global-definition-hook77 (lambda (symbol873 type874 val875) (let ((existing876 (let ((v877 (module-variable (current-module) symbol873))) (and v877 (variable-bound? v877) (let ((val878 (variable-ref v877))) (and (macro? val878) (not (syncase-macro-type val878)) val878)))))) (module-define! (current-module) symbol873 (if existing876 (make-extended-syncase-macro existing876 type874 val875) (make-syncase-macro type874 val875)))))) (local-eval-hook76 (lambda (x879 mod880) (primitive-eval (list noexpand69 (let ((t881 (fluid-ref *mode*70))) (if (memv t881 (quote (c))) ((@ (ice-9 expand-support) strip-expansion-structures) x879) x879)))))) (top-level-eval-hook75 (lambda (x882 mod883) (primitive-eval (list noexpand69 (let ((t884 (fluid-ref *mode*70))) (if (memv t884 (quote (c))) ((@ (ice-9 expand-support) strip-expansion-structures) x882) x882)))))) (fx<74 <) (fx=73 =) (fx-72 -) (fx+71 +) (*mode*70 (make-fluid)) (noexpand69 "noexpand")) (begin (global-extend102 (quote local-syntax) (quote letrec-syntax) #t) (global-extend102 (quote local-syntax) (quote let-syntax) #f) (global-extend102 (quote core) (quote fluid-let-syntax) (lambda (e885 r886 w887 s888 mod889) ((lambda (tmp890) ((lambda (tmp891) (if (if tmp891 (apply (lambda (_892 var893 val894 e1895 e2896) (valid-bound-ids?129 var893)) tmp891) #f) (apply (lambda (_898 var899 val900 e1901 e2902) (let ((names903 (map (lambda (x904) (id-var-name126 x904 w887)) var899))) (begin (for-each (lambda (id906 n907) (let ((t908 (binding-type96 (lookup101 n907 r886 mod889)))) (if (memv t908 (quote (displaced-lexical))) (syntax-violation (quote fluid-let-syntax) "identifier out of context" e885 (source-wrap133 id906 w887 s888 mod889))))) var899 names903) (chi-body144 (cons e1901 e2902) (source-wrap133 e885 w887 s888 mod889) (extend-env98 names903 (let ((trans-r911 (macros-only-env100 r886))) (map (lambda (x912) (cons (quote macro) (eval-local-transformer147 (chi140 x912 trans-r911 w887 mod889) mod889))) val900)) r886) w887 mod889)))) tmp891) ((lambda (_914) (syntax-violation (quote fluid-let-syntax) "bad syntax" (source-wrap133 e885 w887 s888 mod889))) tmp890))) ($sc-dispatch tmp890 (quote (any #(each (any any)) any . each-any))))) e885))) (global-extend102 (quote core) (quote quote) (lambda (e915 r916 w917 s918 mod919) ((lambda (tmp920) ((lambda (tmp921) (if tmp921 (apply (lambda (_922 e923) (build-data82 s918 (strip151 e923 w917))) tmp921) ((lambda (_924) (syntax-violation (quote quote) "bad syntax" (source-wrap133 e915 w917 s918 mod919))) tmp920))) ($sc-dispatch tmp920 (quote (any any))))) e915))) (global-extend102 (quote core) (quote syntax) (letrec ((regen932 (lambda (x933) (let ((t934 (car x933))) (if (memv t934 (quote (ref))) (build-annotated79 #f (cadr x933)) (if (memv t934 (quote (primitive))) (build-annotated79 #f (cadr x933)) (if (memv t934 (quote (quote))) (build-data82 #f (cadr x933)) (if (memv t934 (quote (lambda))) (build-annotated79 #f (list (quote lambda) (cadr x933) (regen932 (caddr x933)))) (if (memv t934 (quote (map))) (let ((ls935 (map regen932 (cdr x933)))) (build-annotated79 #f (cons (if (fx=73 (length ls935) 2) (build-annotated79 #f (quote map)) (build-annotated79 #f (quote map))) ls935))) (build-annotated79 #f (cons (build-annotated79 #f (car x933)) (map regen932 (cdr x933)))))))))))) (gen-vector931 (lambda (x936) (cond ((eq? (car x936) (quote list)) (cons (quote vector) (cdr x936))) ((eq? (car x936) (quote quote)) (list (quote quote) (list->vector (cadr x936)))) (else (list (quote list->vector) x936))))) (gen-append930 (lambda (x937 y938) (if (equal? y938 (quote (quote ()))) x937 (list (quote append) x937 y938)))) (gen-cons929 (lambda (x939 y940) (let ((t941 (car y940))) (if (memv t941 (quote (quote))) (if (eq? (car x939) (quote quote)) (list (quote quote) (cons (cadr x939) (cadr y940))) (if (eq? (cadr y940) (quote ())) (list (quote list) x939) (list (quote cons) x939 y940))) (if (memv t941 (quote (list))) (cons (quote list) (cons x939 (cdr y940))) (list (quote cons) x939 y940)))))) (gen-map928 (lambda (e942 map-env943) (let ((formals944 (map cdr map-env943)) (actuals945 (map (lambda (x946) (list (quote ref) (car x946))) map-env943))) (cond ((eq? (car e942) (quote ref)) (car actuals945)) ((and-map (lambda (x947) (and (eq? (car x947) (quote ref)) (memq (cadr x947) formals944))) (cdr e942)) (cons (quote map) (cons (list (quote primitive) (car e942)) (map (let ((r948 (map cons formals944 actuals945))) (lambda (x949) (cdr (assq (cadr x949) r948)))) (cdr e942))))) (else (cons (quote map) (cons (list (quote lambda) formals944 e942) actuals945))))))) (gen-mappend927 (lambda (e950 map-env951) (list (quote apply) (quote (primitive append)) (gen-map928 e950 map-env951)))) (gen-ref926 (lambda (src952 var953 level954 maps955) (if (fx=73 level954 0) (values var953 maps955) (if (null? maps955) (syntax-violation (quote syntax) "missing ellipsis" src952) (call-with-values (lambda () (gen-ref926 src952 var953 (fx-72 level954 1) (cdr maps955))) (lambda (outer-var956 outer-maps957) (let ((b958 (assq outer-var956 (car maps955)))) (if b958 (values (cdr b958) maps955) (let ((inner-var959 (gen-var152 (quote tmp)))) (values inner-var959 (cons (cons (cons outer-var956 inner-var959) (car maps955)) outer-maps957))))))))))) (gen-syntax925 (lambda (src960 e961 r962 maps963 ellipsis?964 mod965) (if (id?104 e961) (let ((label966 (id-var-name126 e961 (quote (()))))) (let ((b967 (lookup101 label966 r962 mod965))) (if (eq? (binding-type96 b967) (quote syntax)) (call-with-values (lambda () (let ((var.lev968 (binding-value97 b967))) (gen-ref926 src960 (car var.lev968) (cdr var.lev968) maps963))) (lambda (var969 maps970) (values (list (quote ref) var969) maps970))) (if (ellipsis?964 e961) (syntax-violation (quote syntax) "misplaced ellipsis" src960) (values (list (quote quote) e961) maps963))))) ((lambda (tmp971) ((lambda (tmp972) (if (if tmp972 (apply (lambda (dots973 e974) (ellipsis?964 dots973)) tmp972) #f) (apply (lambda (dots975 e976) (gen-syntax925 src960 e976 r962 maps963 (lambda (x977) #f) mod965)) tmp972) ((lambda (tmp978) (if (if tmp978 (apply (lambda (x979 dots980 y981) (ellipsis?964 dots980)) tmp978) #f) (apply (lambda (x982 dots983 y984) (let f985 ((y986 y984) (k987 (lambda (maps988) (call-with-values (lambda () (gen-syntax925 src960 x982 r962 (cons (quote ()) maps988) ellipsis?964 mod965)) (lambda (x989 maps990) (if (null? (car maps990)) (syntax-violation (quote syntax) "extra ellipsis" src960) (values (gen-map928 x989 (car maps990)) (cdr maps990)))))))) ((lambda (tmp991) ((lambda (tmp992) (if (if tmp992 (apply (lambda (dots993 y994) (ellipsis?964 dots993)) tmp992) #f) (apply (lambda (dots995 y996) (f985 y996 (lambda (maps997) (call-with-values (lambda () (k987 (cons (quote ()) maps997))) (lambda (x998 maps999) (if (null? (car maps999)) (syntax-violation (quote syntax) "extra ellipsis" src960) (values (gen-mappend927 x998 (car maps999)) (cdr maps999)))))))) tmp992) ((lambda (_1000) (call-with-values (lambda () (gen-syntax925 src960 y986 r962 maps963 ellipsis?964 mod965)) (lambda (y1001 maps1002) (call-with-values (lambda () (k987 maps1002)) (lambda (x1003 maps1004) (values (gen-append930 x1003 y1001) maps1004)))))) tmp991))) ($sc-dispatch tmp991 (quote (any . any))))) y986))) tmp978) ((lambda (tmp1005) (if tmp1005 (apply (lambda (x1006 y1007) (call-with-values (lambda () (gen-syntax925 src960 x1006 r962 maps963 ellipsis?964 mod965)) (lambda (x1008 maps1009) (call-with-values (lambda () (gen-syntax925 src960 y1007 r962 maps1009 ellipsis?964 mod965)) (lambda (y1010 maps1011) (values (gen-cons929 x1008 y1010) maps1011)))))) tmp1005) ((lambda (tmp1012) (if tmp1012 (apply (lambda (e11013 e21014) (call-with-values (lambda () (gen-syntax925 src960 (cons e11013 e21014) r962 maps963 ellipsis?964 mod965)) (lambda (e1016 maps1017) (values (gen-vector931 e1016) maps1017)))) tmp1012) ((lambda (_1018) (values (list (quote quote) e961) maps963)) tmp971))) ($sc-dispatch tmp971 (quote #(vector (any . each-any))))))) ($sc-dispatch tmp971 (quote (any . any)))))) ($sc-dispatch tmp971 (quote (any any . any)))))) ($sc-dispatch tmp971 (quote (any any))))) e961))))) (lambda (e1019 r1020 w1021 s1022 mod1023) (let ((e1024 (source-wrap133 e1019 w1021 s1022 mod1023))) ((lambda (tmp1025) ((lambda (tmp1026) (if tmp1026 (apply (lambda (_1027 x1028) (call-with-values (lambda () (gen-syntax925 e1024 x1028 r1020 (quote ()) ellipsis?149 mod1023)) (lambda (e1029 maps1030) (regen932 e1029)))) tmp1026) ((lambda (_1031) (syntax-violation (quote syntax) "bad `syntax' form" e1024)) tmp1025))) ($sc-dispatch tmp1025 (quote (any any))))) e1024))))) (global-extend102 (quote core) (quote lambda) (lambda (e1032 r1033 w1034 s1035 mod1036) ((lambda (tmp1037) ((lambda (tmp1038) (if tmp1038 (apply (lambda (_1039 c1040) (chi-lambda-clause145 (source-wrap133 e1032 w1034 s1035 mod1036) #f c1040 r1033 w1034 mod1036 (lambda (vars1041 docstring1042 body1043) (build-annotated79 s1035 (cons (quote lambda) (cons vars1041 (append (if docstring1042 (list docstring1042) (quote ())) (list body1043)))))))) tmp1038) (syntax-violation #f "source expression failed to match any pattern" tmp1037))) ($sc-dispatch tmp1037 (quote (any . any))))) e1032))) (global-extend102 (quote core) (quote let) (letrec ((chi-let1044 (lambda (e1045 r1046 w1047 s1048 mod1049 constructor1050 ids1051 vals1052 exps1053) (if (not (valid-bound-ids?129 ids1051)) (syntax-violation (quote let) "duplicate bound variable" e1045) (let ((labels1054 (gen-labels110 ids1051)) (new-vars1055 (map gen-var152 ids1051))) (let ((nw1056 (make-binding-wrap121 ids1051 labels1054 w1047)) (nr1057 (extend-var-env99 labels1054 new-vars1055 r1046))) (constructor1050 s1048 new-vars1055 (map (lambda (x1058) (chi140 x1058 r1046 w1047 mod1049)) vals1052) (chi-body144 exps1053 (source-wrap133 e1045 nw1056 s1048 mod1049) nr1057 nw1056 mod1049)))))))) (lambda (e1059 r1060 w1061 s1062 mod1063) ((lambda (tmp1064) ((lambda (tmp1065) (if tmp1065 (apply (lambda (_1066 id1067 val1068 e11069 e21070) (chi-let1044 e1059 r1060 w1061 s1062 mod1063 build-let84 id1067 val1068 (cons e11069 e21070))) tmp1065) ((lambda (tmp1074) (if (if tmp1074 (apply (lambda (_1075 f1076 id1077 val1078 e11079 e21080) (id?104 f1076)) tmp1074) #f) (apply (lambda (_1081 f1082 id1083 val1084 e11085 e21086) (chi-let1044 e1059 r1060 w1061 s1062 mod1063 build-named-let85 (cons f1082 id1083) val1084 (cons e11085 e21086))) tmp1074) ((lambda (_1090) (syntax-violation (quote let) "bad let" (source-wrap133 e1059 w1061 s1062 mod1063))) tmp1064))) ($sc-dispatch tmp1064 (quote (any any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp1064 (quote (any #(each (any any)) any . each-any))))) e1059)))) (global-extend102 (quote core) (quote letrec) (lambda (e1091 r1092 w1093 s1094 mod1095) ((lambda (tmp1096) ((lambda (tmp1097) (if tmp1097 (apply (lambda (_1098 id1099 val1100 e11101 e21102) (let ((ids1103 id1099)) (if (not (valid-bound-ids?129 ids1103)) (syntax-violation (quote letrec) "duplicate bound variable" e1091) (let ((labels1105 (gen-labels110 ids1103)) (new-vars1106 (map gen-var152 ids1103))) (let ((w1107 (make-binding-wrap121 ids1103 labels1105 w1093)) (r1108 (extend-var-env99 labels1105 new-vars1106 r1092))) (build-letrec86 s1094 new-vars1106 (map (lambda (x1109) (chi140 x1109 r1108 w1107 mod1095)) val1100) (chi-body144 (cons e11101 e21102) (source-wrap133 e1091 w1107 s1094 mod1095) r1108 w1107 mod1095))))))) tmp1097) ((lambda (_1112) (syntax-violation (quote letrec) "bad letrec" (source-wrap133 e1091 w1093 s1094 mod1095))) tmp1096))) ($sc-dispatch tmp1096 (quote (any #(each (any any)) any . each-any))))) e1091))) (global-extend102 (quote core) (quote set!) (lambda (e1113 r1114 w1115 s1116 mod1117) ((lambda (tmp1118) ((lambda (tmp1119) (if (if tmp1119 (apply (lambda (_1120 id1121 val1122) (id?104 id1121)) tmp1119) #f) (apply (lambda (_1123 id1124 val1125) (let ((val1126 (chi140 val1125 r1114 w1115 mod1117)) (n1127 (id-var-name126 id1124 w1115))) (let ((b1128 (lookup101 n1127 r1114 mod1117))) (let ((t1129 (binding-type96 b1128))) (if (memv t1129 (quote (lexical))) (build-annotated79 s1116 (list (quote set!) (binding-value97 b1128) val1126)) (if (memv t1129 (quote (global))) (build-global-assignment81 s1116 n1127 val1126 mod1117) (if (memv t1129 (quote (displaced-lexical))) (syntax-violation (quote set!) "identifier out of context" (wrap132 id1124 w1115 mod1117)) (syntax-violation (quote set!) "bad set!" (source-wrap133 e1113 w1115 s1116 mod1117))))))))) tmp1119) ((lambda (tmp1130) (if tmp1130 (apply (lambda (_1131 head1132 tail1133 val1134) (call-with-values (lambda () (syntax-type138 head1132 r1114 (quote (())) #f #f mod1117)) (lambda (type1135 value1136 ee1137 ww1138 ss1139 modmod1140) (let ((t1141 type1135)) (if (memv t1141 (quote (module-ref))) (let ((val1142 (chi140 val1134 r1114 w1115 mod1117))) (call-with-values (lambda () (value1136 (cons head1132 tail1133))) (lambda (id1144 mod1145) (build-global-assignment81 s1116 id1144 val1142 mod1145)))) (build-annotated79 s1116 (cons (chi140 (list (quote #(syntax-object setter ((top) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type value ee ww ss modmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage #(_ head tail val) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(e r w s mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) head1132) r1114 w1115 mod1117) (map (lambda (e1146) (chi140 e1146 r1114 w1115 mod1117)) (append tail1133 (list val1134)))))))))) tmp1130) ((lambda (_1148) (syntax-violation (quote set!) "bad set!" (source-wrap133 e1113 w1115 s1116 mod1117))) tmp1118))) ($sc-dispatch tmp1118 (quote (any (any . each-any) any)))))) ($sc-dispatch tmp1118 (quote (any any any))))) e1113))) (global-extend102 (quote module-ref) (quote @) (lambda (e1149) ((lambda (tmp1150) ((lambda (tmp1151) (if (if tmp1151 (apply (lambda (_1152 mod1153 id1154) (and (and-map id?104 mod1153) (id?104 id1154))) tmp1151) #f) (apply (lambda (_1156 mod1157 id1158) (values (syntax->datum id1158) (syntax->datum (cons (quote #(syntax-object public ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod1157)))) tmp1151) (syntax-violation #f "source expression failed to match any pattern" tmp1150))) ($sc-dispatch tmp1150 (quote (any each-any any))))) e1149))) (global-extend102 (quote module-ref) (quote @@) (lambda (e1160) ((lambda (tmp1161) ((lambda (tmp1162) (if (if tmp1162 (apply (lambda (_1163 mod1164 id1165) (and (and-map id?104 mod1164) (id?104 id1165))) tmp1162) #f) (apply (lambda (_1167 mod1168 id1169) (values (syntax->datum id1169) (syntax->datum (cons (quote #(syntax-object private ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod1168)))) tmp1162) (syntax-violation #f "source expression failed to match any pattern" tmp1161))) ($sc-dispatch tmp1161 (quote (any each-any any))))) e1160))) (global-extend102 (quote begin) (quote begin) (quote ())) (global-extend102 (quote define) (quote define) (quote ())) (global-extend102 (quote define-syntax) (quote define-syntax) (quote ())) (global-extend102 (quote eval-when) (quote eval-when) (quote ())) (global-extend102 (quote core) (quote syntax-case) (letrec ((gen-syntax-case1174 (lambda (x1175 keys1176 clauses1177 r1178 mod1179) (if (null? clauses1177) (build-annotated79 #f (list (build-annotated79 #f (quote syntax-violation)) #f "source expression failed to match any pattern" x1175)) ((lambda (tmp1180) ((lambda (tmp1181) (if tmp1181 (apply (lambda (pat1182 exp1183) (if (and (id?104 pat1182) (and-map (lambda (x1184) (not (free-id=?127 pat1182 x1184))) (cons (quote #(syntax-object ... ((top) #(ribcage #(pat exp) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x keys clauses r mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (gen-syntax-case gen-clause build-dispatch-call convert-pattern) ((top) (top) (top) (top)) ("i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) keys1176))) (let ((labels1185 (list (gen-label109))) (var1186 (gen-var152 pat1182))) (build-annotated79 #f (list (build-annotated79 #f (list (quote lambda) (list var1186) (chi140 exp1183 (extend-env98 labels1185 (list (cons (quote syntax) (cons var1186 0))) r1178) (make-binding-wrap121 (list pat1182) labels1185 (quote (()))) mod1179))) x1175))) (gen-clause1173 x1175 keys1176 (cdr clauses1177) r1178 pat1182 #t exp1183 mod1179))) tmp1181) ((lambda (tmp1187) (if tmp1187 (apply (lambda (pat1188 fender1189 exp1190) (gen-clause1173 x1175 keys1176 (cdr clauses1177) r1178 pat1188 fender1189 exp1190 mod1179)) tmp1187) ((lambda (_1191) (syntax-violation (quote syntax-case) "invalid clause" (car clauses1177))) tmp1180))) ($sc-dispatch tmp1180 (quote (any any any)))))) ($sc-dispatch tmp1180 (quote (any any))))) (car clauses1177))))) (gen-clause1173 (lambda (x1192 keys1193 clauses1194 r1195 pat1196 fender1197 exp1198 mod1199) (call-with-values (lambda () (convert-pattern1171 pat1196 keys1193)) (lambda (p1200 pvars1201) (cond ((not (distinct-bound-ids?130 (map car pvars1201))) (syntax-violation (quote syntax-case) "duplicate pattern variable" pat1196)) ((not (and-map (lambda (x1202) (not (ellipsis?149 (car x1202)))) pvars1201)) (syntax-violation (quote syntax-case) "misplaced ellipsis" pat1196)) (else (let ((y1203 (gen-var152 (quote tmp)))) (build-annotated79 #f (list (build-annotated79 #f (list (quote lambda) (list y1203) (let ((y1204 (build-annotated79 #f y1203))) (build-annotated79 #f (list (quote if) ((lambda (tmp1205) ((lambda (tmp1206) (if tmp1206 (apply (lambda () y1204) tmp1206) ((lambda (_1207) (build-annotated79 #f (list (quote if) y1204 (build-dispatch-call1172 pvars1201 fender1197 y1204 r1195 mod1199) (build-data82 #f #f)))) tmp1205))) ($sc-dispatch tmp1205 (quote #(atom #t))))) fender1197) (build-dispatch-call1172 pvars1201 exp1198 y1204 r1195 mod1199) (gen-syntax-case1174 x1192 keys1193 clauses1194 r1195 mod1199)))))) (if (eq? p1200 (quote any)) (build-annotated79 #f (list (build-annotated79 #f (quote list)) x1192)) (build-annotated79 #f (list (build-annotated79 #f (quote $sc-dispatch)) x1192 (build-data82 #f p1200))))))))))))) (build-dispatch-call1172 (lambda (pvars1208 exp1209 y1210 r1211 mod1212) (let ((ids1213 (map car pvars1208)) (levels1214 (map cdr pvars1208))) (let ((labels1215 (gen-labels110 ids1213)) (new-vars1216 (map gen-var152 ids1213))) (build-annotated79 #f (list (build-annotated79 #f (quote apply)) (build-annotated79 #f (list (quote lambda) new-vars1216 (chi140 exp1209 (extend-env98 labels1215 (map (lambda (var1217 level1218) (cons (quote syntax) (cons var1217 level1218))) new-vars1216 (map cdr pvars1208)) r1211) (make-binding-wrap121 ids1213 labels1215 (quote (()))) mod1212))) y1210)))))) (convert-pattern1171 (lambda (pattern1219 keys1220) (let cvt1221 ((p1222 pattern1219) (n1223 0) (ids1224 (quote ()))) (if (id?104 p1222) (if (bound-id-member?131 p1222 keys1220) (values (vector (quote free-id) p1222) ids1224) (values (quote any) (cons (cons p1222 n1223) ids1224))) ((lambda (tmp1225) ((lambda (tmp1226) (if (if tmp1226 (apply (lambda (x1227 dots1228) (ellipsis?149 dots1228)) tmp1226) #f) (apply (lambda (x1229 dots1230) (call-with-values (lambda () (cvt1221 x1229 (fx+71 n1223 1) ids1224)) (lambda (p1231 ids1232) (values (if (eq? p1231 (quote any)) (quote each-any) (vector (quote each) p1231)) ids1232)))) tmp1226) ((lambda (tmp1233) (if tmp1233 (apply (lambda (x1234 y1235) (call-with-values (lambda () (cvt1221 y1235 n1223 ids1224)) (lambda (y1236 ids1237) (call-with-values (lambda () (cvt1221 x1234 n1223 ids1237)) (lambda (x1238 ids1239) (values (cons x1238 y1236) ids1239)))))) tmp1233) ((lambda (tmp1240) (if tmp1240 (apply (lambda () (values (quote ()) ids1224)) tmp1240) ((lambda (tmp1241) (if tmp1241 (apply (lambda (x1242) (call-with-values (lambda () (cvt1221 x1242 n1223 ids1224)) (lambda (p1244 ids1245) (values (vector (quote vector) p1244) ids1245)))) tmp1241) ((lambda (x1246) (values (vector (quote atom) (strip151 p1222 (quote (())))) ids1224)) tmp1225))) ($sc-dispatch tmp1225 (quote #(vector each-any)))))) ($sc-dispatch tmp1225 (quote ()))))) ($sc-dispatch tmp1225 (quote (any . any)))))) ($sc-dispatch tmp1225 (quote (any any))))) p1222)))))) (lambda (e1247 r1248 w1249 s1250 mod1251) (let ((e1252 (source-wrap133 e1247 w1249 s1250 mod1251))) ((lambda (tmp1253) ((lambda (tmp1254) (if tmp1254 (apply (lambda (_1255 val1256 key1257 m1258) (if (and-map (lambda (x1259) (and (id?104 x1259) (not (ellipsis?149 x1259)))) key1257) (let ((x1261 (gen-var152 (quote tmp)))) (build-annotated79 s1250 (list (build-annotated79 #f (list (quote lambda) (list x1261) (gen-syntax-case1174 (build-annotated79 #f x1261) key1257 m1258 r1248 mod1251))) (chi140 val1256 r1248 (quote (())) mod1251)))) (syntax-violation (quote syntax-case) "invalid literals list" e1252))) tmp1254) (syntax-violation #f "source expression failed to match any pattern" tmp1253))) ($sc-dispatch tmp1253 (quote (any any each-any . each-any))))) e1252))))) (set! sc-expand (lambda (x1265 . rest1264) (if (and (pair? x1265) (equal? (car x1265) noexpand69)) (cadr x1265) (let ((m1266 (if (null? rest1264) (quote e) (car rest1264))) (esew1267 (if (or (null? rest1264) (null? (cdr rest1264))) (quote (eval)) (cadr rest1264)))) (with-fluid* *mode*70 m1266 (lambda () (chi-top139 x1265 (quote ()) (quote ((top))) m1266 esew1267 (cons (quote hygiene) (module-name (current-module)))))))))) (set! identifier? (lambda (x1268) (nonsymbol-id?103 x1268))) (set! datum->syntax (lambda (id1269 datum1270) (make-syntax-object87 datum1270 (syntax-object-wrap90 id1269) #f))) (set! syntax->datum (lambda (x1271) (strip151 x1271 (quote (()))))) (set! generate-temporaries (lambda (ls1272) (begin (let ((x1273 ls1272)) (if (not (list? x1273)) (syntax-violation (quote generate-temporaries) "invalid argument" x1273))) (map (lambda (x1274) (wrap132 (gensym) (quote ((top))) #f)) ls1272)))) (set! free-identifier=? (lambda (x1275 y1276) (begin (let ((x1277 x1275)) (if (not (nonsymbol-id?103 x1277)) (syntax-violation (quote free-identifier=?) "invalid argument" x1277))) (let ((x1278 y1276)) (if (not (nonsymbol-id?103 x1278)) (syntax-violation (quote free-identifier=?) "invalid argument" x1278))) (free-id=?127 x1275 y1276)))) (set! bound-identifier=? (lambda (x1279 y1280) (begin (let ((x1281 x1279)) (if (not (nonsymbol-id?103 x1281)) (syntax-violation (quote bound-identifier=?) "invalid argument" x1281))) (let ((x1282 y1280)) (if (not (nonsymbol-id?103 x1282)) (syntax-violation (quote bound-identifier=?) "invalid argument" x1282))) (bound-id=?128 x1279 y1280)))) (set! syntax-violation (lambda (who1286 message1285 form1284 . subform1283) (begin (let ((x1287 who1286)) (if (not ((lambda (x1288) (or (not x1288) (string? x1288) (symbol? x1288))) x1287)) (syntax-violation (quote syntax-violation) "invalid argument" x1287))) (let ((x1289 message1285)) (if (not (string? x1289)) (syntax-violation (quote syntax-violation) "invalid argument" x1289))) (scm-error (quote syntax-error) (quote sc-expand) (string-append (if who1286 "~a: " "") "~a " (if (null? subform1283) "in ~a" "in subform `~s' of `~s'")) (let ((tail1290 (cons message1285 (map (lambda (x1291) (strip151 x1291 (quote (())))) (append subform1283 (list form1284)))))) (if who1286 (cons who1286 tail1290) tail1290)) #f)))) (letrec ((match1296 (lambda (e1297 p1298 w1299 r1300 mod1301) (cond ((not r1300) #f) ((eq? p1298 (quote any)) (cons (wrap132 e1297 w1299 mod1301) r1300)) ((syntax-object?88 e1297) (match*1295 (let ((e1302 (syntax-object-expression89 e1297))) (if (annotation? e1302) (annotation-expression e1302) e1302)) p1298 (join-wraps123 w1299 (syntax-object-wrap90 e1297)) r1300 (syntax-object-module91 e1297))) (else (match*1295 (let ((e1303 e1297)) (if (annotation? e1303) (annotation-expression e1303) e1303)) p1298 w1299 r1300 mod1301))))) (match*1295 (lambda (e1304 p1305 w1306 r1307 mod1308) (cond ((null? p1305) (and (null? e1304) r1307)) ((pair? p1305) (and (pair? e1304) (match1296 (car e1304) (car p1305) w1306 (match1296 (cdr e1304) (cdr p1305) w1306 r1307 mod1308) mod1308))) ((eq? p1305 (quote each-any)) (let ((l1309 (match-each-any1293 e1304 w1306 mod1308))) (and l1309 (cons l1309 r1307)))) (else (let ((t1310 (vector-ref p1305 0))) (if (memv t1310 (quote (each))) (if (null? e1304) (match-empty1294 (vector-ref p1305 1) r1307) (let ((l1311 (match-each1292 e1304 (vector-ref p1305 1) w1306 mod1308))) (and l1311 (let collect1312 ((l1313 l1311)) (if (null? (car l1313)) r1307 (cons (map car l1313) (collect1312 (map cdr l1313)))))))) (if (memv t1310 (quote (free-id))) (and (id?104 e1304) (free-id=?127 (wrap132 e1304 w1306 mod1308) (vector-ref p1305 1)) r1307) (if (memv t1310 (quote (atom))) (and (equal? (vector-ref p1305 1) (strip151 e1304 w1306)) r1307) (if (memv t1310 (quote (vector))) (and (vector? e1304) (match1296 (vector->list e1304) (vector-ref p1305 1) w1306 r1307 mod1308))))))))))) (match-empty1294 (lambda (p1314 r1315) (cond ((null? p1314) r1315) ((eq? p1314 (quote any)) (cons (quote ()) r1315)) ((pair? p1314) (match-empty1294 (car p1314) (match-empty1294 (cdr p1314) r1315))) ((eq? p1314 (quote each-any)) (cons (quote ()) r1315)) (else (let ((t1316 (vector-ref p1314 0))) (if (memv t1316 (quote (each))) (match-empty1294 (vector-ref p1314 1) r1315) (if (memv t1316 (quote (free-id atom))) r1315 (if (memv t1316 (quote (vector))) (match-empty1294 (vector-ref p1314 1) r1315))))))))) (match-each-any1293 (lambda (e1317 w1318 mod1319) (cond ((annotation? e1317) (match-each-any1293 (annotation-expression e1317) w1318 mod1319)) ((pair? e1317) (let ((l1320 (match-each-any1293 (cdr e1317) w1318 mod1319))) (and l1320 (cons (wrap132 (car e1317) w1318 mod1319) l1320)))) ((null? e1317) (quote ())) ((syntax-object?88 e1317) (match-each-any1293 (syntax-object-expression89 e1317) (join-wraps123 w1318 (syntax-object-wrap90 e1317)) mod1319)) (else #f)))) (match-each1292 (lambda (e1321 p1322 w1323 mod1324) (cond ((annotation? e1321) (match-each1292 (annotation-expression e1321) p1322 w1323 mod1324)) ((pair? e1321) (let ((first1325 (match1296 (car e1321) p1322 w1323 (quote ()) mod1324))) (and first1325 (let ((rest1326 (match-each1292 (cdr e1321) p1322 w1323 mod1324))) (and rest1326 (cons first1325 rest1326)))))) ((null? e1321) (quote ())) ((syntax-object?88 e1321) (match-each1292 (syntax-object-expression89 e1321) p1322 (join-wraps123 w1323 (syntax-object-wrap90 e1321)) (syntax-object-module91 e1321))) (else #f))))) (set! $sc-dispatch (lambda (e1327 p1328) (cond ((eq? p1328 (quote any)) (list e1327)) ((syntax-object?88 e1327) (match*1295 (let ((e1329 (syntax-object-expression89 e1327))) (if (annotation? e1329) (annotation-expression e1329) e1329)) p1328 (syntax-object-wrap90 e1327) (quote ()) (syntax-object-module91 e1327))) (else (match*1295 (let ((e1330 e1327)) (if (annotation? e1330) (annotation-expression e1330) e1330)) p1328 (quote (())) (quote ()) #f)))))))))
(define with-syntax (make-syncase-macro (quote macro) (lambda (x1331) ((lambda (tmp1332) ((lambda (tmp1333) (if tmp1333 (apply (lambda (_1334 e11335 e21336) (cons (quote #(syntax-object begin ((top) #(ribcage #(_ e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11335 e21336))) tmp1333) ((lambda (tmp1338) (if tmp1338 (apply (lambda (_1339 out1340 in1341 e11342 e21343) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in1341 (quote ()) (list out1340 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11342 e21343))))) tmp1338) ((lambda (tmp1345) (if tmp1345 (apply (lambda (_1346 out1347 in1348 e11349 e21350) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object list ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in1348) (quote ()) (list out1347 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11349 e21350))))) tmp1345) (syntax-violation #f "source expression failed to match any pattern" tmp1332))) ($sc-dispatch tmp1332 (quote (any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp1332 (quote (any ((any any)) any . each-any)))))) ($sc-dispatch tmp1332 (quote (any () any . each-any))))) x1331))))
(define syntax-rules (make-syncase-macro (quote macro) (lambda (x1354) ((lambda (tmp1355) ((lambda (tmp1356) (if tmp1356 (apply (lambda (_1357 k1358 keyword1359 pattern1360 template1361) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (cons (quote #(syntax-object syntax-case ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons k1358 (map (lambda (tmp1364 tmp1363) (list (cons (quote #(syntax-object dummy ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp1363) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp1364))) template1361 pattern1360)))))) tmp1356) (syntax-violation #f "source expression failed to match any pattern" tmp1355))) ($sc-dispatch tmp1355 (quote (any each-any . #(each ((any . any) any))))))) x1354))))
(define let* (make-extended-syncase-macro (module-ref (current-module) (quote let*)) (quote macro) (lambda (x1365) ((lambda (tmp1366) ((lambda (tmp1367) (if (if tmp1367 (apply (lambda (let*1368 x1369 v1370 e11371 e21372) (and-map identifier? x1369)) tmp1367) #f) (apply (lambda (let*1374 x1375 v1376 e11377 e21378) (let f1379 ((bindings1380 (map list x1375 v1376))) (if (null? bindings1380) (cons (quote #(syntax-object let ((top) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote ()) (cons e11377 e21378))) ((lambda (tmp1384) ((lambda (tmp1385) (if tmp1385 (apply (lambda (body1386 binding1387) (list (quote #(syntax-object let ((top) #(ribcage #(body binding) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list binding1387) body1386)) tmp1385) (syntax-violation #f "source expression failed to match any pattern" tmp1384))) ($sc-dispatch tmp1384 (quote (any any))))) (list (f1379 (cdr bindings1380)) (car bindings1380)))))) tmp1367) (syntax-violation #f "source expression failed to match any pattern" tmp1366))) ($sc-dispatch tmp1366 (quote (any #(each (any any)) any . each-any))))) x1365))))
(define do (make-extended-syncase-macro (module-ref (current-module) (quote do)) (quote macro) (lambda (orig-x1388) ((lambda (tmp1389) ((lambda (tmp1390) (if tmp1390 (apply (lambda (_1391 var1392 init1393 step1394 e01395 e11396 c1397) ((lambda (tmp1398) ((lambda (tmp1399) (if tmp1399 (apply (lambda (step1400) ((lambda (tmp1401) ((lambda (tmp1402) (if tmp1402 (apply (lambda () (list (quote #(syntax-object let ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var1392 init1393) (list (quote #(syntax-object if ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object not ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e01395) (cons (quote #(syntax-object begin ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c1397 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step1400))))))) tmp1402) ((lambda (tmp1407) (if tmp1407 (apply (lambda (e11408 e21409) (list (quote #(syntax-object let ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var1392 init1393) (list (quote #(syntax-object if ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e01395 (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (cons e11408 e21409)) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c1397 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step1400))))))) tmp1407) (syntax-violation #f "source expression failed to match any pattern" tmp1401))) ($sc-dispatch tmp1401 (quote (any . each-any)))))) ($sc-dispatch tmp1401 (quote ())))) e11396)) tmp1399) (syntax-violation #f "source expression failed to match any pattern" tmp1398))) ($sc-dispatch tmp1398 (quote each-any)))) (map (lambda (v1416 s1417) ((lambda (tmp1418) ((lambda (tmp1419) (if tmp1419 (apply (lambda () v1416) tmp1419) ((lambda (tmp1420) (if tmp1420 (apply (lambda (e1421) e1421) tmp1420) ((lambda (_1422) (syntax-violation (quote do) "bad step expression" orig-x1388 s1417)) tmp1418))) ($sc-dispatch tmp1418 (quote (any)))))) ($sc-dispatch tmp1418 (quote ())))) s1417)) var1392 step1394))) tmp1390) (syntax-violation #f "source expression failed to match any pattern" tmp1389))) ($sc-dispatch tmp1389 (quote (any #(each (any any . any)) (any . each-any) . each-any))))) orig-x1388))))
(define quasiquote (make-extended-syncase-macro (module-ref (current-module) (quote quasiquote)) (quote macro) (letrec ((quasicons1425 (lambda (x1429 y1430) ((lambda (tmp1431) ((lambda (tmp1432) (if tmp1432 (apply (lambda (x1433 y1434) ((lambda (tmp1435) ((lambda (tmp1436) (if tmp1436 (apply (lambda (dy1437) ((lambda (tmp1438) ((lambda (tmp1439) (if tmp1439 (apply (lambda (dx1440) (list (quote #(syntax-object quote ((top) #(ribcage #(dx) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons dx1440 dy1437))) tmp1439) ((lambda (_1441) (if (null? dy1437) (list (quote #(syntax-object list ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1433) (list (quote #(syntax-object cons ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1433 y1434))) tmp1438))) ($sc-dispatch tmp1438 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) x1433)) tmp1436) ((lambda (tmp1442) (if tmp1442 (apply (lambda (stuff1443) (cons (quote #(syntax-object list ((top) #(ribcage #(stuff) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons x1433 stuff1443))) tmp1442) ((lambda (else1444) (list (quote #(syntax-object cons ((top) #(ribcage #(else) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1433 y1434)) tmp1435))) ($sc-dispatch tmp1435 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . any)))))) ($sc-dispatch tmp1435 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) y1434)) tmp1432) (syntax-violation #f "source expression failed to match any pattern" tmp1431))) ($sc-dispatch tmp1431 (quote (any any))))) (list x1429 y1430)))) (quasiappend1426 (lambda (x1445 y1446) ((lambda (tmp1447) ((lambda (tmp1448) (if tmp1448 (apply (lambda (x1449 y1450) ((lambda (tmp1451) ((lambda (tmp1452) (if tmp1452 (apply (lambda () x1449) tmp1452) ((lambda (_1453) (list (quote #(syntax-object append ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1449 y1450)) tmp1451))) ($sc-dispatch tmp1451 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) ()))))) y1450)) tmp1448) (syntax-violation #f "source expression failed to match any pattern" tmp1447))) ($sc-dispatch tmp1447 (quote (any any))))) (list x1445 y1446)))) (quasivector1427 (lambda (x1454) ((lambda (tmp1455) ((lambda (x1456) ((lambda (tmp1457) ((lambda (tmp1458) (if tmp1458 (apply (lambda (x1459) (list (quote #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (list->vector x1459))) tmp1458) ((lambda (tmp1461) (if tmp1461 (apply (lambda (x1462) (cons (quote #(syntax-object vector ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1462)) tmp1461) ((lambda (_1464) (list (quote #(syntax-object list->vector ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1456)) tmp1457))) ($sc-dispatch tmp1457 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . each-any)))))) ($sc-dispatch tmp1457 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) each-any))))) x1456)) tmp1455)) x1454))) (quasi1428 (lambda (p1465 lev1466) ((lambda (tmp1467) ((lambda (tmp1468) (if tmp1468 (apply (lambda (p1469) (if (= lev1466 0) p1469 (quasicons1425 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1428 (list p1469) (- lev1466 1))))) tmp1468) ((lambda (tmp1470) (if tmp1470 (apply (lambda (p1471 q1472) (if (= lev1466 0) (quasiappend1426 p1471 (quasi1428 q1472 lev1466)) (quasicons1425 (quasicons1425 (quote (#(syntax-object quote ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote-splicing ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1428 (list p1471) (- lev1466 1))) (quasi1428 q1472 lev1466)))) tmp1470) ((lambda (tmp1473) (if tmp1473 (apply (lambda (p1474) (quasicons1425 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object quasiquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1428 (list p1474) (+ lev1466 1)))) tmp1473) ((lambda (tmp1475) (if tmp1475 (apply (lambda (p1476 q1477) (quasicons1425 (quasi1428 p1476 lev1466) (quasi1428 q1477 lev1466))) tmp1475) ((lambda (tmp1478) (if tmp1478 (apply (lambda (x1479) (quasivector1427 (quasi1428 x1479 lev1466))) tmp1478) ((lambda (p1481) (list (quote #(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) p1481)) tmp1467))) ($sc-dispatch tmp1467 (quote #(vector each-any)))))) ($sc-dispatch tmp1467 (quote (any . any)))))) ($sc-dispatch tmp1467 (quote (#(free-id #(syntax-object quasiquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any)))))) ($sc-dispatch tmp1467 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any) . any)))))) ($sc-dispatch tmp1467 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) p1465)))) (lambda (x1482) ((lambda (tmp1483) ((lambda (tmp1484) (if tmp1484 (apply (lambda (_1485 e1486) (quasi1428 e1486 0)) tmp1484) (syntax-violation #f "source expression failed to match any pattern" tmp1483))) ($sc-dispatch tmp1483 (quote (any any))))) x1482)))))
(define include (make-syncase-macro (quote macro) (lambda (x1487) (letrec ((read-file1488 (lambda (fn1489 k1490) (let ((p1491 (open-input-file fn1489))) (let f1492 ((x1493 (read p1491))) (if (eof-object? x1493) (begin (close-input-port p1491) (quote ())) (cons (datum->syntax k1490 x1493) (f1492 (read p1491))))))))) ((lambda (tmp1494) ((lambda (tmp1495) (if tmp1495 (apply (lambda (k1496 filename1497) (let ((fn1498 (syntax->datum filename1497))) ((lambda (tmp1499) ((lambda (tmp1500) (if tmp1500 (apply (lambda (exp1501) (cons (quote #(syntax-object begin ((top) #(ribcage #(exp) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(fn) #((top)) #("i")) #(ribcage #(k filename) #((top) (top)) #("i" "i")) #(ribcage (read-file) ((top)) ("i")) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) exp1501)) tmp1500) (syntax-violation #f "source expression failed to match any pattern" tmp1499))) ($sc-dispatch tmp1499 (quote each-any)))) (read-file1488 fn1498 k1496)))) tmp1495) (syntax-violation #f "source expression failed to match any pattern" tmp1494))) ($sc-dispatch tmp1494 (quote (any any))))) x1487)))))
(define unquote (make-syncase-macro (quote macro) (lambda (x1503) ((lambda (tmp1504) ((lambda (tmp1505) (if tmp1505 (apply (lambda (_1506 e1507) (syntax-violation (quote unquote) "expression not valid outside of quasiquote" x1503)) tmp1505) (syntax-violation #f "source expression failed to match any pattern" tmp1504))) ($sc-dispatch tmp1504 (quote (any any))))) x1503))))
(define unquote-splicing (make-syncase-macro (quote macro) (lambda (x1508) ((lambda (tmp1509) ((lambda (tmp1510) (if tmp1510 (apply (lambda (_1511 e1512) (syntax-violation (quote unquote-splicing) "expression not valid outside of quasiquote" x1508)) tmp1510) (syntax-violation #f "source expression failed to match any pattern" tmp1509))) ($sc-dispatch tmp1509 (quote (any any))))) x1508))))
(define case (make-extended-syncase-macro (module-ref (current-module) (quote case)) (quote macro) (lambda (x1513) ((lambda (tmp1514) ((lambda (tmp1515) (if tmp1515 (apply (lambda (_1516 e1517 m11518 m21519) ((lambda (tmp1520) ((lambda (body1521) (list (quote #(syntax-object let ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (list (quote #(syntax-object t ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e1517)) body1521)) tmp1520)) (let f1522 ((clause1523 m11518) (clauses1524 m21519)) (if (null? clauses1524) ((lambda (tmp1526) ((lambda (tmp1527) (if tmp1527 (apply (lambda (e11528 e21529) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11528 e21529))) tmp1527) ((lambda (tmp1531) (if tmp1531 (apply (lambda (k1532 e11533 e21534) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k1532)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11533 e21534)))) tmp1531) ((lambda (_1537) (syntax-violation (quote case) "bad clause" x1513 clause1523)) tmp1526))) ($sc-dispatch tmp1526 (quote (each-any any . each-any)))))) ($sc-dispatch tmp1526 (quote (#(free-id #(syntax-object else ((top) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) any . each-any))))) clause1523) ((lambda (tmp1538) ((lambda (rest1539) ((lambda (tmp1540) ((lambda (tmp1541) (if tmp1541 (apply (lambda (k1542 e11543 e21544) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k1542)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11543 e21544)) rest1539)) tmp1541) ((lambda (_1547) (syntax-violation (quote case) "bad clause" x1513 clause1523)) tmp1540))) ($sc-dispatch tmp1540 (quote (each-any any . each-any))))) clause1523)) tmp1538)) (f1522 (car clauses1524) (cdr clauses1524))))))) tmp1515) (syntax-violation #f "source expression failed to match any pattern" tmp1514))) ($sc-dispatch tmp1514 (quote (any any any . each-any))))) x1513))))
(define identifier-syntax (make-syncase-macro (quote macro) (lambda (x1548) ((lambda (tmp1549) ((lambda (tmp1550) (if tmp1550 (apply (lambda (_1551 e1552) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote ()) (list (quote #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object identifier? ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) (#(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e1552)) (list (cons _1551 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e1552 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))))))))) tmp1550) (syntax-violation #f "source expression failed to match any pattern" tmp1549))) ($sc-dispatch tmp1549 (quote (any any))))) x1548))))
