(eval-when (compile) (set-current-module (resolve-module (quote (guile)))))
(void)
(letrec ((lambda-var-list1262 (lambda (vars1467) (let lvl1468 ((vars1469 vars1467) (ls1470 (quote ())) (w1471 (quote (())))) (cond ((pair? vars1469) (lvl1468 (cdr vars1469) (cons (wrap1241 (car vars1469) w1471 #f) ls1470) w1471)) ((id?1213 vars1469) (cons (wrap1241 vars1469 w1471 #f) ls1470)) ((null? vars1469) ls1470) ((syntax-object?1197 vars1469) (lvl1468 (syntax-object-expression1198 vars1469) ls1470 (join-wraps1232 w1471 (syntax-object-wrap1199 vars1469)))) ((annotation? vars1469) (lvl1468 (annotation-expression vars1469) ls1470 w1471)) (else (cons vars1469 ls1470)))))) (gen-var1261 (lambda (id1472) (let ((id1473 (if (syntax-object?1197 id1472) (syntax-object-expression1198 id1472) id1472))) (if (annotation? id1473) (build-annotated1190 (annotation-source id1473) (gensym (symbol->string (annotation-expression id1473)))) (build-annotated1190 #f (gensym (symbol->string id1473))))))) (strip1260 (lambda (x1474 w1475) (if (memq (quote top) (wrap-marks1216 w1475)) (if (or (annotation? x1474) (and (pair? x1474) (annotation? (car x1474)))) (strip-annotation1259 x1474 #f) x1474) (let f1476 ((x1477 x1474)) (cond ((syntax-object?1197 x1477) (strip1260 (syntax-object-expression1198 x1477) (syntax-object-wrap1199 x1477))) ((pair? x1477) (let ((a1478 (f1476 (car x1477))) (d1479 (f1476 (cdr x1477)))) (if (and (eq? a1478 (car x1477)) (eq? d1479 (cdr x1477))) x1477 (cons a1478 d1479)))) ((vector? x1477) (let ((old1480 (vector->list x1477))) (let ((new1481 (map f1476 old1480))) (if (andmap eq? old1480 new1481) x1477 (list->vector new1481))))) (else x1477)))))) (strip-annotation1259 (lambda (x1482 parent1483) (cond ((pair? x1482) (let ((new1484 (cons #f #f))) (begin (if parent1483 (set-annotation-stripped! parent1483 new1484)) (set-car! new1484 (strip-annotation1259 (car x1482) #f)) (set-cdr! new1484 (strip-annotation1259 (cdr x1482) #f)) new1484))) ((annotation? x1482) (or (annotation-stripped x1482) (strip-annotation1259 (annotation-expression x1482) x1482))) ((vector? x1482) (let ((new1485 (make-vector (vector-length x1482)))) (begin (if parent1483 (set-annotation-stripped! parent1483 new1485)) (let loop1486 ((i1487 (- (vector-length x1482) 1))) (unless (fx<1183 i1487 0) (vector-set! new1485 i1487 (strip-annotation1259 (vector-ref x1482 i1487) #f)) (loop1486 (fx-1181 i1487 1)))) new1485))) (else x1482)))) (ellipsis?1258 (lambda (x1488) (and (nonsymbol-id?1212 x1488) (free-id=?1236 x1488 (quote #(syntax-object ... ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (hygiene guile))))))) (chi-void1257 (lambda () (build-annotated1190 #f (list (build-annotated1190 #f (quote void)))))) (eval-local-transformer1256 (lambda (expanded1489 mod1490) (let ((p1491 (local-eval-hook1185 expanded1489 mod1490))) (if (procedure? p1491) p1491 (syntax-violation #f "nonprocedure transformer" p1491))))) (chi-local-syntax1255 (lambda (rec?1492 e1493 r1494 w1495 s1496 mod1497 k1498) ((lambda (tmp1499) ((lambda (tmp1500) (if tmp1500 (apply (lambda (_1501 id1502 val1503 e11504 e21505) (let ((ids1506 id1502)) (if (not (valid-bound-ids?1238 ids1506)) (syntax-violation #f "duplicate bound keyword" e1493) (let ((labels1508 (gen-labels1219 ids1506))) (let ((new-w1509 (make-binding-wrap1230 ids1506 labels1508 w1495))) (k1498 (cons e11504 e21505) (extend-env1207 labels1508 (let ((w1511 (if rec?1492 new-w1509 w1495)) (trans-r1512 (macros-only-env1209 r1494))) (map (lambda (x1513) (cons (quote macro) (eval-local-transformer1256 (chi1249 x1513 trans-r1512 w1511 mod1497) mod1497))) val1503)) r1494) new-w1509 s1496 mod1497)))))) tmp1500) ((lambda (_1515) (syntax-violation #f "bad local syntax definition" (source-wrap1242 e1493 w1495 s1496 mod1497))) tmp1499))) (syntax-dispatch tmp1499 (quote (any #(each (any any)) any . each-any))))) e1493))) (chi-lambda-clause1254 (lambda (e1516 docstring1517 c1518 r1519 w1520 mod1521 k1522) ((lambda (tmp1523) ((lambda (tmp1524) (if (if tmp1524 (apply (lambda (args1525 doc1526 e11527 e21528) (and (string? (syntax-object->datum doc1526)) (not docstring1517))) tmp1524) #f) (apply (lambda (args1529 doc1530 e11531 e21532) (chi-lambda-clause1254 e1516 doc1530 (cons args1529 (cons e11531 e21532)) r1519 w1520 mod1521 k1522)) tmp1524) ((lambda (tmp1534) (if tmp1534 (apply (lambda (id1535 e11536 e21537) (let ((ids1538 id1535)) (if (not (valid-bound-ids?1238 ids1538)) (syntax-violation (quote lambda) "invalid parameter list" e1516) (let ((labels1540 (gen-labels1219 ids1538)) (new-vars1541 (map gen-var1261 ids1538))) (k1522 new-vars1541 docstring1517 (chi-body1253 (cons e11536 e21537) e1516 (extend-var-env1208 labels1540 new-vars1541 r1519) (make-binding-wrap1230 ids1538 labels1540 w1520) mod1521)))))) tmp1534) ((lambda (tmp1543) (if tmp1543 (apply (lambda (ids1544 e11545 e21546) (let ((old-ids1547 (lambda-var-list1262 ids1544))) (if (not (valid-bound-ids?1238 old-ids1547)) (syntax-violation (quote lambda) "invalid parameter list" e1516) (let ((labels1548 (gen-labels1219 old-ids1547)) (new-vars1549 (map gen-var1261 old-ids1547))) (k1522 (let f1550 ((ls11551 (cdr new-vars1549)) (ls21552 (car new-vars1549))) (if (null? ls11551) ls21552 (f1550 (cdr ls11551) (cons (car ls11551) ls21552)))) docstring1517 (chi-body1253 (cons e11545 e21546) e1516 (extend-var-env1208 labels1548 new-vars1549 r1519) (make-binding-wrap1230 old-ids1547 labels1548 w1520) mod1521)))))) tmp1543) ((lambda (_1554) (syntax-violation (quote lambda) "bad lambda" e1516)) tmp1523))) (syntax-dispatch tmp1523 (quote (any any . each-any)))))) (syntax-dispatch tmp1523 (quote (each-any any . each-any)))))) (syntax-dispatch tmp1523 (quote (any any any . each-any))))) c1518))) (chi-body1253 (lambda (body1555 outer-form1556 r1557 w1558 mod1559) (let ((r1560 (cons (quote ("placeholder" placeholder)) r1557))) (let ((ribcage1561 (make-ribcage1220 (quote ()) (quote ()) (quote ())))) (let ((w1562 (make-wrap1215 (wrap-marks1216 w1558) (cons ribcage1561 (wrap-subst1217 w1558))))) (let parse1563 ((body1564 (map (lambda (x1570) (cons r1560 (wrap1241 x1570 w1562 mod1559))) body1555)) (ids1565 (quote ())) (labels1566 (quote ())) (vars1567 (quote ())) (vals1568 (quote ())) (bindings1569 (quote ()))) (if (null? body1564) (syntax-violation #f "no expressions in body" outer-form1556) (let ((e1571 (cdar body1564)) (er1572 (caar body1564))) (call-with-values (lambda () (syntax-type1247 e1571 er1572 (quote (())) #f ribcage1561 mod1559)) (lambda (type1573 value1574 e1575 w1576 s1577 mod1578) (let ((t1579 type1573)) (if (memv t1579 (quote (define-form))) (let ((id1580 (wrap1241 value1574 w1576 mod1578)) (label1581 (gen-label1218))) (let ((var1582 (gen-var1261 id1580))) (begin (extend-ribcage!1229 ribcage1561 id1580 label1581) (parse1563 (cdr body1564) (cons id1580 ids1565) (cons label1581 labels1566) (cons var1582 vars1567) (cons (cons er1572 (wrap1241 e1575 w1576 mod1578)) vals1568) (cons (cons (quote lexical) var1582) bindings1569))))) (if (memv t1579 (quote (define-syntax-form))) (let ((id1583 (wrap1241 value1574 w1576 mod1578)) (label1584 (gen-label1218))) (begin (extend-ribcage!1229 ribcage1561 id1583 label1584) (parse1563 (cdr body1564) (cons id1583 ids1565) (cons label1584 labels1566) vars1567 vals1568 (cons (cons (quote macro) (cons er1572 (wrap1241 e1575 w1576 mod1578))) bindings1569)))) (if (memv t1579 (quote (begin-form))) ((lambda (tmp1585) ((lambda (tmp1586) (if tmp1586 (apply (lambda (_1587 e11588) (parse1563 (let f1589 ((forms1590 e11588)) (if (null? forms1590) (cdr body1564) (cons (cons er1572 (wrap1241 (car forms1590) w1576 mod1578)) (f1589 (cdr forms1590))))) ids1565 labels1566 vars1567 vals1568 bindings1569)) tmp1586) (syntax-violation #f "source expression failed to match any pattern" tmp1585))) (syntax-dispatch tmp1585 (quote (any . each-any))))) e1575) (if (memv t1579 (quote (local-syntax-form))) (chi-local-syntax1255 value1574 e1575 er1572 w1576 s1577 mod1578 (lambda (forms1592 er1593 w1594 s1595 mod1596) (parse1563 (let f1597 ((forms1598 forms1592)) (if (null? forms1598) (cdr body1564) (cons (cons er1593 (wrap1241 (car forms1598) w1594 mod1596)) (f1597 (cdr forms1598))))) ids1565 labels1566 vars1567 vals1568 bindings1569))) (if (null? ids1565) (build-sequence1192 #f (map (lambda (x1599) (chi1249 (cdr x1599) (car x1599) (quote (())) mod1578)) (cons (cons er1572 (source-wrap1242 e1575 w1576 s1577 mod1578)) (cdr body1564)))) (begin (if (not (valid-bound-ids?1238 ids1565)) (syntax-violation #f "invalid or duplicate identifier in definition" outer-form1556)) (let loop1600 ((bs1601 bindings1569) (er-cache1602 #f) (r-cache1603 #f)) (if (not (null? bs1601)) (let ((b1604 (car bs1601))) (if (eq? (car b1604) (quote macro)) (let ((er1605 (cadr b1604))) (let ((r-cache1606 (if (eq? er1605 er-cache1602) r-cache1603 (macros-only-env1209 er1605)))) (begin (set-cdr! b1604 (eval-local-transformer1256 (chi1249 (cddr b1604) r-cache1606 (quote (())) mod1578) mod1578)) (loop1600 (cdr bs1601) er1605 r-cache1606)))) (loop1600 (cdr bs1601) er-cache1602 r-cache1603))))) (set-cdr! r1560 (extend-env1207 labels1566 bindings1569 (cdr r1560))) (build-letrec1195 #f vars1567 (map (lambda (x1607) (chi1249 (cdr x1607) (car x1607) (quote (())) mod1578)) vals1568) (build-sequence1192 #f (map (lambda (x1608) (chi1249 (cdr x1608) (car x1608) (quote (())) mod1578)) (cons (cons er1572 (source-wrap1242 e1575 w1576 s1577 mod1578)) (cdr body1564)))))))))))))))))))))) (chi-macro1252 (lambda (p1609 e1610 r1611 w1612 rib1613 mod1614) (letrec ((rebuild-macro-output1615 (lambda (x1616 m1617) (cond ((pair? x1616) (cons (rebuild-macro-output1615 (car x1616) m1617) (rebuild-macro-output1615 (cdr x1616) m1617))) ((syntax-object?1197 x1616) (let ((w1618 (syntax-object-wrap1199 x1616))) (let ((ms1619 (wrap-marks1216 w1618)) (s1620 (wrap-subst1217 w1618))) (if (and (pair? ms1619) (eq? (car ms1619) #f)) (make-syntax-object1196 (syntax-object-expression1198 x1616) (make-wrap1215 (cdr ms1619) (if rib1613 (cons rib1613 (cdr s1620)) (cdr s1620))) (syntax-object-module1200 x1616)) (make-syntax-object1196 (syntax-object-expression1198 x1616) (make-wrap1215 (cons m1617 ms1619) (if rib1613 (cons rib1613 (cons (quote shift) s1620)) (cons (quote shift) s1620))) (let ((pmod1621 (procedure-module p1609))) (if pmod1621 (cons (quote hygiene) (module-name pmod1621)) (quote (hygiene guile))))))))) ((vector? x1616) (let ((n1622 (vector-length x1616))) (let ((v1623 (make-vector n1622))) (let doloop1624 ((i1625 0)) (if (fx=1182 i1625 n1622) v1623 (begin (vector-set! v1623 i1625 (rebuild-macro-output1615 (vector-ref x1616 i1625) m1617)) (doloop1624 (fx+1180 i1625 1)))))))) ((symbol? x1616) (syntax-violation #f "encountered raw symbol in macro output" (source-wrap1242 e1610 w1612 s mod1614) x1616)) (else x1616))))) (rebuild-macro-output1615 (p1609 (wrap1241 e1610 (anti-mark1228 w1612) mod1614)) (string #\m))))) (chi-application1251 (lambda (x1626 e1627 r1628 w1629 s1630 mod1631) ((lambda (tmp1632) ((lambda (tmp1633) (if tmp1633 (apply (lambda (e01634 e11635) (build-annotated1190 s1630 (cons x1626 (map (lambda (e1636) (chi1249 e1636 r1628 w1629 mod1631)) e11635)))) tmp1633) (syntax-violation #f "source expression failed to match any pattern" tmp1632))) (syntax-dispatch tmp1632 (quote (any . each-any))))) e1627))) (chi-expr1250 (lambda (type1638 value1639 e1640 r1641 w1642 s1643 mod1644) (let ((t1645 type1638)) (if (memv t1645 (quote (lexical))) (build-annotated1190 s1643 value1639) (if (memv t1645 (quote (core external-macro))) (value1639 e1640 r1641 w1642 s1643 mod1644) (if (memv t1645 (quote (module-ref))) (call-with-values (lambda () (value1639 e1640)) (lambda (id1646 mod1647) (build-annotated1190 s1643 (if mod1647 (make-module-ref (cdr mod1647) id1646 (car mod1647)) (make-module-ref mod1647 id1646 (quote bare)))))) (if (memv t1645 (quote (lexical-call))) (chi-application1251 (build-annotated1190 (source-annotation1204 (car e1640)) value1639) e1640 r1641 w1642 s1643 mod1644) (if (memv t1645 (quote (global-call))) (chi-application1251 (build-annotated1190 (source-annotation1204 (car e1640)) (if (if (syntax-object?1197 (car e1640)) (syntax-object-module1200 (car e1640)) mod1644) (make-module-ref (cdr (if (syntax-object?1197 (car e1640)) (syntax-object-module1200 (car e1640)) mod1644)) value1639 (car (if (syntax-object?1197 (car e1640)) (syntax-object-module1200 (car e1640)) mod1644))) (make-module-ref (if (syntax-object?1197 (car e1640)) (syntax-object-module1200 (car e1640)) mod1644) value1639 (quote bare)))) e1640 r1641 w1642 s1643 mod1644) (if (memv t1645 (quote (constant))) (build-data1191 s1643 (strip1260 (source-wrap1242 e1640 w1642 s1643 mod1644) (quote (())))) (if (memv t1645 (quote (global))) (build-annotated1190 s1643 (if mod1644 (make-module-ref (cdr mod1644) value1639 (car mod1644)) (make-module-ref mod1644 value1639 (quote bare)))) (if (memv t1645 (quote (call))) (chi-application1251 (chi1249 (car e1640) r1641 w1642 mod1644) e1640 r1641 w1642 s1643 mod1644) (if (memv t1645 (quote (begin-form))) ((lambda (tmp1648) ((lambda (tmp1649) (if tmp1649 (apply (lambda (_1650 e11651 e21652) (chi-sequence1243 (cons e11651 e21652) r1641 w1642 s1643 mod1644)) tmp1649) (syntax-violation #f "source expression failed to match any pattern" tmp1648))) (syntax-dispatch tmp1648 (quote (any any . each-any))))) e1640) (if (memv t1645 (quote (local-syntax-form))) (chi-local-syntax1255 value1639 e1640 r1641 w1642 s1643 mod1644 chi-sequence1243) (if (memv t1645 (quote (eval-when-form))) ((lambda (tmp1654) ((lambda (tmp1655) (if tmp1655 (apply (lambda (_1656 x1657 e11658 e21659) (let ((when-list1660 (chi-when-list1246 e1640 x1657 w1642))) (if (memq (quote eval) when-list1660) (chi-sequence1243 (cons e11658 e21659) r1641 w1642 s1643 mod1644) (chi-void1257)))) tmp1655) (syntax-violation #f "source expression failed to match any pattern" tmp1654))) (syntax-dispatch tmp1654 (quote (any each-any any . each-any))))) e1640) (if (memv t1645 (quote (define-form define-syntax-form))) (syntax-violation #f "definition in expression context" e1640 (wrap1241 value1639 w1642 mod1644)) (if (memv t1645 (quote (syntax))) (syntax-violation #f "reference to pattern variable outside syntax form" (source-wrap1242 e1640 w1642 s1643 mod1644)) (if (memv t1645 (quote (displaced-lexical))) (syntax-violation #f (source-wrap1242 e1640 w1642 s1643 mod1644) "reference to identifier outside its scope") (syntax-violation #f "unexpected syntax" (source-wrap1242 e1640 w1642 s1643 mod1644))))))))))))))))))) (chi1249 (lambda (e1663 r1664 w1665 mod1666) (call-with-values (lambda () (syntax-type1247 e1663 r1664 w1665 #f #f mod1666)) (lambda (type1667 value1668 e1669 w1670 s1671 mod1672) (chi-expr1250 type1667 value1668 e1669 r1664 w1670 s1671 mod1672))))) (chi-top1248 (lambda (e1673 r1674 w1675 m1676 esew1677 mod1678) (call-with-values (lambda () (syntax-type1247 e1673 r1674 w1675 #f #f mod1678)) (lambda (type1686 value1687 e1688 w1689 s1690 mod1691) (let ((t1692 type1686)) (if (memv t1692 (quote (begin-form))) ((lambda (tmp1693) ((lambda (tmp1694) (if tmp1694 (apply (lambda (_1695) (chi-void1257)) tmp1694) ((lambda (tmp1696) (if tmp1696 (apply (lambda (_1697 e11698 e21699) (chi-top-sequence1244 (cons e11698 e21699) r1674 w1689 s1690 m1676 esew1677 mod1691)) tmp1696) (syntax-violation #f "source expression failed to match any pattern" tmp1693))) (syntax-dispatch tmp1693 (quote (any any . each-any)))))) (syntax-dispatch tmp1693 (quote (any))))) e1688) (if (memv t1692 (quote (local-syntax-form))) (chi-local-syntax1255 value1687 e1688 r1674 w1689 s1690 mod1691 (lambda (body1701 r1702 w1703 s1704 mod1705) (chi-top-sequence1244 body1701 r1702 w1703 s1704 m1676 esew1677 mod1705))) (if (memv t1692 (quote (eval-when-form))) ((lambda (tmp1706) ((lambda (tmp1707) (if tmp1707 (apply (lambda (_1708 x1709 e11710 e21711) (let ((when-list1712 (chi-when-list1246 e1688 x1709 w1689)) (body1713 (cons e11710 e21711))) (cond ((eq? m1676 (quote e)) (if (memq (quote eval) when-list1712) (chi-top-sequence1244 body1713 r1674 w1689 s1690 (quote e) (quote (eval)) mod1691) (chi-void1257))) ((memq (quote load) when-list1712) (if (or (memq (quote compile) when-list1712) (and (eq? m1676 (quote c&e)) (memq (quote eval) when-list1712))) (chi-top-sequence1244 body1713 r1674 w1689 s1690 (quote c&e) (quote (compile load)) mod1691) (if (memq m1676 (quote (c c&e))) (chi-top-sequence1244 body1713 r1674 w1689 s1690 (quote c) (quote (load)) mod1691) (chi-void1257)))) ((or (memq (quote compile) when-list1712) (and (eq? m1676 (quote c&e)) (memq (quote eval) when-list1712))) (top-level-eval-hook1184 (chi-top-sequence1244 body1713 r1674 w1689 s1690 (quote e) (quote (eval)) mod1691) mod1691) (chi-void1257)) (else (chi-void1257))))) tmp1707) (syntax-violation #f "source expression failed to match any pattern" tmp1706))) (syntax-dispatch tmp1706 (quote (any each-any any . each-any))))) e1688) (if (memv t1692 (quote (define-syntax-form))) (let ((n1716 (id-var-name1235 value1687 w1689)) (r1717 (macros-only-env1209 r1674))) (let ((t1718 m1676)) (if (memv t1718 (quote (c))) (if (memq (quote compile) esew1677) (let ((e1719 (chi-install-global1245 n1716 (chi1249 e1688 r1717 w1689 mod1691)))) (begin (top-level-eval-hook1184 e1719 mod1691) (if (memq (quote load) esew1677) e1719 (chi-void1257)))) (if (memq (quote load) esew1677) (chi-install-global1245 n1716 (chi1249 e1688 r1717 w1689 mod1691)) (chi-void1257))) (if (memv t1718 (quote (c&e))) (let ((e1720 (chi-install-global1245 n1716 (chi1249 e1688 r1717 w1689 mod1691)))) (begin (top-level-eval-hook1184 e1720 mod1691) e1720)) (begin (if (memq (quote eval) esew1677) (top-level-eval-hook1184 (chi-install-global1245 n1716 (chi1249 e1688 r1717 w1689 mod1691)) mod1691)) (chi-void1257)))))) (if (memv t1692 (quote (define-form))) (let ((n1721 (id-var-name1235 value1687 w1689))) (let ((type1722 (binding-type1205 (lookup1210 n1721 r1674 mod1691)))) (let ((t1723 type1722)) (if (memv t1723 (quote (global))) (let ((x1724 (build-annotated1190 s1690 (list (quote define) n1721 (chi1249 e1688 r1674 w1689 mod1691))))) (begin (if (eq? m1676 (quote c&e)) (top-level-eval-hook1184 x1724 mod1691)) x1724)) (if (memv t1723 (quote (displaced-lexical))) (syntax-violation #f "identifier out of context" e1688 (wrap1241 value1687 w1689 mod1691)) (if (memv t1723 (quote (core macro module-ref))) (begin (remove-global-definition-hook1188 n1721) (let ((x1725 (build-annotated1190 s1690 (list (quote define) n1721 (chi1249 e1688 r1674 w1689 mod1691))))) (begin (if (eq? m1676 (quote c&e)) (top-level-eval-hook1184 x1725 mod1691)) x1725))) (syntax-violation #f "cannot define keyword at top level" e1688 (wrap1241 value1687 w1689 mod1691)))))))) (let ((x1726 (chi-expr1250 type1686 value1687 e1688 r1674 w1689 s1690 mod1691))) (begin (if (eq? m1676 (quote c&e)) (top-level-eval-hook1184 x1726 mod1691)) x1726)))))))))))) (syntax-type1247 (lambda (e1727 r1728 w1729 s1730 rib1731 mod1732) (cond ((symbol? e1727) (let ((n1733 (id-var-name1235 e1727 w1729))) (let ((b1734 (lookup1210 n1733 r1728 mod1732))) (let ((type1735 (binding-type1205 b1734))) (let ((t1736 type1735)) (if (memv t1736 (quote (lexical))) (values type1735 (binding-value1206 b1734) e1727 w1729 s1730 mod1732) (if (memv t1736 (quote (global))) (values type1735 n1733 e1727 w1729 s1730 mod1732) (if (memv t1736 (quote (macro))) (syntax-type1247 (chi-macro1252 (binding-value1206 b1734) e1727 r1728 w1729 rib1731 mod1732) r1728 (quote (())) s1730 rib1731 mod1732) (values type1735 (binding-value1206 b1734) e1727 w1729 s1730 mod1732))))))))) ((pair? e1727) (let ((first1737 (car e1727))) (if (id?1213 first1737) (let ((n1738 (id-var-name1235 first1737 w1729))) (let ((b1739 (lookup1210 n1738 r1728 (or (and (syntax-object?1197 first1737) (syntax-object-module1200 first1737)) mod1732)))) (let ((type1740 (binding-type1205 b1739))) (let ((t1741 type1740)) (if (memv t1741 (quote (lexical))) (values (quote lexical-call) (binding-value1206 b1739) e1727 w1729 s1730 mod1732) (if (memv t1741 (quote (global))) (values (quote global-call) n1738 e1727 w1729 s1730 mod1732) (if (memv t1741 (quote (macro))) (syntax-type1247 (chi-macro1252 (binding-value1206 b1739) e1727 r1728 w1729 rib1731 mod1732) r1728 (quote (())) s1730 rib1731 mod1732) (if (memv t1741 (quote (core external-macro module-ref))) (values type1740 (binding-value1206 b1739) e1727 w1729 s1730 mod1732) (if (memv t1741 (quote (local-syntax))) (values (quote local-syntax-form) (binding-value1206 b1739) e1727 w1729 s1730 mod1732) (if (memv t1741 (quote (begin))) (values (quote begin-form) #f e1727 w1729 s1730 mod1732) (if (memv t1741 (quote (eval-when))) (values (quote eval-when-form) #f e1727 w1729 s1730 mod1732) (if (memv t1741 (quote (define))) ((lambda (tmp1742) ((lambda (tmp1743) (if (if tmp1743 (apply (lambda (_1744 name1745 val1746) (id?1213 name1745)) tmp1743) #f) (apply (lambda (_1747 name1748 val1749) (values (quote define-form) name1748 val1749 w1729 s1730 mod1732)) tmp1743) ((lambda (tmp1750) (if (if tmp1750 (apply (lambda (_1751 name1752 args1753 e11754 e21755) (and (id?1213 name1752) (valid-bound-ids?1238 (lambda-var-list1262 args1753)))) tmp1750) #f) (apply (lambda (_1756 name1757 args1758 e11759 e21760) (values (quote define-form) (wrap1241 name1757 w1729 mod1732) (cons (quote #(syntax-object lambda ((top) #(ribcage #(_ name args e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (hygiene guile))) (wrap1241 (cons args1758 (cons e11759 e21760)) w1729 mod1732)) (quote (())) s1730 mod1732)) tmp1750) ((lambda (tmp1762) (if (if tmp1762 (apply (lambda (_1763 name1764) (id?1213 name1764)) tmp1762) #f) (apply (lambda (_1765 name1766) (values (quote define-form) (wrap1241 name1766 w1729 mod1732) (quote (#(syntax-object void ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (hygiene guile)))) (quote (())) s1730 mod1732)) tmp1762) (syntax-violation #f "source expression failed to match any pattern" tmp1742))) (syntax-dispatch tmp1742 (quote (any any)))))) (syntax-dispatch tmp1742 (quote (any (any . any) any . each-any)))))) (syntax-dispatch tmp1742 (quote (any any any))))) e1727) (if (memv t1741 (quote (define-syntax))) ((lambda (tmp1767) ((lambda (tmp1768) (if (if tmp1768 (apply (lambda (_1769 name1770 val1771) (id?1213 name1770)) tmp1768) #f) (apply (lambda (_1772 name1773 val1774) (values (quote define-syntax-form) name1773 val1774 w1729 s1730 mod1732)) tmp1768) (syntax-violation #f "source expression failed to match any pattern" tmp1767))) (syntax-dispatch tmp1767 (quote (any any any))))) e1727) (values (quote call) #f e1727 w1729 s1730 mod1732)))))))))))))) (values (quote call) #f e1727 w1729 s1730 mod1732)))) ((syntax-object?1197 e1727) (syntax-type1247 (syntax-object-expression1198 e1727) r1728 (join-wraps1232 w1729 (syntax-object-wrap1199 e1727)) #f rib1731 (or (syntax-object-module1200 e1727) mod1732))) ((annotation? e1727) (syntax-type1247 (annotation-expression e1727) r1728 w1729 (annotation-source e1727) rib1731 mod1732)) ((self-evaluating? e1727) (values (quote constant) #f e1727 w1729 s1730 mod1732)) (else (values (quote other) #f e1727 w1729 s1730 mod1732))))) (chi-when-list1246 (lambda (e1775 when-list1776 w1777) (let f1778 ((when-list1779 when-list1776) (situations1780 (quote ()))) (if (null? when-list1779) situations1780 (f1778 (cdr when-list1779) (cons (let ((x1781 (car when-list1779))) (cond ((free-id=?1236 x1781 (quote #(syntax-object compile ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (hygiene guile)))) (quote compile)) ((free-id=?1236 x1781 (quote #(syntax-object load ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (hygiene guile)))) (quote load)) ((free-id=?1236 x1781 (quote #(syntax-object eval ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (hygiene guile)))) (quote eval)) (else (syntax-violation (quote eval-when) "invalid situation" e1775 (wrap1241 x1781 w1777 #f))))) situations1780)))))) (chi-install-global1245 (lambda (name1782 e1783) (build-annotated1190 #f (list (build-annotated1190 #f (quote install-global-transformer)) (build-data1191 #f name1782) e1783)))) (chi-top-sequence1244 (lambda (body1784 r1785 w1786 s1787 m1788 esew1789 mod1790) (build-sequence1192 s1787 (let dobody1791 ((body1792 body1784) (r1793 r1785) (w1794 w1786) (m1795 m1788) (esew1796 esew1789) (mod1797 mod1790)) (if (null? body1792) (quote ()) (let ((first1798 (chi-top1248 (car body1792) r1793 w1794 m1795 esew1796 mod1797))) (cons first1798 (dobody1791 (cdr body1792) r1793 w1794 m1795 esew1796 mod1797)))))))) (chi-sequence1243 (lambda (body1799 r1800 w1801 s1802 mod1803) (build-sequence1192 s1802 (let dobody1804 ((body1805 body1799) (r1806 r1800) (w1807 w1801) (mod1808 mod1803)) (if (null? body1805) (quote ()) (let ((first1809 (chi1249 (car body1805) r1806 w1807 mod1808))) (cons first1809 (dobody1804 (cdr body1805) r1806 w1807 mod1808)))))))) (source-wrap1242 (lambda (x1810 w1811 s1812 defmod1813) (wrap1241 (if s1812 (make-annotation x1810 s1812 #f) x1810) w1811 defmod1813))) (wrap1241 (lambda (x1814 w1815 defmod1816) (cond ((and (null? (wrap-marks1216 w1815)) (null? (wrap-subst1217 w1815))) x1814) ((syntax-object?1197 x1814) (make-syntax-object1196 (syntax-object-expression1198 x1814) (join-wraps1232 w1815 (syntax-object-wrap1199 x1814)) (syntax-object-module1200 x1814))) ((null? x1814) x1814) (else (make-syntax-object1196 x1814 w1815 defmod1816))))) (bound-id-member?1240 (lambda (x1817 list1818) (and (not (null? list1818)) (or (bound-id=?1237 x1817 (car list1818)) (bound-id-member?1240 x1817 (cdr list1818)))))) (distinct-bound-ids?1239 (lambda (ids1819) (let distinct?1820 ((ids1821 ids1819)) (or (null? ids1821) (and (not (bound-id-member?1240 (car ids1821) (cdr ids1821))) (distinct?1820 (cdr ids1821))))))) (valid-bound-ids?1238 (lambda (ids1822) (and (let all-ids?1823 ((ids1824 ids1822)) (or (null? ids1824) (and (id?1213 (car ids1824)) (all-ids?1823 (cdr ids1824))))) (distinct-bound-ids?1239 ids1822)))) (bound-id=?1237 (lambda (i1825 j1826) (if (and (syntax-object?1197 i1825) (syntax-object?1197 j1826)) (and (eq? (let ((e1827 (syntax-object-expression1198 i1825))) (if (annotation? e1827) (annotation-expression e1827) e1827)) (let ((e1828 (syntax-object-expression1198 j1826))) (if (annotation? e1828) (annotation-expression e1828) e1828))) (same-marks?1234 (wrap-marks1216 (syntax-object-wrap1199 i1825)) (wrap-marks1216 (syntax-object-wrap1199 j1826)))) (eq? (let ((e1829 i1825)) (if (annotation? e1829) (annotation-expression e1829) e1829)) (let ((e1830 j1826)) (if (annotation? e1830) (annotation-expression e1830) e1830)))))) (free-id=?1236 (lambda (i1831 j1832) (and (eq? (let ((x1833 i1831)) (let ((e1834 (if (syntax-object?1197 x1833) (syntax-object-expression1198 x1833) x1833))) (if (annotation? e1834) (annotation-expression e1834) e1834))) (let ((x1835 j1832)) (let ((e1836 (if (syntax-object?1197 x1835) (syntax-object-expression1198 x1835) x1835))) (if (annotation? e1836) (annotation-expression e1836) e1836)))) (eq? (id-var-name1235 i1831 (quote (()))) (id-var-name1235 j1832 (quote (()))))))) (id-var-name1235 (lambda (id1837 w1838) (letrec ((search-vector-rib1841 (lambda (sym1847 subst1848 marks1849 symnames1850 ribcage1851) (let ((n1852 (vector-length symnames1850))) (let f1853 ((i1854 0)) (cond ((fx=1182 i1854 n1852) (search1839 sym1847 (cdr subst1848) marks1849)) ((and (eq? (vector-ref symnames1850 i1854) sym1847) (same-marks?1234 marks1849 (vector-ref (ribcage-marks1223 ribcage1851) i1854))) (values (vector-ref (ribcage-labels1224 ribcage1851) i1854) marks1849)) (else (f1853 (fx+1180 i1854 1)))))))) (search-list-rib1840 (lambda (sym1855 subst1856 marks1857 symnames1858 ribcage1859) (let f1860 ((symnames1861 symnames1858) (i1862 0)) (cond ((null? symnames1861) (search1839 sym1855 (cdr subst1856) marks1857)) ((and (eq? (car symnames1861) sym1855) (same-marks?1234 marks1857 (list-ref (ribcage-marks1223 ribcage1859) i1862))) (values (list-ref (ribcage-labels1224 ribcage1859) i1862) marks1857)) (else (f1860 (cdr symnames1861) (fx+1180 i1862 1))))))) (search1839 (lambda (sym1863 subst1864 marks1865) (if (null? subst1864) (values #f marks1865) (let ((fst1866 (car subst1864))) (if (eq? fst1866 (quote shift)) (search1839 sym1863 (cdr subst1864) (cdr marks1865)) (let ((symnames1867 (ribcage-symnames1222 fst1866))) (if (vector? symnames1867) (search-vector-rib1841 sym1863 subst1864 marks1865 symnames1867 fst1866) (search-list-rib1840 sym1863 subst1864 marks1865 symnames1867 fst1866))))))))) (cond ((symbol? id1837) (or (call-with-values (lambda () (search1839 id1837 (wrap-subst1217 w1838) (wrap-marks1216 w1838))) (lambda (x1869 . ignore1868) x1869)) id1837)) ((syntax-object?1197 id1837) (let ((id1870 (let ((e1872 (syntax-object-expression1198 id1837))) (if (annotation? e1872) (annotation-expression e1872) e1872))) (w11871 (syntax-object-wrap1199 id1837))) (let ((marks1873 (join-marks1233 (wrap-marks1216 w1838) (wrap-marks1216 w11871)))) (call-with-values (lambda () (search1839 id1870 (wrap-subst1217 w1838) marks1873)) (lambda (new-id1874 marks1875) (or new-id1874 (call-with-values (lambda () (search1839 id1870 (wrap-subst1217 w11871) marks1875)) (lambda (x1877 . ignore1876) x1877)) id1870)))))) ((annotation? id1837) (let ((id1878 (let ((e1879 id1837)) (if (annotation? e1879) (annotation-expression e1879) e1879)))) (or (call-with-values (lambda () (search1839 id1878 (wrap-subst1217 w1838) (wrap-marks1216 w1838))) (lambda (x1881 . ignore1880) x1881)) id1878))) (else (error-hook1186 (quote id-var-name) "invalid id" id1837)))))) (same-marks?1234 (lambda (x1882 y1883) (or (eq? x1882 y1883) (and (not (null? x1882)) (not (null? y1883)) (eq? (car x1882) (car y1883)) (same-marks?1234 (cdr x1882) (cdr y1883)))))) (join-marks1233 (lambda (m11884 m21885) (smart-append1231 m11884 m21885))) (join-wraps1232 (lambda (w11886 w21887) (let ((m11888 (wrap-marks1216 w11886)) (s11889 (wrap-subst1217 w11886))) (if (null? m11888) (if (null? s11889) w21887 (make-wrap1215 (wrap-marks1216 w21887) (smart-append1231 s11889 (wrap-subst1217 w21887)))) (make-wrap1215 (smart-append1231 m11888 (wrap-marks1216 w21887)) (smart-append1231 s11889 (wrap-subst1217 w21887))))))) (smart-append1231 (lambda (m11890 m21891) (if (null? m21891) m11890 (append m11890 m21891)))) (make-binding-wrap1230 (lambda (ids1892 labels1893 w1894) (if (null? ids1892) w1894 (make-wrap1215 (wrap-marks1216 w1894) (cons (let ((labelvec1895 (list->vector labels1893))) (let ((n1896 (vector-length labelvec1895))) (let ((symnamevec1897 (make-vector n1896)) (marksvec1898 (make-vector n1896))) (begin (let f1899 ((ids1900 ids1892) (i1901 0)) (if (not (null? ids1900)) (call-with-values (lambda () (id-sym-name&marks1214 (car ids1900) w1894)) (lambda (symname1902 marks1903) (begin (vector-set! symnamevec1897 i1901 symname1902) (vector-set! marksvec1898 i1901 marks1903) (f1899 (cdr ids1900) (fx+1180 i1901 1))))))) (make-ribcage1220 symnamevec1897 marksvec1898 labelvec1895))))) (wrap-subst1217 w1894)))))) (extend-ribcage!1229 (lambda (ribcage1904 id1905 label1906) (begin (set-ribcage-symnames!1225 ribcage1904 (cons (let ((e1907 (syntax-object-expression1198 id1905))) (if (annotation? e1907) (annotation-expression e1907) e1907)) (ribcage-symnames1222 ribcage1904))) (set-ribcage-marks!1226 ribcage1904 (cons (wrap-marks1216 (syntax-object-wrap1199 id1905)) (ribcage-marks1223 ribcage1904))) (set-ribcage-labels!1227 ribcage1904 (cons label1906 (ribcage-labels1224 ribcage1904)))))) (anti-mark1228 (lambda (w1908) (make-wrap1215 (cons #f (wrap-marks1216 w1908)) (cons (quote shift) (wrap-subst1217 w1908))))) (set-ribcage-labels!1227 (lambda (x1909 update1910) (vector-set! x1909 3 update1910))) (set-ribcage-marks!1226 (lambda (x1911 update1912) (vector-set! x1911 2 update1912))) (set-ribcage-symnames!1225 (lambda (x1913 update1914) (vector-set! x1913 1 update1914))) (ribcage-labels1224 (lambda (x1915) (vector-ref x1915 3))) (ribcage-marks1223 (lambda (x1916) (vector-ref x1916 2))) (ribcage-symnames1222 (lambda (x1917) (vector-ref x1917 1))) (ribcage?1221 (lambda (x1918) (and (vector? x1918) (= (vector-length x1918) 4) (eq? (vector-ref x1918 0) (quote ribcage))))) (make-ribcage1220 (lambda (symnames1919 marks1920 labels1921) (vector (quote ribcage) symnames1919 marks1920 labels1921))) (gen-labels1219 (lambda (ls1922) (if (null? ls1922) (quote ()) (cons (gen-label1218) (gen-labels1219 (cdr ls1922)))))) (gen-label1218 (lambda () (string #\i))) (wrap-subst1217 cdr) (wrap-marks1216 car) (make-wrap1215 cons) (id-sym-name&marks1214 (lambda (x1923 w1924) (if (syntax-object?1197 x1923) (values (let ((e1925 (syntax-object-expression1198 x1923))) (if (annotation? e1925) (annotation-expression e1925) e1925)) (join-marks1233 (wrap-marks1216 w1924) (wrap-marks1216 (syntax-object-wrap1199 x1923)))) (values (let ((e1926 x1923)) (if (annotation? e1926) (annotation-expression e1926) e1926)) (wrap-marks1216 w1924))))) (id?1213 (lambda (x1927) (cond ((symbol? x1927) #t) ((syntax-object?1197 x1927) (symbol? (let ((e1928 (syntax-object-expression1198 x1927))) (if (annotation? e1928) (annotation-expression e1928) e1928)))) ((annotation? x1927) (symbol? (annotation-expression x1927))) (else #f)))) (nonsymbol-id?1212 (lambda (x1929) (and (syntax-object?1197 x1929) (symbol? (let ((e1930 (syntax-object-expression1198 x1929))) (if (annotation? e1930) (annotation-expression e1930) e1930)))))) (global-extend1211 (lambda (type1931 sym1932 val1933) (put-global-definition-hook1187 sym1932 type1931 val1933))) (lookup1210 (lambda (x1934 r1935 mod1936) (cond ((assq x1934 r1935) => cdr) ((symbol? x1934) (or (get-global-definition-hook1189 x1934 mod1936) (quote (global)))) (else (quote (displaced-lexical)))))) (macros-only-env1209 (lambda (r1937) (if (null? r1937) (quote ()) (let ((a1938 (car r1937))) (if (eq? (cadr a1938) (quote macro)) (cons a1938 (macros-only-env1209 (cdr r1937))) (macros-only-env1209 (cdr r1937))))))) (extend-var-env1208 (lambda (labels1939 vars1940 r1941) (if (null? labels1939) r1941 (extend-var-env1208 (cdr labels1939) (cdr vars1940) (cons (cons (car labels1939) (cons (quote lexical) (car vars1940))) r1941))))) (extend-env1207 (lambda (labels1942 bindings1943 r1944) (if (null? labels1942) r1944 (extend-env1207 (cdr labels1942) (cdr bindings1943) (cons (cons (car labels1942) (car bindings1943)) r1944))))) (binding-value1206 cdr) (binding-type1205 car) (source-annotation1204 (lambda (x1945) (cond ((annotation? x1945) (annotation-source x1945)) ((syntax-object?1197 x1945) (source-annotation1204 (syntax-object-expression1198 x1945))) (else #f)))) (set-syntax-object-module!1203 (lambda (x1946 update1947) (vector-set! x1946 3 update1947))) (set-syntax-object-wrap!1202 (lambda (x1948 update1949) (vector-set! x1948 2 update1949))) (set-syntax-object-expression!1201 (lambda (x1950 update1951) (vector-set! x1950 1 update1951))) (syntax-object-module1200 (lambda (x1952) (vector-ref x1952 3))) (syntax-object-wrap1199 (lambda (x1953) (vector-ref x1953 2))) (syntax-object-expression1198 (lambda (x1954) (vector-ref x1954 1))) (syntax-object?1197 (lambda (x1955) (and (vector? x1955) (= (vector-length x1955) 4) (eq? (vector-ref x1955 0) (quote syntax-object))))) (make-syntax-object1196 (lambda (expression1956 wrap1957 module1958) (vector (quote syntax-object) expression1956 wrap1957 module1958))) (build-letrec1195 (lambda (src1959 vars1960 val-exps1961 body-exp1962) (if (null? vars1960) (build-annotated1190 src1959 body-exp1962) (build-annotated1190 src1959 (list (quote letrec) (map list vars1960 val-exps1961) body-exp1962))))) (build-named-let1194 (lambda (src1963 vars1964 val-exps1965 body-exp1966) (if (null? vars1964) (build-annotated1190 src1963 body-exp1966) (build-annotated1190 src1963 (list (quote let) (car vars1964) (map list (cdr vars1964) val-exps1965) body-exp1966))))) (build-let1193 (lambda (src1967 vars1968 val-exps1969 body-exp1970) (if (null? vars1968) (build-annotated1190 src1967 body-exp1970) (build-annotated1190 src1967 (list (quote let) (map list vars1968 val-exps1969) body-exp1970))))) (build-sequence1192 (lambda (src1971 exps1972) (if (null? (cdr exps1972)) (build-annotated1190 src1971 (car exps1972)) (build-annotated1190 src1971 (cons (quote begin) exps1972))))) (build-data1191 (lambda (src1973 exp1974) (if (and (self-evaluating? exp1974) (not (vector? exp1974))) (build-annotated1190 src1973 exp1974) (build-annotated1190 src1973 (list (quote quote) exp1974))))) (build-annotated1190 (lambda (src1975 exp1976) (if (and src1975 (not (annotation? exp1976))) (make-annotation exp1976 src1975 #t) exp1976))) (get-global-definition-hook1189 (lambda (symbol1977 module1978) (begin (if (and (not module1978) (current-module)) (warn "module system is booted, we should have a module" symbol1977)) (module-lookup-keyword (if module1978 (resolve-module (cdr module1978)) (current-module)) symbol1977)))) (remove-global-definition-hook1188 (lambda (symbol1979) (module-undefine-keyword! (current-module) symbol1979))) (put-global-definition-hook1187 (lambda (symbol1980 type1981 val1982) (module-define-keyword! (current-module) symbol1980 type1981 val1982))) (error-hook1186 (lambda (who1983 why1984 what1985) (error who1983 "~a ~s" why1984 what1985))) (local-eval-hook1185 (lambda (x1986 mod1987) (primitive-eval (list noexpand1179 x1986)))) (top-level-eval-hook1184 (lambda (x1988 mod1989) (primitive-eval (list noexpand1179 x1988)))) (fx<1183 <) (fx=1182 =) (fx-1181 -) (fx+1180 +) (noexpand1179 "noexpand")) (begin (global-extend1211 (quote local-syntax) (quote letrec-syntax) #t) (global-extend1211 (quote local-syntax) (quote let-syntax) #f) (global-extend1211 (quote core) (quote fluid-let-syntax) (lambda (e1990 r1991 w1992 s1993 mod1994) ((lambda (tmp1995) ((lambda (tmp1996) (if (if tmp1996 (apply (lambda (_1997 var1998 val1999 e12000 e22001) (valid-bound-ids?1238 var1998)) tmp1996) #f) (apply (lambda (_2003 var2004 val2005 e12006 e22007) (let ((names2008 (map (lambda (x2009) (id-var-name1235 x2009 w1992)) var2004))) (begin (for-each (lambda (id2011 n2012) (let ((t2013 (binding-type1205 (lookup1210 n2012 r1991 mod1994)))) (if (memv t2013 (quote (displaced-lexical))) (syntax-violation (quote fluid-let-syntax) "identifier out of context" e1990 (source-wrap1242 id2011 w1992 s1993 mod1994))))) var2004 names2008) (chi-body1253 (cons e12006 e22007) (source-wrap1242 e1990 w1992 s1993 mod1994) (extend-env1207 names2008 (let ((trans-r2016 (macros-only-env1209 r1991))) (map (lambda (x2017) (cons (quote macro) (eval-local-transformer1256 (chi1249 x2017 trans-r2016 w1992 mod1994) mod1994))) val2005)) r1991) w1992 mod1994)))) tmp1996) ((lambda (_2019) (syntax-violation (quote fluid-let-syntax) "bad syntax" (source-wrap1242 e1990 w1992 s1993 mod1994))) tmp1995))) (syntax-dispatch tmp1995 (quote (any #(each (any any)) any . each-any))))) e1990))) (global-extend1211 (quote core) (quote quote) (lambda (e2020 r2021 w2022 s2023 mod2024) ((lambda (tmp2025) ((lambda (tmp2026) (if tmp2026 (apply (lambda (_2027 e2028) (build-data1191 s2023 (strip1260 e2028 w2022))) tmp2026) ((lambda (_2029) (syntax-violation (quote quote) "bad syntax" (source-wrap1242 e2020 w2022 s2023 mod2024))) tmp2025))) (syntax-dispatch tmp2025 (quote (any any))))) e2020))) (global-extend1211 (quote core) (quote syntax) (letrec ((regen2037 (lambda (x2038) (let ((t2039 (car x2038))) (if (memv t2039 (quote (ref))) (build-annotated1190 #f (cadr x2038)) (if (memv t2039 (quote (primitive))) (build-annotated1190 #f (cadr x2038)) (if (memv t2039 (quote (quote))) (build-data1191 #f (cadr x2038)) (if (memv t2039 (quote (lambda))) (build-annotated1190 #f (list (quote lambda) (cadr x2038) (regen2037 (caddr x2038)))) (if (memv t2039 (quote (map))) (let ((ls2040 (map regen2037 (cdr x2038)))) (build-annotated1190 #f (cons (if (fx=1182 (length ls2040) 2) (build-annotated1190 #f (quote map)) (build-annotated1190 #f (quote map))) ls2040))) (build-annotated1190 #f (cons (build-annotated1190 #f (car x2038)) (map regen2037 (cdr x2038)))))))))))) (gen-vector2036 (lambda (x2041) (cond ((eq? (car x2041) (quote list)) (cons (quote vector) (cdr x2041))) ((eq? (car x2041) (quote quote)) (list (quote quote) (list->vector (cadr x2041)))) (else (list (quote list->vector) x2041))))) (gen-append2035 (lambda (x2042 y2043) (if (equal? y2043 (quote (quote ()))) x2042 (list (quote append) x2042 y2043)))) (gen-cons2034 (lambda (x2044 y2045) (let ((t2046 (car y2045))) (if (memv t2046 (quote (quote))) (if (eq? (car x2044) (quote quote)) (list (quote quote) (cons (cadr x2044) (cadr y2045))) (if (eq? (cadr y2045) (quote ())) (list (quote list) x2044) (list (quote cons) x2044 y2045))) (if (memv t2046 (quote (list))) (cons (quote list) (cons x2044 (cdr y2045))) (list (quote cons) x2044 y2045)))))) (gen-map2033 (lambda (e2047 map-env2048) (let ((formals2049 (map cdr map-env2048)) (actuals2050 (map (lambda (x2051) (list (quote ref) (car x2051))) map-env2048))) (cond ((eq? (car e2047) (quote ref)) (car actuals2050)) ((andmap (lambda (x2052) (and (eq? (car x2052) (quote ref)) (memq (cadr x2052) formals2049))) (cdr e2047)) (cons (quote map) (cons (list (quote primitive) (car e2047)) (map (let ((r2053 (map cons formals2049 actuals2050))) (lambda (x2054) (cdr (assq (cadr x2054) r2053)))) (cdr e2047))))) (else (cons (quote map) (cons (list (quote lambda) formals2049 e2047) actuals2050))))))) (gen-mappend2032 (lambda (e2055 map-env2056) (list (quote apply) (quote (primitive append)) (gen-map2033 e2055 map-env2056)))) (gen-ref2031 (lambda (src2057 var2058 level2059 maps2060) (if (fx=1182 level2059 0) (values var2058 maps2060) (if (null? maps2060) (syntax-violation (quote syntax) "missing ellipsis" src2057) (call-with-values (lambda () (gen-ref2031 src2057 var2058 (fx-1181 level2059 1) (cdr maps2060))) (lambda (outer-var2061 outer-maps2062) (let ((b2063 (assq outer-var2061 (car maps2060)))) (if b2063 (values (cdr b2063) maps2060) (let ((inner-var2064 (gen-var1261 (quote tmp)))) (values inner-var2064 (cons (cons (cons outer-var2061 inner-var2064) (car maps2060)) outer-maps2062))))))))))) (gen-syntax2030 (lambda (src2065 e2066 r2067 maps2068 ellipsis?2069 mod2070) (if (id?1213 e2066) (let ((label2071 (id-var-name1235 e2066 (quote (()))))) (let ((b2072 (lookup1210 label2071 r2067 mod2070))) (if (eq? (binding-type1205 b2072) (quote syntax)) (call-with-values (lambda () (let ((var.lev2073 (binding-value1206 b2072))) (gen-ref2031 src2065 (car var.lev2073) (cdr var.lev2073) maps2068))) (lambda (var2074 maps2075) (values (list (quote ref) var2074) maps2075))) (if (ellipsis?2069 e2066) (syntax-violation (quote syntax) "misplaced ellipsis" src2065) (values (list (quote quote) e2066) maps2068))))) ((lambda (tmp2076) ((lambda (tmp2077) (if (if tmp2077 (apply (lambda (dots2078 e2079) (ellipsis?2069 dots2078)) tmp2077) #f) (apply (lambda (dots2080 e2081) (gen-syntax2030 src2065 e2081 r2067 maps2068 (lambda (x2082) #f) mod2070)) tmp2077) ((lambda (tmp2083) (if (if tmp2083 (apply (lambda (x2084 dots2085 y2086) (ellipsis?2069 dots2085)) tmp2083) #f) (apply (lambda (x2087 dots2088 y2089) (let f2090 ((y2091 y2089) (k2092 (lambda (maps2093) (call-with-values (lambda () (gen-syntax2030 src2065 x2087 r2067 (cons (quote ()) maps2093) ellipsis?2069 mod2070)) (lambda (x2094 maps2095) (if (null? (car maps2095)) (syntax-violation (quote syntax) "extra ellipsis" src2065) (values (gen-map2033 x2094 (car maps2095)) (cdr maps2095)))))))) ((lambda (tmp2096) ((lambda (tmp2097) (if (if tmp2097 (apply (lambda (dots2098 y2099) (ellipsis?2069 dots2098)) tmp2097) #f) (apply (lambda (dots2100 y2101) (f2090 y2101 (lambda (maps2102) (call-with-values (lambda () (k2092 (cons (quote ()) maps2102))) (lambda (x2103 maps2104) (if (null? (car maps2104)) (syntax-violation (quote syntax) "extra ellipsis" src2065) (values (gen-mappend2032 x2103 (car maps2104)) (cdr maps2104)))))))) tmp2097) ((lambda (_2105) (call-with-values (lambda () (gen-syntax2030 src2065 y2091 r2067 maps2068 ellipsis?2069 mod2070)) (lambda (y2106 maps2107) (call-with-values (lambda () (k2092 maps2107)) (lambda (x2108 maps2109) (values (gen-append2035 x2108 y2106) maps2109)))))) tmp2096))) (syntax-dispatch tmp2096 (quote (any . any))))) y2091))) tmp2083) ((lambda (tmp2110) (if tmp2110 (apply (lambda (x2111 y2112) (call-with-values (lambda () (gen-syntax2030 src2065 x2111 r2067 maps2068 ellipsis?2069 mod2070)) (lambda (x2113 maps2114) (call-with-values (lambda () (gen-syntax2030 src2065 y2112 r2067 maps2114 ellipsis?2069 mod2070)) (lambda (y2115 maps2116) (values (gen-cons2034 x2113 y2115) maps2116)))))) tmp2110) ((lambda (tmp2117) (if tmp2117 (apply (lambda (e12118 e22119) (call-with-values (lambda () (gen-syntax2030 src2065 (cons e12118 e22119) r2067 maps2068 ellipsis?2069 mod2070)) (lambda (e2121 maps2122) (values (gen-vector2036 e2121) maps2122)))) tmp2117) ((lambda (_2123) (values (list (quote quote) e2066) maps2068)) tmp2076))) (syntax-dispatch tmp2076 (quote #(vector (any . each-any))))))) (syntax-dispatch tmp2076 (quote (any . any)))))) (syntax-dispatch tmp2076 (quote (any any . any)))))) (syntax-dispatch tmp2076 (quote (any any))))) e2066))))) (lambda (e2124 r2125 w2126 s2127 mod2128) (let ((e2129 (source-wrap1242 e2124 w2126 s2127 mod2128))) ((lambda (tmp2130) ((lambda (tmp2131) (if tmp2131 (apply (lambda (_2132 x2133) (call-with-values (lambda () (gen-syntax2030 e2129 x2133 r2125 (quote ()) ellipsis?1258 mod2128)) (lambda (e2134 maps2135) (regen2037 e2134)))) tmp2131) ((lambda (_2136) (syntax-violation (quote syntax) "bad `syntax' form" e2129)) tmp2130))) (syntax-dispatch tmp2130 (quote (any any))))) e2129))))) (global-extend1211 (quote core) (quote lambda) (lambda (e2137 r2138 w2139 s2140 mod2141) ((lambda (tmp2142) ((lambda (tmp2143) (if tmp2143 (apply (lambda (_2144 c2145) (chi-lambda-clause1254 (source-wrap1242 e2137 w2139 s2140 mod2141) #f c2145 r2138 w2139 mod2141 (lambda (vars2146 docstring2147 body2148) (build-annotated1190 s2140 (cons (quote lambda) (cons vars2146 (append (if docstring2147 (list docstring2147) (quote ())) (list body2148)))))))) tmp2143) (syntax-violation #f "source expression failed to match any pattern" tmp2142))) (syntax-dispatch tmp2142 (quote (any . any))))) e2137))) (global-extend1211 (quote core) (quote let) (letrec ((chi-let2149 (lambda (e2150 r2151 w2152 s2153 mod2154 constructor2155 ids2156 vals2157 exps2158) (if (not (valid-bound-ids?1238 ids2156)) (syntax-violation (quote let) "duplicate bound variable" e2150) (let ((labels2159 (gen-labels1219 ids2156)) (new-vars2160 (map gen-var1261 ids2156))) (let ((nw2161 (make-binding-wrap1230 ids2156 labels2159 w2152)) (nr2162 (extend-var-env1208 labels2159 new-vars2160 r2151))) (constructor2155 s2153 new-vars2160 (map (lambda (x2163) (chi1249 x2163 r2151 w2152 mod2154)) vals2157) (chi-body1253 exps2158 (source-wrap1242 e2150 nw2161 s2153 mod2154) nr2162 nw2161 mod2154)))))))) (lambda (e2164 r2165 w2166 s2167 mod2168) ((lambda (tmp2169) ((lambda (tmp2170) (if tmp2170 (apply (lambda (_2171 id2172 val2173 e12174 e22175) (chi-let2149 e2164 r2165 w2166 s2167 mod2168 build-let1193 id2172 val2173 (cons e12174 e22175))) tmp2170) ((lambda (tmp2179) (if (if tmp2179 (apply (lambda (_2180 f2181 id2182 val2183 e12184 e22185) (id?1213 f2181)) tmp2179) #f) (apply (lambda (_2186 f2187 id2188 val2189 e12190 e22191) (chi-let2149 e2164 r2165 w2166 s2167 mod2168 build-named-let1194 (cons f2187 id2188) val2189 (cons e12190 e22191))) tmp2179) ((lambda (_2195) (syntax-violation (quote let) "bad let" (source-wrap1242 e2164 w2166 s2167 mod2168))) tmp2169))) (syntax-dispatch tmp2169 (quote (any any #(each (any any)) any . each-any)))))) (syntax-dispatch tmp2169 (quote (any #(each (any any)) any . each-any))))) e2164)))) (global-extend1211 (quote core) (quote letrec) (lambda (e2196 r2197 w2198 s2199 mod2200) ((lambda (tmp2201) ((lambda (tmp2202) (if tmp2202 (apply (lambda (_2203 id2204 val2205 e12206 e22207) (let ((ids2208 id2204)) (if (not (valid-bound-ids?1238 ids2208)) (syntax-violation (quote letrec) "duplicate bound variable" e2196) (let ((labels2210 (gen-labels1219 ids2208)) (new-vars2211 (map gen-var1261 ids2208))) (let ((w2212 (make-binding-wrap1230 ids2208 labels2210 w2198)) (r2213 (extend-var-env1208 labels2210 new-vars2211 r2197))) (build-letrec1195 s2199 new-vars2211 (map (lambda (x2214) (chi1249 x2214 r2213 w2212 mod2200)) val2205) (chi-body1253 (cons e12206 e22207) (source-wrap1242 e2196 w2212 s2199 mod2200) r2213 w2212 mod2200))))))) tmp2202) ((lambda (_2217) (syntax-violation (quote letrec) "bad letrec" (source-wrap1242 e2196 w2198 s2199 mod2200))) tmp2201))) (syntax-dispatch tmp2201 (quote (any #(each (any any)) any . each-any))))) e2196))) (global-extend1211 (quote core) (quote set!) (lambda (e2218 r2219 w2220 s2221 mod2222) ((lambda (tmp2223) ((lambda (tmp2224) (if (if tmp2224 (apply (lambda (_2225 id2226 val2227) (id?1213 id2226)) tmp2224) #f) (apply (lambda (_2228 id2229 val2230) (let ((val2231 (chi1249 val2230 r2219 w2220 mod2222)) (n2232 (id-var-name1235 id2229 w2220))) (let ((b2233 (lookup1210 n2232 r2219 mod2222))) (let ((t2234 (binding-type1205 b2233))) (if (memv t2234 (quote (lexical))) (build-annotated1190 s2221 (list (quote set!) (binding-value1206 b2233) val2231)) (if (memv t2234 (quote (global))) (build-annotated1190 s2221 (list (quote set!) (if mod2222 (make-module-ref (cdr mod2222) n2232 (car mod2222)) (make-module-ref mod2222 n2232 (quote bare))) val2231)) (if (memv t2234 (quote (displaced-lexical))) (syntax-violation (quote set!) "identifier out of context" (wrap1241 id2229 w2220 mod2222)) (syntax-violation (quote set!) "bad set!" (source-wrap1242 e2218 w2220 s2221 mod2222))))))))) tmp2224) ((lambda (tmp2235) (if tmp2235 (apply (lambda (_2236 head2237 tail2238 val2239) (call-with-values (lambda () (syntax-type1247 head2237 r2219 (quote (())) #f #f mod2222)) (lambda (type2240 value2241 ee2242 ww2243 ss2244 modmod2245) (let ((t2246 type2240)) (if (memv t2246 (quote (module-ref))) (let ((val2247 (chi1249 val2239 r2219 w2220 mod2222))) (call-with-values (lambda () (value2241 (cons head2237 tail2238))) (lambda (id2249 mod2250) (build-annotated1190 s2221 (list (quote set!) (if mod2250 (make-module-ref (cdr mod2250) id2249 (car mod2250)) (make-module-ref mod2250 id2249 (quote bare))) val2247))))) (build-annotated1190 s2221 (cons (chi1249 (list (quote #(syntax-object setter ((top) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type value ee ww ss modmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage #(_ head tail val) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(e r w s mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (hygiene guile))) head2237) r2219 w2220 mod2222) (map (lambda (e2251) (chi1249 e2251 r2219 w2220 mod2222)) (append tail2238 (list val2239)))))))))) tmp2235) ((lambda (_2253) (syntax-violation (quote set!) "bad set!" (source-wrap1242 e2218 w2220 s2221 mod2222))) tmp2223))) (syntax-dispatch tmp2223 (quote (any (any . each-any) any)))))) (syntax-dispatch tmp2223 (quote (any any any))))) e2218))) (global-extend1211 (quote module-ref) (quote @) (lambda (e2254) ((lambda (tmp2255) ((lambda (tmp2256) (if (if tmp2256 (apply (lambda (_2257 mod2258 id2259) (and (andmap id?1213 mod2258) (id?1213 id2259))) tmp2256) #f) (apply (lambda (_2261 mod2262 id2263) (values (syntax-object->datum id2263) (syntax-object->datum (cons (quote #(syntax-object public ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (hygiene guile))) mod2262)))) tmp2256) (syntax-violation #f "source expression failed to match any pattern" tmp2255))) (syntax-dispatch tmp2255 (quote (any each-any any))))) e2254))) (global-extend1211 (quote module-ref) (quote @@) (lambda (e2265) ((lambda (tmp2266) ((lambda (tmp2267) (if (if tmp2267 (apply (lambda (_2268 mod2269 id2270) (and (andmap id?1213 mod2269) (id?1213 id2270))) tmp2267) #f) (apply (lambda (_2272 mod2273 id2274) (values (syntax-object->datum id2274) (syntax-object->datum (cons (quote #(syntax-object private ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (hygiene guile))) mod2273)))) tmp2267) (syntax-violation #f "source expression failed to match any pattern" tmp2266))) (syntax-dispatch tmp2266 (quote (any each-any any))))) e2265))) (global-extend1211 (quote begin) (quote begin) (quote ())) (global-extend1211 (quote define) (quote define) (quote ())) (global-extend1211 (quote define-syntax) (quote define-syntax) (quote ())) (global-extend1211 (quote eval-when) (quote eval-when) (quote ())) (global-extend1211 (quote core) (quote syntax-case) (letrec ((gen-syntax-case2279 (lambda (x2280 keys2281 clauses2282 r2283 mod2284) (if (null? clauses2282) (build-annotated1190 #f (list (build-annotated1190 #f (quote syntax-violation)) #f "source expression failed to match any pattern" x2280)) ((lambda (tmp2285) ((lambda (tmp2286) (if tmp2286 (apply (lambda (pat2287 exp2288) (if (and (id?1213 pat2287) (andmap (lambda (x2289) (not (free-id=?1236 pat2287 x2289))) (cons (quote #(syntax-object ... ((top) #(ribcage #(pat exp) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x keys clauses r mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (gen-syntax-case gen-clause build-dispatch-call convert-pattern) ((top) (top) (top) (top)) ("i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application build-annotated get-global-definition-hook remove-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))) (hygiene guile))) keys2281))) (let ((labels2290 (list (gen-label1218))) (var2291 (gen-var1261 pat2287))) (build-annotated1190 #f (list (build-annotated1190 #f (list (quote lambda) (list var2291) (chi1249 exp2288 (extend-env1207 labels2290 (list (cons (quote syntax) (cons var2291 0))) r2283) (make-binding-wrap1230 (list pat2287) labels2290 (quote (()))) mod2284))) x2280))) (gen-clause2278 x2280 keys2281 (cdr clauses2282) r2283 pat2287 #t exp2288 mod2284))) tmp2286) ((lambda (tmp2292) (if tmp2292 (apply (lambda (pat2293 fender2294 exp2295) (gen-clause2278 x2280 keys2281 (cdr clauses2282) r2283 pat2293 fender2294 exp2295 mod2284)) tmp2292) ((lambda (_2296) (syntax-violation (quote syntax-case) "invalid clause" (car clauses2282))) tmp2285))) (syntax-dispatch tmp2285 (quote (any any any)))))) (syntax-dispatch tmp2285 (quote (any any))))) (car clauses2282))))) (gen-clause2278 (lambda (x2297 keys2298 clauses2299 r2300 pat2301 fender2302 exp2303 mod2304) (call-with-values (lambda () (convert-pattern2276 pat2301 keys2298)) (lambda (p2305 pvars2306) (cond ((not (distinct-bound-ids?1239 (map car pvars2306))) (syntax-violation (quote syntax-case) "duplicate pattern variable" pat2301)) ((not (andmap (lambda (x2307) (not (ellipsis?1258 (car x2307)))) pvars2306)) (syntax-violation (quote syntax-case) "misplaced ellipsis" pat2301)) (else (let ((y2308 (gen-var1261 (quote tmp)))) (build-annotated1190 #f (list (build-annotated1190 #f (list (quote lambda) (list y2308) (let ((y2309 (build-annotated1190 #f y2308))) (build-annotated1190 #f (list (quote if) ((lambda (tmp2310) ((lambda (tmp2311) (if tmp2311 (apply (lambda () y2309) tmp2311) ((lambda (_2312) (build-annotated1190 #f (list (quote if) y2309 (build-dispatch-call2277 pvars2306 fender2302 y2309 r2300 mod2304) (build-data1191 #f #f)))) tmp2310))) (syntax-dispatch tmp2310 (quote #(atom #t))))) fender2302) (build-dispatch-call2277 pvars2306 exp2303 y2309 r2300 mod2304) (gen-syntax-case2279 x2297 keys2298 clauses2299 r2300 mod2304)))))) (if (eq? p2305 (quote any)) (build-annotated1190 #f (list (build-annotated1190 #f (quote list)) x2297)) (build-annotated1190 #f (list (build-annotated1190 #f (quote syntax-dispatch)) x2297 (build-data1191 #f p2305))))))))))))) (build-dispatch-call2277 (lambda (pvars2313 exp2314 y2315 r2316 mod2317) (let ((ids2318 (map car pvars2313)) (levels2319 (map cdr pvars2313))) (let ((labels2320 (gen-labels1219 ids2318)) (new-vars2321 (map gen-var1261 ids2318))) (build-annotated1190 #f (list (build-annotated1190 #f (quote apply)) (build-annotated1190 #f (list (quote lambda) new-vars2321 (chi1249 exp2314 (extend-env1207 labels2320 (map (lambda (var2322 level2323) (cons (quote syntax) (cons var2322 level2323))) new-vars2321 (map cdr pvars2313)) r2316) (make-binding-wrap1230 ids2318 labels2320 (quote (()))) mod2317))) y2315)))))) (convert-pattern2276 (lambda (pattern2324 keys2325) (let cvt2326 ((p2327 pattern2324) (n2328 0) (ids2329 (quote ()))) (if (id?1213 p2327) (if (bound-id-member?1240 p2327 keys2325) (values (vector (quote free-id) p2327) ids2329) (values (quote any) (cons (cons p2327 n2328) ids2329))) ((lambda (tmp2330) ((lambda (tmp2331) (if (if tmp2331 (apply (lambda (x2332 dots2333) (ellipsis?1258 dots2333)) tmp2331) #f) (apply (lambda (x2334 dots2335) (call-with-values (lambda () (cvt2326 x2334 (fx+1180 n2328 1) ids2329)) (lambda (p2336 ids2337) (values (if (eq? p2336 (quote any)) (quote each-any) (vector (quote each) p2336)) ids2337)))) tmp2331) ((lambda (tmp2338) (if tmp2338 (apply (lambda (x2339 y2340) (call-with-values (lambda () (cvt2326 y2340 n2328 ids2329)) (lambda (y2341 ids2342) (call-with-values (lambda () (cvt2326 x2339 n2328 ids2342)) (lambda (x2343 ids2344) (values (cons x2343 y2341) ids2344)))))) tmp2338) ((lambda (tmp2345) (if tmp2345 (apply (lambda () (values (quote ()) ids2329)) tmp2345) ((lambda (tmp2346) (if tmp2346 (apply (lambda (x2347) (call-with-values (lambda () (cvt2326 x2347 n2328 ids2329)) (lambda (p2349 ids2350) (values (vector (quote vector) p2349) ids2350)))) tmp2346) ((lambda (x2351) (values (vector (quote atom) (strip1260 p2327 (quote (())))) ids2329)) tmp2330))) (syntax-dispatch tmp2330 (quote #(vector each-any)))))) (syntax-dispatch tmp2330 (quote ()))))) (syntax-dispatch tmp2330 (quote (any . any)))))) (syntax-dispatch tmp2330 (quote (any any))))) p2327)))))) (lambda (e2352 r2353 w2354 s2355 mod2356) (let ((e2357 (source-wrap1242 e2352 w2354 s2355 mod2356))) ((lambda (tmp2358) ((lambda (tmp2359) (if tmp2359 (apply (lambda (_2360 val2361 key2362 m2363) (if (andmap (lambda (x2364) (and (id?1213 x2364) (not (ellipsis?1258 x2364)))) key2362) (let ((x2366 (gen-var1261 (quote tmp)))) (build-annotated1190 s2355 (list (build-annotated1190 #f (list (quote lambda) (list x2366) (gen-syntax-case2279 (build-annotated1190 #f x2366) key2362 m2363 r2353 mod2356))) (chi1249 val2361 r2353 (quote (())) mod2356)))) (syntax-violation (quote syntax-case) "invalid literals list" e2357))) tmp2359) (syntax-violation #f "source expression failed to match any pattern" tmp2358))) (syntax-dispatch tmp2358 (quote (any any each-any . each-any))))) e2357))))) (set! sc-expand (let ((m2369 (quote e)) (esew2370 (quote (eval)))) (lambda (x2371) (if (and (pair? x2371) (equal? (car x2371) noexpand1179)) (cadr x2371) (chi-top1248 x2371 (quote ()) (quote ((top))) m2369 esew2370 (cons (quote hygiene) (module-name (current-module)))))))) (set! sc-expand3 (let ((m2372 (quote e)) (esew2373 (quote (eval)))) (lambda (x2375 . rest2374) (if (and (pair? x2375) (equal? (car x2375) noexpand1179)) (cadr x2375) (chi-top1248 x2375 (quote ()) (quote ((top))) (if (null? rest2374) m2372 (car rest2374)) (if (or (null? rest2374) (null? (cdr rest2374))) esew2373 (cadr rest2374)) (cons (quote hygiene) (module-name (current-module)))))))) (set! identifier? (lambda (x2376) (nonsymbol-id?1212 x2376))) (set! datum->syntax-object (lambda (id2377 datum2378) (make-syntax-object1196 datum2378 (syntax-object-wrap1199 id2377) #f))) (set! syntax-object->datum (lambda (x2379) (strip1260 x2379 (quote (()))))) (set! generate-temporaries (lambda (ls2380) (begin (let ((x2381 ls2380)) (if (not (list? x2381)) (error-hook1186 (quote generate-temporaries) "invalid argument" x2381))) (map (lambda (x2382) (wrap1241 (gensym) (quote ((top))) #f)) ls2380)))) (set! free-identifier=? (lambda (x2383 y2384) (begin (let ((x2385 x2383)) (if (not (nonsymbol-id?1212 x2385)) (error-hook1186 (quote free-identifier=?) "invalid argument" x2385))) (let ((x2386 y2384)) (if (not (nonsymbol-id?1212 x2386)) (error-hook1186 (quote free-identifier=?) "invalid argument" x2386))) (free-id=?1236 x2383 y2384)))) (set! bound-identifier=? (lambda (x2387 y2388) (begin (let ((x2389 x2387)) (if (not (nonsymbol-id?1212 x2389)) (error-hook1186 (quote bound-identifier=?) "invalid argument" x2389))) (let ((x2390 y2388)) (if (not (nonsymbol-id?1212 x2390)) (error-hook1186 (quote bound-identifier=?) "invalid argument" x2390))) (bound-id=?1237 x2387 y2388)))) (set! syntax-violation (lambda (who2394 message2393 form2392 . subform2391) (begin (let ((x2395 who2394)) (if (not ((lambda (x2396) (or (not x2396) (string? x2396) (symbol? x2396))) x2395)) (error-hook1186 (quote syntax-violation) "invalid argument" x2395))) (let ((x2397 message2393)) (if (not (string? x2397)) (error-hook1186 (quote syntax-violation) "invalid argument" x2397))) (scm-error (quote syntax-error) (quote sc-expand) (string-append (if who2394 "~a: " "") "~a " (if (null? subform2391) "in ~a" "in subform `~s' of `~s'")) (let ((tail2398 (cons message2393 (map (lambda (x2399) (strip1260 x2399 (quote (())))) (append subform2391 (list form2392)))))) (if who2394 (cons who2394 tail2398) tail2398)) #f)))) (set! install-global-transformer (lambda (sym2400 v2401) (begin (let ((x2402 sym2400)) (if (not (symbol? x2402)) (error-hook1186 (quote define-syntax) "invalid argument" x2402))) (let ((x2403 v2401)) (if (not (procedure? x2403)) (error-hook1186 (quote define-syntax) "invalid argument" x2403))) (global-extend1211 (quote macro) sym2400 v2401)))) (letrec ((match2408 (lambda (e2409 p2410 w2411 r2412 mod2413) (cond ((not r2412) #f) ((eq? p2410 (quote any)) (cons (wrap1241 e2409 w2411 mod2413) r2412)) ((syntax-object?1197 e2409) (match*2407 (let ((e2414 (syntax-object-expression1198 e2409))) (if (annotation? e2414) (annotation-expression e2414) e2414)) p2410 (join-wraps1232 w2411 (syntax-object-wrap1199 e2409)) r2412 (syntax-object-module1200 e2409))) (else (match*2407 (let ((e2415 e2409)) (if (annotation? e2415) (annotation-expression e2415) e2415)) p2410 w2411 r2412 mod2413))))) (match*2407 (lambda (e2416 p2417 w2418 r2419 mod2420) (cond ((null? p2417) (and (null? e2416) r2419)) ((pair? p2417) (and (pair? e2416) (match2408 (car e2416) (car p2417) w2418 (match2408 (cdr e2416) (cdr p2417) w2418 r2419 mod2420) mod2420))) ((eq? p2417 (quote each-any)) (let ((l2421 (match-each-any2405 e2416 w2418 mod2420))) (and l2421 (cons l2421 r2419)))) (else (let ((t2422 (vector-ref p2417 0))) (if (memv t2422 (quote (each))) (if (null? e2416) (match-empty2406 (vector-ref p2417 1) r2419) (let ((l2423 (match-each2404 e2416 (vector-ref p2417 1) w2418 mod2420))) (and l2423 (let collect2424 ((l2425 l2423)) (if (null? (car l2425)) r2419 (cons (map car l2425) (collect2424 (map cdr l2425)))))))) (if (memv t2422 (quote (free-id))) (and (id?1213 e2416) (free-id=?1236 (wrap1241 e2416 w2418 mod2420) (vector-ref p2417 1)) r2419) (if (memv t2422 (quote (atom))) (and (equal? (vector-ref p2417 1) (strip1260 e2416 w2418)) r2419) (if (memv t2422 (quote (vector))) (and (vector? e2416) (match2408 (vector->list e2416) (vector-ref p2417 1) w2418 r2419 mod2420))))))))))) (match-empty2406 (lambda (p2426 r2427) (cond ((null? p2426) r2427) ((eq? p2426 (quote any)) (cons (quote ()) r2427)) ((pair? p2426) (match-empty2406 (car p2426) (match-empty2406 (cdr p2426) r2427))) ((eq? p2426 (quote each-any)) (cons (quote ()) r2427)) (else (let ((t2428 (vector-ref p2426 0))) (if (memv t2428 (quote (each))) (match-empty2406 (vector-ref p2426 1) r2427) (if (memv t2428 (quote (free-id atom))) r2427 (if (memv t2428 (quote (vector))) (match-empty2406 (vector-ref p2426 1) r2427))))))))) (match-each-any2405 (lambda (e2429 w2430 mod2431) (cond ((annotation? e2429) (match-each-any2405 (annotation-expression e2429) w2430 mod2431)) ((pair? e2429) (let ((l2432 (match-each-any2405 (cdr e2429) w2430 mod2431))) (and l2432 (cons (wrap1241 (car e2429) w2430 mod2431) l2432)))) ((null? e2429) (quote ())) ((syntax-object?1197 e2429) (match-each-any2405 (syntax-object-expression1198 e2429) (join-wraps1232 w2430 (syntax-object-wrap1199 e2429)) mod2431)) (else #f)))) (match-each2404 (lambda (e2433 p2434 w2435 mod2436) (cond ((annotation? e2433) (match-each2404 (annotation-expression e2433) p2434 w2435 mod2436)) ((pair? e2433) (let ((first2437 (match2408 (car e2433) p2434 w2435 (quote ()) mod2436))) (and first2437 (let ((rest2438 (match-each2404 (cdr e2433) p2434 w2435 mod2436))) (and rest2438 (cons first2437 rest2438)))))) ((null? e2433) (quote ())) ((syntax-object?1197 e2433) (match-each2404 (syntax-object-expression1198 e2433) p2434 (join-wraps1232 w2435 (syntax-object-wrap1199 e2433)) (syntax-object-module1200 e2433))) (else #f))))) (set! syntax-dispatch (lambda (e2439 p2440) (cond ((eq? p2440 (quote any)) (list e2439)) ((syntax-object?1197 e2439) (match*2407 (let ((e2441 (syntax-object-expression1198 e2439))) (if (annotation? e2441) (annotation-expression e2441) e2441)) p2440 (syntax-object-wrap1199 e2439) (quote ()) (syntax-object-module1200 e2439))) (else (match*2407 (let ((e2442 e2439)) (if (annotation? e2442) (annotation-expression e2442) e2442)) p2440 (quote (())) (quote ()) #f))))))))
(install-global-transformer (quote with-syntax) (lambda (x2443) ((lambda (tmp2444) ((lambda (tmp2445) (if tmp2445 (apply (lambda (_2446 e12447 e22448) (cons (quote #(syntax-object begin ((top) #(ribcage #(_ e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12447 e22448))) tmp2445) ((lambda (tmp2450) (if tmp2450 (apply (lambda (_2451 out2452 in2453 e12454 e22455) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in2453 (quote ()) (list out2452 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12454 e22455))))) tmp2450) ((lambda (tmp2457) (if tmp2457 (apply (lambda (_2458 out2459 in2460 e12461 e22462) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object list ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in2460) (quote ()) (list out2459 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12461 e22462))))) tmp2457) (syntax-violation #f "source expression failed to match any pattern" tmp2444))) (syntax-dispatch tmp2444 (quote (any #(each (any any)) any . each-any)))))) (syntax-dispatch tmp2444 (quote (any ((any any)) any . each-any)))))) (syntax-dispatch tmp2444 (quote (any () any . each-any))))) x2443)))
(install-global-transformer (quote syntax-rules) (lambda (x2466) ((lambda (tmp2467) ((lambda (tmp2468) (if tmp2468 (apply (lambda (_2469 k2470 keyword2471 pattern2472 template2473) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (cons (quote #(syntax-object syntax-case ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons k2470 (map (lambda (tmp2476 tmp2475) (list (cons (quote #(syntax-object dummy ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp2475) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp2476))) template2473 pattern2472)))))) tmp2468) (syntax-violation #f "source expression failed to match any pattern" tmp2467))) (syntax-dispatch tmp2467 (quote (any each-any . #(each ((any . any) any))))))) x2466)))
(install-global-transformer (quote let*) (lambda (x2477) ((lambda (tmp2478) ((lambda (tmp2479) (if (if tmp2479 (apply (lambda (let*2480 x2481 v2482 e12483 e22484) (andmap identifier? x2481)) tmp2479) #f) (apply (lambda (let*2486 x2487 v2488 e12489 e22490) (let f2491 ((bindings2492 (map list x2487 v2488))) (if (null? bindings2492) (cons (quote #(syntax-object let ((top) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote ()) (cons e12489 e22490))) ((lambda (tmp2496) ((lambda (tmp2497) (if tmp2497 (apply (lambda (body2498 binding2499) (list (quote #(syntax-object let ((top) #(ribcage #(body binding) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list binding2499) body2498)) tmp2497) (syntax-violation #f "source expression failed to match any pattern" tmp2496))) (syntax-dispatch tmp2496 (quote (any any))))) (list (f2491 (cdr bindings2492)) (car bindings2492)))))) tmp2479) (syntax-violation #f "source expression failed to match any pattern" tmp2478))) (syntax-dispatch tmp2478 (quote (any #(each (any any)) any . each-any))))) x2477)))
(install-global-transformer (quote do) (lambda (orig-x2500) ((lambda (tmp2501) ((lambda (tmp2502) (if tmp2502 (apply (lambda (_2503 var2504 init2505 step2506 e02507 e12508 c2509) ((lambda (tmp2510) ((lambda (tmp2511) (if tmp2511 (apply (lambda (step2512) ((lambda (tmp2513) ((lambda (tmp2514) (if tmp2514 (apply (lambda () (list (quote #(syntax-object let ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var2504 init2505) (list (quote #(syntax-object if ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object not ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e02507) (cons (quote #(syntax-object begin ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c2509 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step2512))))))) tmp2514) ((lambda (tmp2519) (if tmp2519 (apply (lambda (e12520 e22521) (list (quote #(syntax-object let ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var2504 init2505) (list (quote #(syntax-object if ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e02507 (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (cons e12520 e22521)) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c2509 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step2512))))))) tmp2519) (syntax-violation #f "source expression failed to match any pattern" tmp2513))) (syntax-dispatch tmp2513 (quote (any . each-any)))))) (syntax-dispatch tmp2513 (quote ())))) e12508)) tmp2511) (syntax-violation #f "source expression failed to match any pattern" tmp2510))) (syntax-dispatch tmp2510 (quote each-any)))) (map (lambda (v2528 s2529) ((lambda (tmp2530) ((lambda (tmp2531) (if tmp2531 (apply (lambda () v2528) tmp2531) ((lambda (tmp2532) (if tmp2532 (apply (lambda (e2533) e2533) tmp2532) ((lambda (_2534) (syntax-violation (quote do) "bad step expression" orig-x2500 s2529)) tmp2530))) (syntax-dispatch tmp2530 (quote (any)))))) (syntax-dispatch tmp2530 (quote ())))) s2529)) var2504 step2506))) tmp2502) (syntax-violation #f "source expression failed to match any pattern" tmp2501))) (syntax-dispatch tmp2501 (quote (any #(each (any any . any)) (any . each-any) . each-any))))) orig-x2500)))
(install-global-transformer (quote quasiquote) (letrec ((quasicons2537 (lambda (x2541 y2542) ((lambda (tmp2543) ((lambda (tmp2544) (if tmp2544 (apply (lambda (x2545 y2546) ((lambda (tmp2547) ((lambda (tmp2548) (if tmp2548 (apply (lambda (dy2549) ((lambda (tmp2550) ((lambda (tmp2551) (if tmp2551 (apply (lambda (dx2552) (list (quote #(syntax-object quote ((top) #(ribcage #(dx) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons dx2552 dy2549))) tmp2551) ((lambda (_2553) (if (null? dy2549) (list (quote #(syntax-object list ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x2545) (list (quote #(syntax-object cons ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x2545 y2546))) tmp2550))) (syntax-dispatch tmp2550 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) x2545)) tmp2548) ((lambda (tmp2554) (if tmp2554 (apply (lambda (stuff2555) (cons (quote #(syntax-object list ((top) #(ribcage #(stuff) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons x2545 stuff2555))) tmp2554) ((lambda (else2556) (list (quote #(syntax-object cons ((top) #(ribcage #(else) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x2545 y2546)) tmp2547))) (syntax-dispatch tmp2547 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . any)))))) (syntax-dispatch tmp2547 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) y2546)) tmp2544) (syntax-violation #f "source expression failed to match any pattern" tmp2543))) (syntax-dispatch tmp2543 (quote (any any))))) (list x2541 y2542)))) (quasiappend2538 (lambda (x2557 y2558) ((lambda (tmp2559) ((lambda (tmp2560) (if tmp2560 (apply (lambda (x2561 y2562) ((lambda (tmp2563) ((lambda (tmp2564) (if tmp2564 (apply (lambda () x2561) tmp2564) ((lambda (_2565) (list (quote #(syntax-object append ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x2561 y2562)) tmp2563))) (syntax-dispatch tmp2563 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) ()))))) y2562)) tmp2560) (syntax-violation #f "source expression failed to match any pattern" tmp2559))) (syntax-dispatch tmp2559 (quote (any any))))) (list x2557 y2558)))) (quasivector2539 (lambda (x2566) ((lambda (tmp2567) ((lambda (x2568) ((lambda (tmp2569) ((lambda (tmp2570) (if tmp2570 (apply (lambda (x2571) (list (quote #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (list->vector x2571))) tmp2570) ((lambda (tmp2573) (if tmp2573 (apply (lambda (x2574) (cons (quote #(syntax-object vector ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x2574)) tmp2573) ((lambda (_2576) (list (quote #(syntax-object list->vector ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x2568)) tmp2569))) (syntax-dispatch tmp2569 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . each-any)))))) (syntax-dispatch tmp2569 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) each-any))))) x2568)) tmp2567)) x2566))) (quasi2540 (lambda (p2577 lev2578) ((lambda (tmp2579) ((lambda (tmp2580) (if tmp2580 (apply (lambda (p2581) (if (= lev2578 0) p2581 (quasicons2537 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi2540 (list p2581) (- lev2578 1))))) tmp2580) ((lambda (tmp2582) (if tmp2582 (apply (lambda (p2583 q2584) (if (= lev2578 0) (quasiappend2538 p2583 (quasi2540 q2584 lev2578)) (quasicons2537 (quasicons2537 (quote (#(syntax-object quote ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote-splicing ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi2540 (list p2583) (- lev2578 1))) (quasi2540 q2584 lev2578)))) tmp2582) ((lambda (tmp2585) (if tmp2585 (apply (lambda (p2586) (quasicons2537 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object quasiquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi2540 (list p2586) (+ lev2578 1)))) tmp2585) ((lambda (tmp2587) (if tmp2587 (apply (lambda (p2588 q2589) (quasicons2537 (quasi2540 p2588 lev2578) (quasi2540 q2589 lev2578))) tmp2587) ((lambda (tmp2590) (if tmp2590 (apply (lambda (x2591) (quasivector2539 (quasi2540 x2591 lev2578))) tmp2590) ((lambda (p2593) (list (quote #(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) p2593)) tmp2579))) (syntax-dispatch tmp2579 (quote #(vector each-any)))))) (syntax-dispatch tmp2579 (quote (any . any)))))) (syntax-dispatch tmp2579 (quote (#(free-id #(syntax-object quasiquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any)))))) (syntax-dispatch tmp2579 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any) . any)))))) (syntax-dispatch tmp2579 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) p2577)))) (lambda (x2594) ((lambda (tmp2595) ((lambda (tmp2596) (if tmp2596 (apply (lambda (_2597 e2598) (quasi2540 e2598 0)) tmp2596) (syntax-violation #f "source expression failed to match any pattern" tmp2595))) (syntax-dispatch tmp2595 (quote (any any))))) x2594))))
(install-global-transformer (quote include) (lambda (x2599) (letrec ((read-file2600 (lambda (fn2601 k2602) (let ((p2603 (open-input-file fn2601))) (let f2604 ((x2605 (read p2603))) (if (eof-object? x2605) (begin (close-input-port p2603) (quote ())) (cons (datum->syntax-object k2602 x2605) (f2604 (read p2603))))))))) ((lambda (tmp2606) ((lambda (tmp2607) (if tmp2607 (apply (lambda (k2608 filename2609) (let ((fn2610 (syntax-object->datum filename2609))) ((lambda (tmp2611) ((lambda (tmp2612) (if tmp2612 (apply (lambda (exp2613) (cons (quote #(syntax-object begin ((top) #(ribcage #(exp) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(fn) #((top)) #("i")) #(ribcage #(k filename) #((top) (top)) #("i" "i")) #(ribcage (read-file) ((top)) ("i")) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) exp2613)) tmp2612) (syntax-violation #f "source expression failed to match any pattern" tmp2611))) (syntax-dispatch tmp2611 (quote each-any)))) (read-file2600 fn2610 k2608)))) tmp2607) (syntax-violation #f "source expression failed to match any pattern" tmp2606))) (syntax-dispatch tmp2606 (quote (any any))))) x2599))))
(install-global-transformer (quote unquote) (lambda (x2615) ((lambda (tmp2616) ((lambda (tmp2617) (if tmp2617 (apply (lambda (_2618 e2619) (error (quote unquote) "expression ,~s not valid outside of quasiquote" (syntax-object->datum e2619))) tmp2617) (syntax-violation #f "source expression failed to match any pattern" tmp2616))) (syntax-dispatch tmp2616 (quote (any any))))) x2615)))
(install-global-transformer (quote unquote-splicing) (lambda (x2620) ((lambda (tmp2621) ((lambda (tmp2622) (if tmp2622 (apply (lambda (_2623 e2624) (error (quote unquote-splicing) "expression ,@~s not valid outside of quasiquote" (syntax-object->datum e2624))) tmp2622) (syntax-violation #f "source expression failed to match any pattern" tmp2621))) (syntax-dispatch tmp2621 (quote (any any))))) x2620)))
(install-global-transformer (quote case) (lambda (x2625) ((lambda (tmp2626) ((lambda (tmp2627) (if tmp2627 (apply (lambda (_2628 e2629 m12630 m22631) ((lambda (tmp2632) ((lambda (body2633) (list (quote #(syntax-object let ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (list (quote #(syntax-object t ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e2629)) body2633)) tmp2632)) (let f2634 ((clause2635 m12630) (clauses2636 m22631)) (if (null? clauses2636) ((lambda (tmp2638) ((lambda (tmp2639) (if tmp2639 (apply (lambda (e12640 e22641) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12640 e22641))) tmp2639) ((lambda (tmp2643) (if tmp2643 (apply (lambda (k2644 e12645 e22646) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k2644)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12645 e22646)))) tmp2643) ((lambda (_2649) (syntax-violation (quote case) "bad clause" x2625 clause2635)) tmp2638))) (syntax-dispatch tmp2638 (quote (each-any any . each-any)))))) (syntax-dispatch tmp2638 (quote (#(free-id #(syntax-object else ((top) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) any . each-any))))) clause2635) ((lambda (tmp2650) ((lambda (rest2651) ((lambda (tmp2652) ((lambda (tmp2653) (if tmp2653 (apply (lambda (k2654 e12655 e22656) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k2654)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12655 e22656)) rest2651)) tmp2653) ((lambda (_2659) (syntax-violation (quote case) "bad clause" x2625 clause2635)) tmp2652))) (syntax-dispatch tmp2652 (quote (each-any any . each-any))))) clause2635)) tmp2650)) (f2634 (car clauses2636) (cdr clauses2636))))))) tmp2627) (syntax-violation #f "source expression failed to match any pattern" tmp2626))) (syntax-dispatch tmp2626 (quote (any any any . each-any))))) x2625)))
(install-global-transformer (quote identifier-syntax) (lambda (x2660) ((lambda (tmp2661) ((lambda (tmp2662) (if tmp2662 (apply (lambda (_2663 e2664) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote ()) (list (quote #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object identifier? ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) (#(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e2664)) (list (cons _2663 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e2664 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))))))))) tmp2662) (syntax-violation #f "source expression failed to match any pattern" tmp2661))) (syntax-dispatch tmp2661 (quote (any any))))) x2660)))
