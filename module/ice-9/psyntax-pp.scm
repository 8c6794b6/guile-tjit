(eval-when (compile) (set-current-module (resolve-module (quote (guile)))))
(if #f #f)
(letrec ((and-map*475 (lambda (f515 first514 . rest513) (or (null? first514) (if (null? rest513) (letrec ((andmap516 (lambda (first517) (let ((x518 (car first517)) (first519 (cdr first517))) (if (null? first519) (f515 x518) (and (f515 x518) (andmap516 first519))))))) (andmap516 first514)) (letrec ((andmap520 (lambda (first521 rest522) (let ((x523 (car first521)) (xr524 (map car rest522)) (first525 (cdr first521)) (rest526 (map cdr rest522))) (if (null? first525) (apply f515 (cons x523 xr524)) (and (apply f515 (cons x523 xr524)) (andmap520 first525 rest526))))))) (andmap520 first514 rest513))))))) (letrec ((lambda-var-list618 (lambda (vars747) (letrec ((lvl748 (lambda (vars749 ls750 w751) (cond ((pair? vars749) (lvl748 (cdr vars749) (cons (wrap597 (car vars749) w751 #f) ls750) w751)) ((id?569 vars749) (cons (wrap597 vars749 w751 #f) ls750)) ((null? vars749) ls750) ((syntax-object?553 vars749) (lvl748 (syntax-object-expression554 vars749) ls750 (join-wraps588 w751 (syntax-object-wrap555 vars749)))) ((annotation? vars749) (lvl748 (annotation-expression vars749) ls750 w751)) (else (cons vars749 ls750)))))) (lvl748 vars747 (quote ()) (quote (())))))) (gen-var617 (lambda (id752) (let ((id753 (if (syntax-object?553 id752) (syntax-object-expression554 id752) id752))) (if (annotation? id753) (gensym (symbol->string (annotation-expression id753))) (gensym (symbol->string id753)))))) (strip616 (lambda (x754 w755) (if (memq (quote top) (wrap-marks572 w755)) (if (or (annotation? x754) (and (pair? x754) (annotation? (car x754)))) (strip-annotation615 x754 #f) x754) (letrec ((f756 (lambda (x757) (cond ((syntax-object?553 x757) (strip616 (syntax-object-expression554 x757) (syntax-object-wrap555 x757))) ((pair? x757) (let ((a758 (f756 (car x757))) (d759 (f756 (cdr x757)))) (if (and (eq? a758 (car x757)) (eq? d759 (cdr x757))) x757 (cons a758 d759)))) ((vector? x757) (let ((old760 (vector->list x757))) (let ((new761 (map f756 old760))) (if (and-map*475 eq? old760 new761) x757 (list->vector new761))))) (else x757))))) (f756 x754))))) (strip-annotation615 (lambda (x762 parent763) (cond ((pair? x762) (let ((new764 (cons #f #f))) (begin (if parent763 (set-annotation-stripped! parent763 new764)) (set-car! new764 (strip-annotation615 (car x762) #f)) (set-cdr! new764 (strip-annotation615 (cdr x762) #f)) new764))) ((annotation? x762) (or (annotation-stripped x762) (strip-annotation615 (annotation-expression x762) x762))) ((vector? x762) (let ((new765 (make-vector (vector-length x762)))) (begin (if parent763 (set-annotation-stripped! parent763 new765)) (letrec ((loop766 (lambda (i767) (unless (fx<532 i767 0) (vector-set! new765 i767 (strip-annotation615 (vector-ref x762 i767) #f)) (loop766 (fx-530 i767 1)))))) (loop766 (- (vector-length x762) 1))) new765))) (else x762)))) (ellipsis?614 (lambda (x768) (and (nonsymbol-id?568 x768) (free-id=?592 x768 (quote #(syntax-object ... ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))))))) (chi-void613 (lambda () (build-application537 #f (build-primref546 #f (quote if)) (quote (#f #f))))) (eval-local-transformer612 (lambda (expanded769 mod770) (let ((p771 (local-eval-hook534 expanded769 mod770))) (if (procedure? p771) p771 (syntax-violation #f "nonprocedure transformer" p771))))) (chi-local-syntax611 (lambda (rec?772 e773 r774 w775 s776 mod777 k778) ((lambda (tmp779) ((lambda (tmp780) (if tmp780 (apply (lambda (_781 id782 val783 e1784 e2785) (let ((ids786 id782)) (if (not (valid-bound-ids?594 ids786)) (syntax-violation #f "duplicate bound keyword" e773) (let ((labels788 (gen-labels575 ids786))) (let ((new-w789 (make-binding-wrap586 ids786 labels788 w775))) (k778 (cons e1784 e2785) (extend-env563 labels788 (let ((w791 (if rec?772 new-w789 w775)) (trans-r792 (macros-only-env565 r774))) (map (lambda (x793) (cons (quote macro) (eval-local-transformer612 (chi605 x793 trans-r792 w791 mod777) mod777))) val783)) r774) new-w789 s776 mod777)))))) tmp780) ((lambda (_795) (syntax-violation #f "bad local syntax definition" (source-wrap598 e773 w775 s776 mod777))) tmp779))) ($sc-dispatch tmp779 (quote (any #(each (any any)) any . each-any))))) e773))) (chi-lambda-clause610 (lambda (e796 docstring797 c798 r799 w800 mod801 k802) ((lambda (tmp803) ((lambda (tmp804) (if (if tmp804 (apply (lambda (args805 doc806 e1807 e2808) (and (string? (syntax->datum doc806)) (not docstring797))) tmp804) #f) (apply (lambda (args809 doc810 e1811 e2812) (chi-lambda-clause610 e796 doc810 (cons args809 (cons e1811 e2812)) r799 w800 mod801 k802)) tmp804) ((lambda (tmp814) (if tmp814 (apply (lambda (id815 e1816 e2817) (let ((ids818 id815)) (if (not (valid-bound-ids?594 ids818)) (syntax-violation (quote lambda) "invalid parameter list" e796) (let ((labels820 (gen-labels575 ids818)) (new-vars821 (map gen-var617 ids818))) (k802 (map syntax->datum ids818) new-vars821 docstring797 (chi-body609 (cons e1816 e2817) e796 (extend-var-env564 labels820 new-vars821 r799) (make-binding-wrap586 ids818 labels820 w800) mod801)))))) tmp814) ((lambda (tmp823) (if tmp823 (apply (lambda (ids824 e1825 e2826) (let ((old-ids827 (lambda-var-list618 ids824))) (if (not (valid-bound-ids?594 old-ids827)) (syntax-violation (quote lambda) "invalid parameter list" e796) (let ((labels828 (gen-labels575 old-ids827)) (new-vars829 (map gen-var617 old-ids827))) (k802 (letrec ((f830 (lambda (ls1831 ls2832) (if (null? ls1831) (syntax->datum ls2832) (f830 (cdr ls1831) (cons (syntax->datum (car ls1831)) ls2832)))))) (f830 (cdr old-ids827) (car old-ids827))) (letrec ((f833 (lambda (ls1834 ls2835) (if (null? ls1834) ls2835 (f833 (cdr ls1834) (cons (car ls1834) ls2835)))))) (f833 (cdr new-vars829) (car new-vars829))) docstring797 (chi-body609 (cons e1825 e2826) e796 (extend-var-env564 labels828 new-vars829 r799) (make-binding-wrap586 old-ids827 labels828 w800) mod801)))))) tmp823) ((lambda (_837) (syntax-violation (quote lambda) "bad lambda" e796)) tmp803))) ($sc-dispatch tmp803 (quote (any any . each-any)))))) ($sc-dispatch tmp803 (quote (each-any any . each-any)))))) ($sc-dispatch tmp803 (quote (any any any . each-any))))) c798))) (chi-body609 (lambda (body838 outer-form839 r840 w841 mod842) (let ((r843 (cons (quote ("placeholder" placeholder)) r840))) (let ((ribcage844 (make-ribcage576 (quote ()) (quote ()) (quote ())))) (let ((w845 (make-wrap571 (wrap-marks572 w841) (cons ribcage844 (wrap-subst573 w841))))) (letrec ((parse846 (lambda (body847 ids848 labels849 vars850 vals851 bindings852) (if (null? body847) (syntax-violation #f "no expressions in body" outer-form839) (let ((e854 (cdar body847)) (er855 (caar body847))) (call-with-values (lambda () (syntax-type603 e854 er855 (quote (())) #f ribcage844 mod842)) (lambda (type856 value857 e858 w859 s860 mod861) (let ((t862 type856)) (if (memv t862 (quote (define-form))) (let ((id863 (wrap597 value857 w859 mod861)) (label864 (gen-label574))) (let ((var865 (gen-var617 id863))) (begin (extend-ribcage!585 ribcage844 id863 label864) (parse846 (cdr body847) (cons id863 ids848) (cons label864 labels849) (cons var865 vars850) (cons (cons er855 (wrap597 e858 w859 mod861)) vals851) (cons (cons (quote lexical) var865) bindings852))))) (if (memv t862 (quote (define-syntax-form))) (let ((id866 (wrap597 value857 w859 mod861)) (label867 (gen-label574))) (begin (extend-ribcage!585 ribcage844 id866 label867) (parse846 (cdr body847) (cons id866 ids848) (cons label867 labels849) vars850 vals851 (cons (cons (quote macro) (cons er855 (wrap597 e858 w859 mod861))) bindings852)))) (if (memv t862 (quote (begin-form))) ((lambda (tmp868) ((lambda (tmp869) (if tmp869 (apply (lambda (_870 e1871) (parse846 (letrec ((f872 (lambda (forms873) (if (null? forms873) (cdr body847) (cons (cons er855 (wrap597 (car forms873) w859 mod861)) (f872 (cdr forms873))))))) (f872 e1871)) ids848 labels849 vars850 vals851 bindings852)) tmp869) (syntax-violation #f "source expression failed to match any pattern" tmp868))) ($sc-dispatch tmp868 (quote (any . each-any))))) e858) (if (memv t862 (quote (local-syntax-form))) (chi-local-syntax611 value857 e858 er855 w859 s860 mod861 (lambda (forms875 er876 w877 s878 mod879) (parse846 (letrec ((f880 (lambda (forms881) (if (null? forms881) (cdr body847) (cons (cons er876 (wrap597 (car forms881) w877 mod879)) (f880 (cdr forms881))))))) (f880 forms875)) ids848 labels849 vars850 vals851 bindings852))) (if (null? ids848) (build-sequence548 #f (map (lambda (x882) (chi605 (cdr x882) (car x882) (quote (())) mod861)) (cons (cons er855 (source-wrap598 e858 w859 s860 mod861)) (cdr body847)))) (begin (if (not (valid-bound-ids?594 ids848)) (syntax-violation #f "invalid or duplicate identifier in definition" outer-form839)) (letrec ((loop883 (lambda (bs884 er-cache885 r-cache886) (if (not (null? bs884)) (let ((b887 (car bs884))) (if (eq? (car b887) (quote macro)) (let ((er888 (cadr b887))) (let ((r-cache889 (if (eq? er888 er-cache885) r-cache886 (macros-only-env565 er888)))) (begin (set-cdr! b887 (eval-local-transformer612 (chi605 (cddr b887) r-cache889 (quote (())) mod861) mod861)) (loop883 (cdr bs884) er888 r-cache889)))) (loop883 (cdr bs884) er-cache885 r-cache886))))))) (loop883 bindings852 #f #f)) (set-cdr! r843 (extend-env563 labels849 bindings852 (cdr r843))) (build-letrec551 #f (map syntax->datum ids848) vars850 (map (lambda (x890) (chi605 (cdr x890) (car x890) (quote (())) mod861)) vals851) (build-sequence548 #f (map (lambda (x891) (chi605 (cdr x891) (car x891) (quote (())) mod861)) (cons (cons er855 (source-wrap598 e858 w859 s860 mod861)) (cdr body847))))))))))))))))))) (parse846 (map (lambda (x853) (cons r843 (wrap597 x853 w845 mod842))) body838) (quote ()) (quote ()) (quote ()) (quote ()) (quote ())))))))) (chi-macro608 (lambda (p892 e893 r894 w895 rib896 mod897) (letrec ((rebuild-macro-output898 (lambda (x899 m900) (cond ((pair? x899) (cons (rebuild-macro-output898 (car x899) m900) (rebuild-macro-output898 (cdr x899) m900))) ((syntax-object?553 x899) (let ((w901 (syntax-object-wrap555 x899))) (let ((ms902 (wrap-marks572 w901)) (s903 (wrap-subst573 w901))) (if (and (pair? ms902) (eq? (car ms902) #f)) (make-syntax-object552 (syntax-object-expression554 x899) (make-wrap571 (cdr ms902) (if rib896 (cons rib896 (cdr s903)) (cdr s903))) (syntax-object-module556 x899)) (make-syntax-object552 (syntax-object-expression554 x899) (make-wrap571 (cons m900 ms902) (if rib896 (cons rib896 (cons (quote shift) s903)) (cons (quote shift) s903))) (let ((pmod904 (procedure-module p892))) (if pmod904 (cons (quote hygiene) (module-name pmod904)) (quote (hygiene guile))))))))) ((vector? x899) (let ((n905 (vector-length x899))) (let ((v906 (make-vector n905))) (letrec ((doloop907 (lambda (i908) (if (fx=531 i908 n905) v906 (begin (vector-set! v906 i908 (rebuild-macro-output898 (vector-ref x899 i908) m900)) (doloop907 (fx+529 i908 1))))))) (doloop907 0))))) ((symbol? x899) (syntax-violation #f "encountered raw symbol in macro output" (source-wrap598 e893 w895 s mod897) x899)) (else x899))))) (rebuild-macro-output898 (p892 (wrap597 e893 (anti-mark584 w895) mod897)) (string #\m))))) (chi-application607 (lambda (x909 e910 r911 w912 s913 mod914) ((lambda (tmp915) ((lambda (tmp916) (if tmp916 (apply (lambda (e0917 e1918) (build-application537 s913 x909 (map (lambda (e919) (chi605 e919 r911 w912 mod914)) e1918))) tmp916) (syntax-violation #f "source expression failed to match any pattern" tmp915))) ($sc-dispatch tmp915 (quote (any . each-any))))) e910))) (chi-expr606 (lambda (type921 value922 e923 r924 w925 s926 mod927) (let ((t928 type921)) (if (memv t928 (quote (lexical))) (build-lexical-reference539 (quote value) s926 e923 value922) (if (memv t928 (quote (core external-macro))) (value922 e923 r924 w925 s926 mod927) (if (memv t928 (quote (module-ref))) (call-with-values (lambda () (value922 e923)) (lambda (id929 mod930) (build-global-reference542 s926 id929 mod930))) (if (memv t928 (quote (lexical-call))) (chi-application607 (build-lexical-reference539 (quote fun) (source-annotation560 (car e923)) (car e923) value922) e923 r924 w925 s926 mod927) (if (memv t928 (quote (global-call))) (chi-application607 (build-global-reference542 (source-annotation560 (car e923)) value922 (if (syntax-object?553 (car e923)) (syntax-object-module556 (car e923)) mod927)) e923 r924 w925 s926 mod927) (if (memv t928 (quote (constant))) (build-data547 s926 (strip616 (source-wrap598 e923 w925 s926 mod927) (quote (())))) (if (memv t928 (quote (global))) (build-global-reference542 s926 value922 mod927) (if (memv t928 (quote (call))) (chi-application607 (chi605 (car e923) r924 w925 mod927) e923 r924 w925 s926 mod927) (if (memv t928 (quote (begin-form))) ((lambda (tmp931) ((lambda (tmp932) (if tmp932 (apply (lambda (_933 e1934 e2935) (chi-sequence599 (cons e1934 e2935) r924 w925 s926 mod927)) tmp932) (syntax-violation #f "source expression failed to match any pattern" tmp931))) ($sc-dispatch tmp931 (quote (any any . each-any))))) e923) (if (memv t928 (quote (local-syntax-form))) (chi-local-syntax611 value922 e923 r924 w925 s926 mod927 chi-sequence599) (if (memv t928 (quote (eval-when-form))) ((lambda (tmp937) ((lambda (tmp938) (if tmp938 (apply (lambda (_939 x940 e1941 e2942) (let ((when-list943 (chi-when-list602 e923 x940 w925))) (if (memq (quote eval) when-list943) (chi-sequence599 (cons e1941 e2942) r924 w925 s926 mod927) (chi-void613)))) tmp938) (syntax-violation #f "source expression failed to match any pattern" tmp937))) ($sc-dispatch tmp937 (quote (any each-any any . each-any))))) e923) (if (memv t928 (quote (define-form define-syntax-form))) (syntax-violation #f "definition in expression context" e923 (wrap597 value922 w925 mod927)) (if (memv t928 (quote (syntax))) (syntax-violation #f "reference to pattern variable outside syntax form" (source-wrap598 e923 w925 s926 mod927)) (if (memv t928 (quote (displaced-lexical))) (syntax-violation #f "reference to identifier outside its scope" (source-wrap598 e923 w925 s926 mod927)) (syntax-violation #f "unexpected syntax" (source-wrap598 e923 w925 s926 mod927))))))))))))))))))) (chi605 (lambda (e946 r947 w948 mod949) (call-with-values (lambda () (syntax-type603 e946 r947 w948 #f #f mod949)) (lambda (type950 value951 e952 w953 s954 mod955) (chi-expr606 type950 value951 e952 r947 w953 s954 mod955))))) (chi-top604 (lambda (e956 r957 w958 m959 esew960 mod961) (call-with-values (lambda () (syntax-type603 e956 r957 w958 #f #f mod961)) (lambda (type969 value970 e971 w972 s973 mod974) (let ((t975 type969)) (if (memv t975 (quote (begin-form))) ((lambda (tmp976) ((lambda (tmp977) (if tmp977 (apply (lambda (_978) (chi-void613)) tmp977) ((lambda (tmp979) (if tmp979 (apply (lambda (_980 e1981 e2982) (chi-top-sequence600 (cons e1981 e2982) r957 w972 s973 m959 esew960 mod974)) tmp979) (syntax-violation #f "source expression failed to match any pattern" tmp976))) ($sc-dispatch tmp976 (quote (any any . each-any)))))) ($sc-dispatch tmp976 (quote (any))))) e971) (if (memv t975 (quote (local-syntax-form))) (chi-local-syntax611 value970 e971 r957 w972 s973 mod974 (lambda (body984 r985 w986 s987 mod988) (chi-top-sequence600 body984 r985 w986 s987 m959 esew960 mod988))) (if (memv t975 (quote (eval-when-form))) ((lambda (tmp989) ((lambda (tmp990) (if tmp990 (apply (lambda (_991 x992 e1993 e2994) (let ((when-list995 (chi-when-list602 e971 x992 w972)) (body996 (cons e1993 e2994))) (cond ((eq? m959 (quote e)) (if (memq (quote eval) when-list995) (chi-top-sequence600 body996 r957 w972 s973 (quote e) (quote (eval)) mod974) (chi-void613))) ((memq (quote load) when-list995) (if (or (memq (quote compile) when-list995) (and (eq? m959 (quote c&e)) (memq (quote eval) when-list995))) (chi-top-sequence600 body996 r957 w972 s973 (quote c&e) (quote (compile load)) mod974) (if (memq m959 (quote (c c&e))) (chi-top-sequence600 body996 r957 w972 s973 (quote c) (quote (load)) mod974) (chi-void613)))) ((or (memq (quote compile) when-list995) (and (eq? m959 (quote c&e)) (memq (quote eval) when-list995))) (top-level-eval-hook533 (chi-top-sequence600 body996 r957 w972 s973 (quote e) (quote (eval)) mod974) mod974) (chi-void613)) (else (chi-void613))))) tmp990) (syntax-violation #f "source expression failed to match any pattern" tmp989))) ($sc-dispatch tmp989 (quote (any each-any any . each-any))))) e971) (if (memv t975 (quote (define-syntax-form))) (let ((n999 (id-var-name591 value970 w972)) (r1000 (macros-only-env565 r957))) (let ((t1001 m959)) (if (memv t1001 (quote (c))) (if (memq (quote compile) esew960) (let ((e1002 (chi-install-global601 n999 (chi605 e971 r1000 w972 mod974)))) (begin (top-level-eval-hook533 e1002 mod974) (if (memq (quote load) esew960) e1002 (chi-void613)))) (if (memq (quote load) esew960) (chi-install-global601 n999 (chi605 e971 r1000 w972 mod974)) (chi-void613))) (if (memv t1001 (quote (c&e))) (let ((e1003 (chi-install-global601 n999 (chi605 e971 r1000 w972 mod974)))) (begin (top-level-eval-hook533 e1003 mod974) e1003)) (begin (if (memq (quote eval) esew960) (top-level-eval-hook533 (chi-install-global601 n999 (chi605 e971 r1000 w972 mod974)) mod974)) (chi-void613)))))) (if (memv t975 (quote (define-form))) (let ((n1004 (id-var-name591 value970 w972))) (let ((type1005 (binding-type561 (lookup566 n1004 r957 mod974)))) (let ((t1006 type1005)) (if (memv t1006 (quote (global core macro module-ref))) (let ((x1007 (build-global-definition544 s973 n1004 (chi605 e971 r957 w972 mod974)))) (begin (if (eq? m959 (quote c&e)) (top-level-eval-hook533 x1007 mod974)) x1007)) (if (memv t1006 (quote (displaced-lexical))) (syntax-violation #f "identifier out of context" e971 (wrap597 value970 w972 mod974)) (syntax-violation #f "cannot define keyword at top level" e971 (wrap597 value970 w972 mod974))))))) (let ((x1008 (chi-expr606 type969 value970 e971 r957 w972 s973 mod974))) (begin (if (eq? m959 (quote c&e)) (top-level-eval-hook533 x1008 mod974)) x1008)))))))))))) (syntax-type603 (lambda (e1009 r1010 w1011 s1012 rib1013 mod1014) (cond ((symbol? e1009) (let ((n1015 (id-var-name591 e1009 w1011))) (let ((b1016 (lookup566 n1015 r1010 mod1014))) (let ((type1017 (binding-type561 b1016))) (let ((t1018 type1017)) (if (memv t1018 (quote (lexical))) (values type1017 (binding-value562 b1016) e1009 w1011 s1012 mod1014) (if (memv t1018 (quote (global))) (values type1017 n1015 e1009 w1011 s1012 mod1014) (if (memv t1018 (quote (macro))) (syntax-type603 (chi-macro608 (binding-value562 b1016) e1009 r1010 w1011 rib1013 mod1014) r1010 (quote (())) s1012 rib1013 mod1014) (values type1017 (binding-value562 b1016) e1009 w1011 s1012 mod1014))))))))) ((pair? e1009) (let ((first1019 (car e1009))) (if (id?569 first1019) (let ((n1020 (id-var-name591 first1019 w1011))) (let ((b1021 (lookup566 n1020 r1010 (or (and (syntax-object?553 first1019) (syntax-object-module556 first1019)) mod1014)))) (let ((type1022 (binding-type561 b1021))) (let ((t1023 type1022)) (if (memv t1023 (quote (lexical))) (values (quote lexical-call) (binding-value562 b1021) e1009 w1011 s1012 mod1014) (if (memv t1023 (quote (global))) (values (quote global-call) n1020 e1009 w1011 s1012 mod1014) (if (memv t1023 (quote (macro))) (syntax-type603 (chi-macro608 (binding-value562 b1021) e1009 r1010 w1011 rib1013 mod1014) r1010 (quote (())) s1012 rib1013 mod1014) (if (memv t1023 (quote (core external-macro module-ref))) (values type1022 (binding-value562 b1021) e1009 w1011 s1012 mod1014) (if (memv t1023 (quote (local-syntax))) (values (quote local-syntax-form) (binding-value562 b1021) e1009 w1011 s1012 mod1014) (if (memv t1023 (quote (begin))) (values (quote begin-form) #f e1009 w1011 s1012 mod1014) (if (memv t1023 (quote (eval-when))) (values (quote eval-when-form) #f e1009 w1011 s1012 mod1014) (if (memv t1023 (quote (define))) ((lambda (tmp1024) ((lambda (tmp1025) (if (if tmp1025 (apply (lambda (_1026 name1027 val1028) (id?569 name1027)) tmp1025) #f) (apply (lambda (_1029 name1030 val1031) (values (quote define-form) name1030 val1031 w1011 s1012 mod1014)) tmp1025) ((lambda (tmp1032) (if (if tmp1032 (apply (lambda (_1033 name1034 args1035 e11036 e21037) (and (id?569 name1034) (valid-bound-ids?594 (lambda-var-list618 args1035)))) tmp1032) #f) (apply (lambda (_1038 name1039 args1040 e11041 e21042) (values (quote define-form) (wrap597 name1039 w1011 mod1014) (cons (quote #(syntax-object lambda ((top) #(ribcage #(_ name args e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) (wrap597 (cons args1040 (cons e11041 e21042)) w1011 mod1014)) (quote (())) s1012 mod1014)) tmp1032) ((lambda (tmp1044) (if (if tmp1044 (apply (lambda (_1045 name1046) (id?569 name1046)) tmp1044) #f) (apply (lambda (_1047 name1048) (values (quote define-form) (wrap597 name1048 w1011 mod1014) (quote (#(syntax-object if ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)) #(syntax-object #f ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)) #(syntax-object #f ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib mod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote (())) s1012 mod1014)) tmp1044) (syntax-violation #f "source expression failed to match any pattern" tmp1024))) ($sc-dispatch tmp1024 (quote (any any)))))) ($sc-dispatch tmp1024 (quote (any (any . any) any . each-any)))))) ($sc-dispatch tmp1024 (quote (any any any))))) e1009) (if (memv t1023 (quote (define-syntax))) ((lambda (tmp1049) ((lambda (tmp1050) (if (if tmp1050 (apply (lambda (_1051 name1052 val1053) (id?569 name1052)) tmp1050) #f) (apply (lambda (_1054 name1055 val1056) (values (quote define-syntax-form) name1055 val1056 w1011 s1012 mod1014)) tmp1050) (syntax-violation #f "source expression failed to match any pattern" tmp1049))) ($sc-dispatch tmp1049 (quote (any any any))))) e1009) (values (quote call) #f e1009 w1011 s1012 mod1014)))))))))))))) (values (quote call) #f e1009 w1011 s1012 mod1014)))) ((syntax-object?553 e1009) (syntax-type603 (syntax-object-expression554 e1009) r1010 (join-wraps588 w1011 (syntax-object-wrap555 e1009)) #f rib1013 (or (syntax-object-module556 e1009) mod1014))) ((annotation? e1009) (syntax-type603 (annotation-expression e1009) r1010 w1011 (annotation-source e1009) rib1013 mod1014)) ((self-evaluating? e1009) (values (quote constant) #f e1009 w1011 s1012 mod1014)) (else (values (quote other) #f e1009 w1011 s1012 mod1014))))) (chi-when-list602 (lambda (e1057 when-list1058 w1059) (letrec ((f1060 (lambda (when-list1061 situations1062) (if (null? when-list1061) situations1062 (f1060 (cdr when-list1061) (cons (let ((x1063 (car when-list1061))) (cond ((free-id=?592 x1063 (quote #(syntax-object compile ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote compile)) ((free-id=?592 x1063 (quote #(syntax-object load ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote load)) ((free-id=?592 x1063 (quote #(syntax-object eval ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile)))) (quote eval)) (else (syntax-violation (quote eval-when) "invalid situation" e1057 (wrap597 x1063 w1059 #f))))) situations1062)))))) (f1060 when-list1058 (quote ()))))) (chi-install-global601 (lambda (name1064 e1065) (build-global-definition544 #f name1064 (if (let ((v1066 (module-variable (current-module) name1064))) (and v1066 (variable-bound? v1066) (macro? (variable-ref v1066)) (not (eq? (macro-type (variable-ref v1066)) (quote syncase-macro))))) (build-application537 #f (build-primref546 #f (quote make-extended-syncase-macro)) (list (build-application537 #f (build-primref546 #f (quote module-ref)) (list (build-application537 #f (quote current-module) (quote ())) (build-data547 #f name1064))) (build-data547 #f (quote macro)) e1065)) (build-application537 #f (build-primref546 #f (quote make-syncase-macro)) (list (build-data547 #f (quote macro)) e1065)))))) (chi-top-sequence600 (lambda (body1067 r1068 w1069 s1070 m1071 esew1072 mod1073) (build-sequence548 s1070 (letrec ((dobody1074 (lambda (body1075 r1076 w1077 m1078 esew1079 mod1080) (if (null? body1075) (quote ()) (let ((first1081 (chi-top604 (car body1075) r1076 w1077 m1078 esew1079 mod1080))) (cons first1081 (dobody1074 (cdr body1075) r1076 w1077 m1078 esew1079 mod1080))))))) (dobody1074 body1067 r1068 w1069 m1071 esew1072 mod1073))))) (chi-sequence599 (lambda (body1082 r1083 w1084 s1085 mod1086) (build-sequence548 s1085 (letrec ((dobody1087 (lambda (body1088 r1089 w1090 mod1091) (if (null? body1088) (quote ()) (let ((first1092 (chi605 (car body1088) r1089 w1090 mod1091))) (cons first1092 (dobody1087 (cdr body1088) r1089 w1090 mod1091))))))) (dobody1087 body1082 r1083 w1084 mod1086))))) (source-wrap598 (lambda (x1093 w1094 s1095 defmod1096) (wrap597 (if s1095 (make-annotation x1093 s1095 #f) x1093) w1094 defmod1096))) (wrap597 (lambda (x1097 w1098 defmod1099) (cond ((and (null? (wrap-marks572 w1098)) (null? (wrap-subst573 w1098))) x1097) ((syntax-object?553 x1097) (make-syntax-object552 (syntax-object-expression554 x1097) (join-wraps588 w1098 (syntax-object-wrap555 x1097)) (syntax-object-module556 x1097))) ((null? x1097) x1097) (else (make-syntax-object552 x1097 w1098 defmod1099))))) (bound-id-member?596 (lambda (x1100 list1101) (and (not (null? list1101)) (or (bound-id=?593 x1100 (car list1101)) (bound-id-member?596 x1100 (cdr list1101)))))) (distinct-bound-ids?595 (lambda (ids1102) (letrec ((distinct?1103 (lambda (ids1104) (or (null? ids1104) (and (not (bound-id-member?596 (car ids1104) (cdr ids1104))) (distinct?1103 (cdr ids1104))))))) (distinct?1103 ids1102)))) (valid-bound-ids?594 (lambda (ids1105) (and (letrec ((all-ids?1106 (lambda (ids1107) (or (null? ids1107) (and (id?569 (car ids1107)) (all-ids?1106 (cdr ids1107))))))) (all-ids?1106 ids1105)) (distinct-bound-ids?595 ids1105)))) (bound-id=?593 (lambda (i1108 j1109) (if (and (syntax-object?553 i1108) (syntax-object?553 j1109)) (and (eq? (let ((e1110 (syntax-object-expression554 i1108))) (if (annotation? e1110) (annotation-expression e1110) e1110)) (let ((e1111 (syntax-object-expression554 j1109))) (if (annotation? e1111) (annotation-expression e1111) e1111))) (same-marks?590 (wrap-marks572 (syntax-object-wrap555 i1108)) (wrap-marks572 (syntax-object-wrap555 j1109)))) (eq? (let ((e1112 i1108)) (if (annotation? e1112) (annotation-expression e1112) e1112)) (let ((e1113 j1109)) (if (annotation? e1113) (annotation-expression e1113) e1113)))))) (free-id=?592 (lambda (i1114 j1115) (and (eq? (let ((x1116 i1114)) (let ((e1117 (if (syntax-object?553 x1116) (syntax-object-expression554 x1116) x1116))) (if (annotation? e1117) (annotation-expression e1117) e1117))) (let ((x1118 j1115)) (let ((e1119 (if (syntax-object?553 x1118) (syntax-object-expression554 x1118) x1118))) (if (annotation? e1119) (annotation-expression e1119) e1119)))) (eq? (id-var-name591 i1114 (quote (()))) (id-var-name591 j1115 (quote (()))))))) (id-var-name591 (lambda (id1120 w1121) (letrec ((search-vector-rib1124 (lambda (sym1130 subst1131 marks1132 symnames1133 ribcage1134) (let ((n1135 (vector-length symnames1133))) (letrec ((f1136 (lambda (i1137) (cond ((fx=531 i1137 n1135) (search1122 sym1130 (cdr subst1131) marks1132)) ((and (eq? (vector-ref symnames1133 i1137) sym1130) (same-marks?590 marks1132 (vector-ref (ribcage-marks579 ribcage1134) i1137))) (values (vector-ref (ribcage-labels580 ribcage1134) i1137) marks1132)) (else (f1136 (fx+529 i1137 1))))))) (f1136 0))))) (search-list-rib1123 (lambda (sym1138 subst1139 marks1140 symnames1141 ribcage1142) (letrec ((f1143 (lambda (symnames1144 i1145) (cond ((null? symnames1144) (search1122 sym1138 (cdr subst1139) marks1140)) ((and (eq? (car symnames1144) sym1138) (same-marks?590 marks1140 (list-ref (ribcage-marks579 ribcage1142) i1145))) (values (list-ref (ribcage-labels580 ribcage1142) i1145) marks1140)) (else (f1143 (cdr symnames1144) (fx+529 i1145 1))))))) (f1143 symnames1141 0)))) (search1122 (lambda (sym1146 subst1147 marks1148) (if (null? subst1147) (values #f marks1148) (let ((fst1149 (car subst1147))) (if (eq? fst1149 (quote shift)) (search1122 sym1146 (cdr subst1147) (cdr marks1148)) (let ((symnames1150 (ribcage-symnames578 fst1149))) (if (vector? symnames1150) (search-vector-rib1124 sym1146 subst1147 marks1148 symnames1150 fst1149) (search-list-rib1123 sym1146 subst1147 marks1148 symnames1150 fst1149))))))))) (cond ((symbol? id1120) (or (call-with-values (lambda () (search1122 id1120 (wrap-subst573 w1121) (wrap-marks572 w1121))) (lambda (x1152 . ignore1151) x1152)) id1120)) ((syntax-object?553 id1120) (let ((id1153 (let ((e1155 (syntax-object-expression554 id1120))) (if (annotation? e1155) (annotation-expression e1155) e1155))) (w11154 (syntax-object-wrap555 id1120))) (let ((marks1156 (join-marks589 (wrap-marks572 w1121) (wrap-marks572 w11154)))) (call-with-values (lambda () (search1122 id1153 (wrap-subst573 w1121) marks1156)) (lambda (new-id1157 marks1158) (or new-id1157 (call-with-values (lambda () (search1122 id1153 (wrap-subst573 w11154) marks1158)) (lambda (x1160 . ignore1159) x1160)) id1153)))))) ((annotation? id1120) (let ((id1161 (let ((e1162 id1120)) (if (annotation? e1162) (annotation-expression e1162) e1162)))) (or (call-with-values (lambda () (search1122 id1161 (wrap-subst573 w1121) (wrap-marks572 w1121))) (lambda (x1164 . ignore1163) x1164)) id1161))) (else (syntax-violation (quote id-var-name) "invalid id" id1120)))))) (same-marks?590 (lambda (x1165 y1166) (or (eq? x1165 y1166) (and (not (null? x1165)) (not (null? y1166)) (eq? (car x1165) (car y1166)) (same-marks?590 (cdr x1165) (cdr y1166)))))) (join-marks589 (lambda (m11167 m21168) (smart-append587 m11167 m21168))) (join-wraps588 (lambda (w11169 w21170) (let ((m11171 (wrap-marks572 w11169)) (s11172 (wrap-subst573 w11169))) (if (null? m11171) (if (null? s11172) w21170 (make-wrap571 (wrap-marks572 w21170) (smart-append587 s11172 (wrap-subst573 w21170)))) (make-wrap571 (smart-append587 m11171 (wrap-marks572 w21170)) (smart-append587 s11172 (wrap-subst573 w21170))))))) (smart-append587 (lambda (m11173 m21174) (if (null? m21174) m11173 (append m11173 m21174)))) (make-binding-wrap586 (lambda (ids1175 labels1176 w1177) (if (null? ids1175) w1177 (make-wrap571 (wrap-marks572 w1177) (cons (let ((labelvec1178 (list->vector labels1176))) (let ((n1179 (vector-length labelvec1178))) (let ((symnamevec1180 (make-vector n1179)) (marksvec1181 (make-vector n1179))) (begin (letrec ((f1182 (lambda (ids1183 i1184) (if (not (null? ids1183)) (call-with-values (lambda () (id-sym-name&marks570 (car ids1183) w1177)) (lambda (symname1185 marks1186) (begin (vector-set! symnamevec1180 i1184 symname1185) (vector-set! marksvec1181 i1184 marks1186) (f1182 (cdr ids1183) (fx+529 i1184 1))))))))) (f1182 ids1175 0)) (make-ribcage576 symnamevec1180 marksvec1181 labelvec1178))))) (wrap-subst573 w1177)))))) (extend-ribcage!585 (lambda (ribcage1187 id1188 label1189) (begin (set-ribcage-symnames!581 ribcage1187 (cons (let ((e1190 (syntax-object-expression554 id1188))) (if (annotation? e1190) (annotation-expression e1190) e1190)) (ribcage-symnames578 ribcage1187))) (set-ribcage-marks!582 ribcage1187 (cons (wrap-marks572 (syntax-object-wrap555 id1188)) (ribcage-marks579 ribcage1187))) (set-ribcage-labels!583 ribcage1187 (cons label1189 (ribcage-labels580 ribcage1187)))))) (anti-mark584 (lambda (w1191) (make-wrap571 (cons #f (wrap-marks572 w1191)) (cons (quote shift) (wrap-subst573 w1191))))) (set-ribcage-labels!583 (lambda (x1192 update1193) (vector-set! x1192 3 update1193))) (set-ribcage-marks!582 (lambda (x1194 update1195) (vector-set! x1194 2 update1195))) (set-ribcage-symnames!581 (lambda (x1196 update1197) (vector-set! x1196 1 update1197))) (ribcage-labels580 (lambda (x1198) (vector-ref x1198 3))) (ribcage-marks579 (lambda (x1199) (vector-ref x1199 2))) (ribcage-symnames578 (lambda (x1200) (vector-ref x1200 1))) (ribcage?577 (lambda (x1201) (and (vector? x1201) (= (vector-length x1201) 4) (eq? (vector-ref x1201 0) (quote ribcage))))) (make-ribcage576 (lambda (symnames1202 marks1203 labels1204) (vector (quote ribcage) symnames1202 marks1203 labels1204))) (gen-labels575 (lambda (ls1205) (if (null? ls1205) (quote ()) (cons (gen-label574) (gen-labels575 (cdr ls1205)))))) (gen-label574 (lambda () (string #\i))) (wrap-subst573 cdr) (wrap-marks572 car) (make-wrap571 cons) (id-sym-name&marks570 (lambda (x1206 w1207) (if (syntax-object?553 x1206) (values (let ((e1208 (syntax-object-expression554 x1206))) (if (annotation? e1208) (annotation-expression e1208) e1208)) (join-marks589 (wrap-marks572 w1207) (wrap-marks572 (syntax-object-wrap555 x1206)))) (values (let ((e1209 x1206)) (if (annotation? e1209) (annotation-expression e1209) e1209)) (wrap-marks572 w1207))))) (id?569 (lambda (x1210) (cond ((symbol? x1210) #t) ((syntax-object?553 x1210) (symbol? (let ((e1211 (syntax-object-expression554 x1210))) (if (annotation? e1211) (annotation-expression e1211) e1211)))) ((annotation? x1210) (symbol? (annotation-expression x1210))) (else #f)))) (nonsymbol-id?568 (lambda (x1212) (and (syntax-object?553 x1212) (symbol? (let ((e1213 (syntax-object-expression554 x1212))) (if (annotation? e1213) (annotation-expression e1213) e1213)))))) (global-extend567 (lambda (type1214 sym1215 val1216) (put-global-definition-hook535 sym1215 type1214 val1216))) (lookup566 (lambda (x1217 r1218 mod1219) (cond ((assq x1217 r1218) => cdr) ((symbol? x1217) (or (get-global-definition-hook536 x1217 mod1219) (quote (global)))) (else (quote (displaced-lexical)))))) (macros-only-env565 (lambda (r1220) (if (null? r1220) (quote ()) (let ((a1221 (car r1220))) (if (eq? (cadr a1221) (quote macro)) (cons a1221 (macros-only-env565 (cdr r1220))) (macros-only-env565 (cdr r1220))))))) (extend-var-env564 (lambda (labels1222 vars1223 r1224) (if (null? labels1222) r1224 (extend-var-env564 (cdr labels1222) (cdr vars1223) (cons (cons (car labels1222) (cons (quote lexical) (car vars1223))) r1224))))) (extend-env563 (lambda (labels1225 bindings1226 r1227) (if (null? labels1225) r1227 (extend-env563 (cdr labels1225) (cdr bindings1226) (cons (cons (car labels1225) (car bindings1226)) r1227))))) (binding-value562 cdr) (binding-type561 car) (source-annotation560 (lambda (x1228) (cond ((annotation? x1228) (annotation-source x1228)) ((syntax-object?553 x1228) (source-annotation560 (syntax-object-expression554 x1228))) (else #f)))) (set-syntax-object-module!559 (lambda (x1229 update1230) (vector-set! x1229 3 update1230))) (set-syntax-object-wrap!558 (lambda (x1231 update1232) (vector-set! x1231 2 update1232))) (set-syntax-object-expression!557 (lambda (x1233 update1234) (vector-set! x1233 1 update1234))) (syntax-object-module556 (lambda (x1235) (vector-ref x1235 3))) (syntax-object-wrap555 (lambda (x1236) (vector-ref x1236 2))) (syntax-object-expression554 (lambda (x1237) (vector-ref x1237 1))) (syntax-object?553 (lambda (x1238) (and (vector? x1238) (= (vector-length x1238) 4) (eq? (vector-ref x1238 0) (quote syntax-object))))) (make-syntax-object552 (lambda (expression1239 wrap1240 module1241) (vector (quote syntax-object) expression1239 wrap1240 module1241))) (build-letrec551 (lambda (src1242 ids1243 vars1244 val-exps1245 body-exp1246) (if (null? vars1244) body-exp1246 (let ((t1247 (fluid-ref *mode*528))) (if (memv t1247 (quote (c))) ((@ (language tree-il) make-letrec) src1242 ids1243 vars1244 val-exps1245 body-exp1246) (list (quote letrec) (map list vars1244 val-exps1245) body-exp1246)))))) (build-named-let550 (lambda (src1248 ids1249 vars1250 val-exps1251 body-exp1252) (let ((f1253 (car vars1250)) (f-name1254 (car ids1249)) (vars1255 (cdr vars1250)) (ids1256 (cdr ids1249))) (let ((t1257 (fluid-ref *mode*528))) (if (memv t1257 (quote (c))) ((@ (language tree-il) make-letrec) src1248 (list f-name1254) (list f1253) (list (build-lambda545 src1248 ids1256 vars1255 #f body-exp1252)) (build-application537 src1248 (build-lexical-reference539 (quote fun) src1248 f-name1254 f1253) val-exps1251)) (list (quote let) f1253 (map list vars1255 val-exps1251) body-exp1252)))))) (build-let549 (lambda (src1258 ids1259 vars1260 val-exps1261 body-exp1262) (if (null? vars1260) body-exp1262 (let ((t1263 (fluid-ref *mode*528))) (if (memv t1263 (quote (c))) ((@ (language tree-il) make-let) src1258 ids1259 vars1260 val-exps1261 body-exp1262) (list (quote let) (map list vars1260 val-exps1261) body-exp1262)))))) (build-sequence548 (lambda (src1264 exps1265) (if (null? (cdr exps1265)) (car exps1265) (let ((t1266 (fluid-ref *mode*528))) (if (memv t1266 (quote (c))) ((@ (language tree-il) make-sequence) src1264 exps1265) (cons (quote begin) exps1265)))))) (build-data547 (lambda (src1267 exp1268) (let ((t1269 (fluid-ref *mode*528))) (if (memv t1269 (quote (c))) ((@ (language tree-il) make-const) src1267 exp1268) (if (and (self-evaluating? exp1268) (not (vector? exp1268))) exp1268 (list (quote quote) exp1268)))))) (build-primref546 (lambda (src1270 name1271) (let ((t1272 (fluid-ref *mode*528))) (if (memv t1272 (quote (c))) ((@ (language tree-il) make-primitive-ref) src1270 name1271) (build-global-reference542 src1270 name1271 (quote (hygiene guile))))))) (build-lambda545 (lambda (src1273 ids1274 vars1275 docstring1276 exp1277) (let ((t1278 (fluid-ref *mode*528))) (if (memv t1278 (quote (c))) ((@ (language tree-il) make-lambda) src1273 ids1274 vars1275 (if docstring1276 (list (cons (quote documentation) docstring1276)) (quote ())) exp1277) (cons (quote lambda) (cons vars1275 (append (if docstring1276 (list docstring1276) (quote ())) (list exp1277)))))))) (build-global-definition544 (lambda (source1279 var1280 exp1281) (let ((t1282 (fluid-ref *mode*528))) (if (memv t1282 (quote (c))) ((@ (language tree-il) make-toplevel-define) source1279 var1280 exp1281) (list (quote define) var1280 exp1281))))) (build-global-assignment543 (lambda (source1283 var1284 exp1285 mod1286) (analyze-variable541 mod1286 var1284 (lambda (mod1287 var1288 public?1289) (let ((t1290 (fluid-ref *mode*528))) (if (memv t1290 (quote (c))) ((@ (language tree-il) make-module-set) source1283 mod1287 var1288 public?1289 exp1285) (list (quote set!) (list (if public?1289 (quote @) (quote @@)) mod1287 var1288) exp1285)))) (lambda (var1291) (let ((t1292 (fluid-ref *mode*528))) (if (memv t1292 (quote (c))) ((@ (language tree-il) make-toplevel-set) source1283 var1291 exp1285) (list (quote set!) var1291 exp1285))))))) (build-global-reference542 (lambda (source1293 var1294 mod1295) (analyze-variable541 mod1295 var1294 (lambda (mod1296 var1297 public?1298) (let ((t1299 (fluid-ref *mode*528))) (if (memv t1299 (quote (c))) ((@ (language tree-il) make-module-ref) source1293 mod1296 var1297 public?1298) (list (if public?1298 (quote @) (quote @@)) mod1296 var1297)))) (lambda (var1300) (let ((t1301 (fluid-ref *mode*528))) (if (memv t1301 (quote (c))) ((@ (language tree-il) make-toplevel-ref) source1293 var1300) var1300)))))) (analyze-variable541 (lambda (mod1302 var1303 modref-cont1304 bare-cont1305) (if (not mod1302) (bare-cont1305 var1303) (let ((kind1306 (car mod1302)) (mod1307 (cdr mod1302))) (let ((t1308 kind1306)) (if (memv t1308 (quote (public))) (modref-cont1304 mod1307 var1303 #t) (if (memv t1308 (quote (private))) (if (not (equal? mod1307 (module-name (current-module)))) (modref-cont1304 mod1307 var1303 #f) (bare-cont1305 var1303)) (if (memv t1308 (quote (bare))) (bare-cont1305 var1303) (if (memv t1308 (quote (hygiene))) (if (and (not (equal? mod1307 (module-name (current-module)))) (module-variable (resolve-module mod1307) var1303)) (modref-cont1304 mod1307 var1303 #f) (bare-cont1305 var1303)) (syntax-violation #f "bad module kind" var1303 mod1307)))))))))) (build-lexical-assignment540 (lambda (source1309 name1310 var1311 exp1312) (let ((t1313 (fluid-ref *mode*528))) (if (memv t1313 (quote (c))) ((@ (language tree-il) make-lexical-set) source1309 name1310 var1311 exp1312) (list (quote set!) var1311 exp1312))))) (build-lexical-reference539 (lambda (type1314 source1315 name1316 var1317) (let ((t1318 (fluid-ref *mode*528))) (if (memv t1318 (quote (c))) ((@ (language tree-il) make-lexical-ref) source1315 name1316 var1317) var1317)))) (build-conditional538 (lambda (source1319 test-exp1320 then-exp1321 else-exp1322) (let ((t1323 (fluid-ref *mode*528))) (if (memv t1323 (quote (c))) ((@ (language tree-il) make-conditional) source1319 test-exp1320 then-exp1321 else-exp1322) (list (quote if) test-exp1320 then-exp1321 else-exp1322))))) (build-application537 (lambda (source1324 fun-exp1325 arg-exps1326) (let ((t1327 (fluid-ref *mode*528))) (if (memv t1327 (quote (c))) ((@ (language tree-il) make-application) source1324 fun-exp1325 arg-exps1326) (cons fun-exp1325 arg-exps1326))))) (get-global-definition-hook536 (lambda (symbol1328 module1329) (begin (if (and (not module1329) (current-module)) (warn "module system is booted, we should have a module" symbol1328)) (let ((v1330 (module-variable (if module1329 (resolve-module (cdr module1329)) (current-module)) symbol1328))) (and v1330 (variable-bound? v1330) (let ((val1331 (variable-ref v1330))) (and (macro? val1331) (syncase-macro-type val1331) (cons (syncase-macro-type val1331) (syncase-macro-binding val1331))))))))) (put-global-definition-hook535 (lambda (symbol1332 type1333 val1334) (let ((existing1335 (let ((v1336 (module-variable (current-module) symbol1332))) (and v1336 (variable-bound? v1336) (let ((val1337 (variable-ref v1336))) (and (macro? val1337) (not (syncase-macro-type val1337)) val1337)))))) (module-define! (current-module) symbol1332 (if existing1335 (make-extended-syncase-macro existing1335 type1333 val1334) (make-syncase-macro type1333 val1334)))))) (local-eval-hook534 (lambda (x1338 mod1339) (primitive-eval (list noexpand527 (let ((t1340 (fluid-ref *mode*528))) (if (memv t1340 (quote (c))) ((@ (language tree-il) tree-il->scheme) x1338) x1338)))))) (top-level-eval-hook533 (lambda (x1341 mod1342) (primitive-eval (list noexpand527 (let ((t1343 (fluid-ref *mode*528))) (if (memv t1343 (quote (c))) ((@ (language tree-il) tree-il->scheme) x1341) x1341)))))) (fx<532 <) (fx=531 =) (fx-530 -) (fx+529 +) (*mode*528 (make-fluid)) (noexpand527 "noexpand")) (begin (global-extend567 (quote local-syntax) (quote letrec-syntax) #t) (global-extend567 (quote local-syntax) (quote let-syntax) #f) (global-extend567 (quote core) (quote fluid-let-syntax) (lambda (e1344 r1345 w1346 s1347 mod1348) ((lambda (tmp1349) ((lambda (tmp1350) (if (if tmp1350 (apply (lambda (_1351 var1352 val1353 e11354 e21355) (valid-bound-ids?594 var1352)) tmp1350) #f) (apply (lambda (_1357 var1358 val1359 e11360 e21361) (let ((names1362 (map (lambda (x1363) (id-var-name591 x1363 w1346)) var1358))) (begin (for-each (lambda (id1365 n1366) (let ((t1367 (binding-type561 (lookup566 n1366 r1345 mod1348)))) (if (memv t1367 (quote (displaced-lexical))) (syntax-violation (quote fluid-let-syntax) "identifier out of context" e1344 (source-wrap598 id1365 w1346 s1347 mod1348))))) var1358 names1362) (chi-body609 (cons e11360 e21361) (source-wrap598 e1344 w1346 s1347 mod1348) (extend-env563 names1362 (let ((trans-r1370 (macros-only-env565 r1345))) (map (lambda (x1371) (cons (quote macro) (eval-local-transformer612 (chi605 x1371 trans-r1370 w1346 mod1348) mod1348))) val1359)) r1345) w1346 mod1348)))) tmp1350) ((lambda (_1373) (syntax-violation (quote fluid-let-syntax) "bad syntax" (source-wrap598 e1344 w1346 s1347 mod1348))) tmp1349))) ($sc-dispatch tmp1349 (quote (any #(each (any any)) any . each-any))))) e1344))) (global-extend567 (quote core) (quote quote) (lambda (e1374 r1375 w1376 s1377 mod1378) ((lambda (tmp1379) ((lambda (tmp1380) (if tmp1380 (apply (lambda (_1381 e1382) (build-data547 s1377 (strip616 e1382 w1376))) tmp1380) ((lambda (_1383) (syntax-violation (quote quote) "bad syntax" (source-wrap598 e1374 w1376 s1377 mod1378))) tmp1379))) ($sc-dispatch tmp1379 (quote (any any))))) e1374))) (global-extend567 (quote core) (quote syntax) (letrec ((regen1391 (lambda (x1392) (let ((t1393 (car x1392))) (if (memv t1393 (quote (ref))) (build-lexical-reference539 (quote value) #f (cadr x1392) (cadr x1392)) (if (memv t1393 (quote (primitive))) (build-primref546 #f (cadr x1392)) (if (memv t1393 (quote (quote))) (build-data547 #f (cadr x1392)) (if (memv t1393 (quote (lambda))) (build-lambda545 #f (cadr x1392) (cadr x1392) #f (regen1391 (caddr x1392))) (if (memv t1393 (quote (map))) (let ((ls1394 (map regen1391 (cdr x1392)))) (build-application537 #f (build-primref546 #f (quote map)) ls1394)) (build-application537 #f (build-primref546 #f (car x1392)) (map regen1391 (cdr x1392))))))))))) (gen-vector1390 (lambda (x1395) (cond ((eq? (car x1395) (quote list)) (cons (quote vector) (cdr x1395))) ((eq? (car x1395) (quote quote)) (list (quote quote) (list->vector (cadr x1395)))) (else (list (quote list->vector) x1395))))) (gen-append1389 (lambda (x1396 y1397) (if (equal? y1397 (quote (quote ()))) x1396 (list (quote append) x1396 y1397)))) (gen-cons1388 (lambda (x1398 y1399) (let ((t1400 (car y1399))) (if (memv t1400 (quote (quote))) (if (eq? (car x1398) (quote quote)) (list (quote quote) (cons (cadr x1398) (cadr y1399))) (if (eq? (cadr y1399) (quote ())) (list (quote list) x1398) (list (quote cons) x1398 y1399))) (if (memv t1400 (quote (list))) (cons (quote list) (cons x1398 (cdr y1399))) (list (quote cons) x1398 y1399)))))) (gen-map1387 (lambda (e1401 map-env1402) (let ((formals1403 (map cdr map-env1402)) (actuals1404 (map (lambda (x1405) (list (quote ref) (car x1405))) map-env1402))) (cond ((eq? (car e1401) (quote ref)) (car actuals1404)) ((and-map (lambda (x1406) (and (eq? (car x1406) (quote ref)) (memq (cadr x1406) formals1403))) (cdr e1401)) (cons (quote map) (cons (list (quote primitive) (car e1401)) (map (let ((r1407 (map cons formals1403 actuals1404))) (lambda (x1408) (cdr (assq (cadr x1408) r1407)))) (cdr e1401))))) (else (cons (quote map) (cons (list (quote lambda) formals1403 e1401) actuals1404))))))) (gen-mappend1386 (lambda (e1409 map-env1410) (list (quote apply) (quote (primitive append)) (gen-map1387 e1409 map-env1410)))) (gen-ref1385 (lambda (src1411 var1412 level1413 maps1414) (if (fx=531 level1413 0) (values var1412 maps1414) (if (null? maps1414) (syntax-violation (quote syntax) "missing ellipsis" src1411) (call-with-values (lambda () (gen-ref1385 src1411 var1412 (fx-530 level1413 1) (cdr maps1414))) (lambda (outer-var1415 outer-maps1416) (let ((b1417 (assq outer-var1415 (car maps1414)))) (if b1417 (values (cdr b1417) maps1414) (let ((inner-var1418 (gen-var617 (quote tmp)))) (values inner-var1418 (cons (cons (cons outer-var1415 inner-var1418) (car maps1414)) outer-maps1416))))))))))) (gen-syntax1384 (lambda (src1419 e1420 r1421 maps1422 ellipsis?1423 mod1424) (if (id?569 e1420) (let ((label1425 (id-var-name591 e1420 (quote (()))))) (let ((b1426 (lookup566 label1425 r1421 mod1424))) (if (eq? (binding-type561 b1426) (quote syntax)) (call-with-values (lambda () (let ((var.lev1427 (binding-value562 b1426))) (gen-ref1385 src1419 (car var.lev1427) (cdr var.lev1427) maps1422))) (lambda (var1428 maps1429) (values (list (quote ref) var1428) maps1429))) (if (ellipsis?1423 e1420) (syntax-violation (quote syntax) "misplaced ellipsis" src1419) (values (list (quote quote) e1420) maps1422))))) ((lambda (tmp1430) ((lambda (tmp1431) (if (if tmp1431 (apply (lambda (dots1432 e1433) (ellipsis?1423 dots1432)) tmp1431) #f) (apply (lambda (dots1434 e1435) (gen-syntax1384 src1419 e1435 r1421 maps1422 (lambda (x1436) #f) mod1424)) tmp1431) ((lambda (tmp1437) (if (if tmp1437 (apply (lambda (x1438 dots1439 y1440) (ellipsis?1423 dots1439)) tmp1437) #f) (apply (lambda (x1441 dots1442 y1443) (letrec ((f1444 (lambda (y1445 k1446) ((lambda (tmp1450) ((lambda (tmp1451) (if (if tmp1451 (apply (lambda (dots1452 y1453) (ellipsis?1423 dots1452)) tmp1451) #f) (apply (lambda (dots1454 y1455) (f1444 y1455 (lambda (maps1456) (call-with-values (lambda () (k1446 (cons (quote ()) maps1456))) (lambda (x1457 maps1458) (if (null? (car maps1458)) (syntax-violation (quote syntax) "extra ellipsis" src1419) (values (gen-mappend1386 x1457 (car maps1458)) (cdr maps1458)))))))) tmp1451) ((lambda (_1459) (call-with-values (lambda () (gen-syntax1384 src1419 y1445 r1421 maps1422 ellipsis?1423 mod1424)) (lambda (y1460 maps1461) (call-with-values (lambda () (k1446 maps1461)) (lambda (x1462 maps1463) (values (gen-append1389 x1462 y1460) maps1463)))))) tmp1450))) ($sc-dispatch tmp1450 (quote (any . any))))) y1445)))) (f1444 y1443 (lambda (maps1447) (call-with-values (lambda () (gen-syntax1384 src1419 x1441 r1421 (cons (quote ()) maps1447) ellipsis?1423 mod1424)) (lambda (x1448 maps1449) (if (null? (car maps1449)) (syntax-violation (quote syntax) "extra ellipsis" src1419) (values (gen-map1387 x1448 (car maps1449)) (cdr maps1449))))))))) tmp1437) ((lambda (tmp1464) (if tmp1464 (apply (lambda (x1465 y1466) (call-with-values (lambda () (gen-syntax1384 src1419 x1465 r1421 maps1422 ellipsis?1423 mod1424)) (lambda (x1467 maps1468) (call-with-values (lambda () (gen-syntax1384 src1419 y1466 r1421 maps1468 ellipsis?1423 mod1424)) (lambda (y1469 maps1470) (values (gen-cons1388 x1467 y1469) maps1470)))))) tmp1464) ((lambda (tmp1471) (if tmp1471 (apply (lambda (e11472 e21473) (call-with-values (lambda () (gen-syntax1384 src1419 (cons e11472 e21473) r1421 maps1422 ellipsis?1423 mod1424)) (lambda (e1475 maps1476) (values (gen-vector1390 e1475) maps1476)))) tmp1471) ((lambda (_1477) (values (list (quote quote) e1420) maps1422)) tmp1430))) ($sc-dispatch tmp1430 (quote #(vector (any . each-any))))))) ($sc-dispatch tmp1430 (quote (any . any)))))) ($sc-dispatch tmp1430 (quote (any any . any)))))) ($sc-dispatch tmp1430 (quote (any any))))) e1420))))) (lambda (e1478 r1479 w1480 s1481 mod1482) (let ((e1483 (source-wrap598 e1478 w1480 s1481 mod1482))) ((lambda (tmp1484) ((lambda (tmp1485) (if tmp1485 (apply (lambda (_1486 x1487) (call-with-values (lambda () (gen-syntax1384 e1483 x1487 r1479 (quote ()) ellipsis?614 mod1482)) (lambda (e1488 maps1489) (regen1391 e1488)))) tmp1485) ((lambda (_1490) (syntax-violation (quote syntax) "bad `syntax' form" e1483)) tmp1484))) ($sc-dispatch tmp1484 (quote (any any))))) e1483))))) (global-extend567 (quote core) (quote lambda) (lambda (e1491 r1492 w1493 s1494 mod1495) ((lambda (tmp1496) ((lambda (tmp1497) (if tmp1497 (apply (lambda (_1498 c1499) (chi-lambda-clause610 (source-wrap598 e1491 w1493 s1494 mod1495) #f c1499 r1492 w1493 mod1495 (lambda (names1500 vars1501 docstring1502 body1503) (build-lambda545 s1494 names1500 vars1501 docstring1502 body1503)))) tmp1497) (syntax-violation #f "source expression failed to match any pattern" tmp1496))) ($sc-dispatch tmp1496 (quote (any . any))))) e1491))) (global-extend567 (quote core) (quote let) (letrec ((chi-let1504 (lambda (e1505 r1506 w1507 s1508 mod1509 constructor1510 ids1511 vals1512 exps1513) (if (not (valid-bound-ids?594 ids1511)) (syntax-violation (quote let) "duplicate bound variable" e1505) (let ((labels1514 (gen-labels575 ids1511)) (new-vars1515 (map gen-var617 ids1511))) (let ((nw1516 (make-binding-wrap586 ids1511 labels1514 w1507)) (nr1517 (extend-var-env564 labels1514 new-vars1515 r1506))) (constructor1510 s1508 (map syntax->datum ids1511) new-vars1515 (map (lambda (x1518) (chi605 x1518 r1506 w1507 mod1509)) vals1512) (chi-body609 exps1513 (source-wrap598 e1505 nw1516 s1508 mod1509) nr1517 nw1516 mod1509)))))))) (lambda (e1519 r1520 w1521 s1522 mod1523) ((lambda (tmp1524) ((lambda (tmp1525) (if tmp1525 (apply (lambda (_1526 id1527 val1528 e11529 e21530) (chi-let1504 e1519 r1520 w1521 s1522 mod1523 build-let549 id1527 val1528 (cons e11529 e21530))) tmp1525) ((lambda (tmp1534) (if (if tmp1534 (apply (lambda (_1535 f1536 id1537 val1538 e11539 e21540) (id?569 f1536)) tmp1534) #f) (apply (lambda (_1541 f1542 id1543 val1544 e11545 e21546) (chi-let1504 e1519 r1520 w1521 s1522 mod1523 build-named-let550 (cons f1542 id1543) val1544 (cons e11545 e21546))) tmp1534) ((lambda (_1550) (syntax-violation (quote let) "bad let" (source-wrap598 e1519 w1521 s1522 mod1523))) tmp1524))) ($sc-dispatch tmp1524 (quote (any any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp1524 (quote (any #(each (any any)) any . each-any))))) e1519)))) (global-extend567 (quote core) (quote letrec) (lambda (e1551 r1552 w1553 s1554 mod1555) ((lambda (tmp1556) ((lambda (tmp1557) (if tmp1557 (apply (lambda (_1558 id1559 val1560 e11561 e21562) (let ((ids1563 id1559)) (if (not (valid-bound-ids?594 ids1563)) (syntax-violation (quote letrec) "duplicate bound variable" e1551) (let ((labels1565 (gen-labels575 ids1563)) (new-vars1566 (map gen-var617 ids1563))) (let ((w1567 (make-binding-wrap586 ids1563 labels1565 w1553)) (r1568 (extend-var-env564 labels1565 new-vars1566 r1552))) (build-letrec551 s1554 (map syntax->datum ids1563) new-vars1566 (map (lambda (x1569) (chi605 x1569 r1568 w1567 mod1555)) val1560) (chi-body609 (cons e11561 e21562) (source-wrap598 e1551 w1567 s1554 mod1555) r1568 w1567 mod1555))))))) tmp1557) ((lambda (_1572) (syntax-violation (quote letrec) "bad letrec" (source-wrap598 e1551 w1553 s1554 mod1555))) tmp1556))) ($sc-dispatch tmp1556 (quote (any #(each (any any)) any . each-any))))) e1551))) (global-extend567 (quote core) (quote set!) (lambda (e1573 r1574 w1575 s1576 mod1577) ((lambda (tmp1578) ((lambda (tmp1579) (if (if tmp1579 (apply (lambda (_1580 id1581 val1582) (id?569 id1581)) tmp1579) #f) (apply (lambda (_1583 id1584 val1585) (let ((val1586 (chi605 val1585 r1574 w1575 mod1577)) (n1587 (id-var-name591 id1584 w1575))) (let ((b1588 (lookup566 n1587 r1574 mod1577))) (let ((t1589 (binding-type561 b1588))) (if (memv t1589 (quote (lexical))) (build-lexical-assignment540 s1576 (syntax->datum id1584) (binding-value562 b1588) val1586) (if (memv t1589 (quote (global))) (build-global-assignment543 s1576 n1587 val1586 mod1577) (if (memv t1589 (quote (displaced-lexical))) (syntax-violation (quote set!) "identifier out of context" (wrap597 id1584 w1575 mod1577)) (syntax-violation (quote set!) "bad set!" (source-wrap598 e1573 w1575 s1576 mod1577))))))))) tmp1579) ((lambda (tmp1590) (if tmp1590 (apply (lambda (_1591 head1592 tail1593 val1594) (call-with-values (lambda () (syntax-type603 head1592 r1574 (quote (())) #f #f mod1577)) (lambda (type1595 value1596 ee1597 ww1598 ss1599 modmod1600) (let ((t1601 type1595)) (if (memv t1601 (quote (module-ref))) (let ((val1602 (chi605 val1594 r1574 w1575 mod1577))) (call-with-values (lambda () (value1596 (cons head1592 tail1593))) (lambda (id1604 mod1605) (build-global-assignment543 s1576 id1604 val1602 mod1605)))) (build-application537 s1576 (chi605 (list (quote #(syntax-object setter ((top) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type value ee ww ss modmod) #((top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i")) #(ribcage #(_ head tail val) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(e r w s mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) head1592) r1574 w1575 mod1577) (map (lambda (e1606) (chi605 e1606 r1574 w1575 mod1577)) (append tail1593 (list val1594))))))))) tmp1590) ((lambda (_1608) (syntax-violation (quote set!) "bad set!" (source-wrap598 e1573 w1575 s1576 mod1577))) tmp1578))) ($sc-dispatch tmp1578 (quote (any (any . each-any) any)))))) ($sc-dispatch tmp1578 (quote (any any any))))) e1573))) (global-extend567 (quote module-ref) (quote @) (lambda (e1609) ((lambda (tmp1610) ((lambda (tmp1611) (if (if tmp1611 (apply (lambda (_1612 mod1613 id1614) (and (and-map id?569 mod1613) (id?569 id1614))) tmp1611) #f) (apply (lambda (_1616 mod1617 id1618) (values (syntax->datum id1618) (syntax->datum (cons (quote #(syntax-object public ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod1617)))) tmp1611) (syntax-violation #f "source expression failed to match any pattern" tmp1610))) ($sc-dispatch tmp1610 (quote (any each-any any))))) e1609))) (global-extend567 (quote module-ref) (quote @@) (lambda (e1620) ((lambda (tmp1621) ((lambda (tmp1622) (if (if tmp1622 (apply (lambda (_1623 mod1624 id1625) (and (and-map id?569 mod1624) (id?569 id1625))) tmp1622) #f) (apply (lambda (_1627 mod1628 id1629) (values (syntax->datum id1629) (syntax->datum (cons (quote #(syntax-object private ((top) #(ribcage #(_ mod id) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) mod1628)))) tmp1622) (syntax-violation #f "source expression failed to match any pattern" tmp1621))) ($sc-dispatch tmp1621 (quote (any each-any any))))) e1620))) (global-extend567 (quote begin) (quote begin) (quote ())) (global-extend567 (quote define) (quote define) (quote ())) (global-extend567 (quote define-syntax) (quote define-syntax) (quote ())) (global-extend567 (quote eval-when) (quote eval-when) (quote ())) (global-extend567 (quote core) (quote syntax-case) (letrec ((gen-syntax-case1634 (lambda (x1635 keys1636 clauses1637 r1638 mod1639) (if (null? clauses1637) (build-application537 #f (build-primref546 #f (quote syntax-violation)) (list #f "source expression failed to match any pattern" x1635)) ((lambda (tmp1640) ((lambda (tmp1641) (if tmp1641 (apply (lambda (pat1642 exp1643) (if (and (id?569 pat1642) (and-map (lambda (x1644) (not (free-id=?592 pat1642 x1644))) (cons (quote #(syntax-object ... ((top) #(ribcage #(pat exp) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x keys clauses r mod) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (gen-syntax-case gen-clause build-dispatch-call convert-pattern) ((top) (top) (top) (top)) ("i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-module! set-syntax-object-wrap! set-syntax-object-expression! syntax-object-module syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference analyze-variable build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook local-eval-hook top-level-eval-hook fx< fx= fx- fx+ *mode* noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure and-map*) ((top) (top)) ("i" "i"))) (hygiene guile))) keys1636))) (let ((labels1645 (list (gen-label574))) (var1646 (gen-var617 pat1642))) (build-application537 #f (build-lambda545 #f (list (syntax->datum pat1642)) (list var1646) #f (chi605 exp1643 (extend-env563 labels1645 (list (cons (quote syntax) (cons var1646 0))) r1638) (make-binding-wrap586 (list pat1642) labels1645 (quote (()))) mod1639)) (list x1635))) (gen-clause1633 x1635 keys1636 (cdr clauses1637) r1638 pat1642 #t exp1643 mod1639))) tmp1641) ((lambda (tmp1647) (if tmp1647 (apply (lambda (pat1648 fender1649 exp1650) (gen-clause1633 x1635 keys1636 (cdr clauses1637) r1638 pat1648 fender1649 exp1650 mod1639)) tmp1647) ((lambda (_1651) (syntax-violation (quote syntax-case) "invalid clause" (car clauses1637))) tmp1640))) ($sc-dispatch tmp1640 (quote (any any any)))))) ($sc-dispatch tmp1640 (quote (any any))))) (car clauses1637))))) (gen-clause1633 (lambda (x1652 keys1653 clauses1654 r1655 pat1656 fender1657 exp1658 mod1659) (call-with-values (lambda () (convert-pattern1631 pat1656 keys1653)) (lambda (p1660 pvars1661) (cond ((not (distinct-bound-ids?595 (map car pvars1661))) (syntax-violation (quote syntax-case) "duplicate pattern variable" pat1656)) ((not (and-map (lambda (x1662) (not (ellipsis?614 (car x1662)))) pvars1661)) (syntax-violation (quote syntax-case) "misplaced ellipsis" pat1656)) (else (let ((y1663 (gen-var617 (quote tmp)))) (build-application537 #f (build-lambda545 #f (list (quote tmp)) (list y1663) #f (let ((y1664 (build-lexical-reference539 (quote value) #f (quote tmp) y1663))) (build-conditional538 #f ((lambda (tmp1665) ((lambda (tmp1666) (if tmp1666 (apply (lambda () y1664) tmp1666) ((lambda (_1667) (build-conditional538 #f y1664 (build-dispatch-call1632 pvars1661 fender1657 y1664 r1655 mod1659) (build-data547 #f #f))) tmp1665))) ($sc-dispatch tmp1665 (quote #(atom #t))))) fender1657) (build-dispatch-call1632 pvars1661 exp1658 y1664 r1655 mod1659) (gen-syntax-case1634 x1652 keys1653 clauses1654 r1655 mod1659)))) (list (if (eq? p1660 (quote any)) (build-application537 #f (build-primref546 #f (quote list)) (list x1652)) (build-application537 #f (build-primref546 #f (quote $sc-dispatch)) (list x1652 (build-data547 #f p1660))))))))))))) (build-dispatch-call1632 (lambda (pvars1668 exp1669 y1670 r1671 mod1672) (let ((ids1673 (map car pvars1668)) (levels1674 (map cdr pvars1668))) (let ((labels1675 (gen-labels575 ids1673)) (new-vars1676 (map gen-var617 ids1673))) (build-application537 #f (build-primref546 #f (quote apply)) (list (build-lambda545 #f (map syntax->datum ids1673) new-vars1676 #f (chi605 exp1669 (extend-env563 labels1675 (map (lambda (var1677 level1678) (cons (quote syntax) (cons var1677 level1678))) new-vars1676 (map cdr pvars1668)) r1671) (make-binding-wrap586 ids1673 labels1675 (quote (()))) mod1672)) y1670)))))) (convert-pattern1631 (lambda (pattern1679 keys1680) (letrec ((cvt1681 (lambda (p1682 n1683 ids1684) (if (id?569 p1682) (if (bound-id-member?596 p1682 keys1680) (values (vector (quote free-id) p1682) ids1684) (values (quote any) (cons (cons p1682 n1683) ids1684))) ((lambda (tmp1685) ((lambda (tmp1686) (if (if tmp1686 (apply (lambda (x1687 dots1688) (ellipsis?614 dots1688)) tmp1686) #f) (apply (lambda (x1689 dots1690) (call-with-values (lambda () (cvt1681 x1689 (fx+529 n1683 1) ids1684)) (lambda (p1691 ids1692) (values (if (eq? p1691 (quote any)) (quote each-any) (vector (quote each) p1691)) ids1692)))) tmp1686) ((lambda (tmp1693) (if tmp1693 (apply (lambda (x1694 y1695) (call-with-values (lambda () (cvt1681 y1695 n1683 ids1684)) (lambda (y1696 ids1697) (call-with-values (lambda () (cvt1681 x1694 n1683 ids1697)) (lambda (x1698 ids1699) (values (cons x1698 y1696) ids1699)))))) tmp1693) ((lambda (tmp1700) (if tmp1700 (apply (lambda () (values (quote ()) ids1684)) tmp1700) ((lambda (tmp1701) (if tmp1701 (apply (lambda (x1702) (call-with-values (lambda () (cvt1681 x1702 n1683 ids1684)) (lambda (p1704 ids1705) (values (vector (quote vector) p1704) ids1705)))) tmp1701) ((lambda (x1706) (values (vector (quote atom) (strip616 p1682 (quote (())))) ids1684)) tmp1685))) ($sc-dispatch tmp1685 (quote #(vector each-any)))))) ($sc-dispatch tmp1685 (quote ()))))) ($sc-dispatch tmp1685 (quote (any . any)))))) ($sc-dispatch tmp1685 (quote (any any))))) p1682))))) (cvt1681 pattern1679 0 (quote ())))))) (lambda (e1707 r1708 w1709 s1710 mod1711) (let ((e1712 (source-wrap598 e1707 w1709 s1710 mod1711))) ((lambda (tmp1713) ((lambda (tmp1714) (if tmp1714 (apply (lambda (_1715 val1716 key1717 m1718) (if (and-map (lambda (x1719) (and (id?569 x1719) (not (ellipsis?614 x1719)))) key1717) (let ((x1721 (gen-var617 (quote tmp)))) (build-application537 s1710 (build-lambda545 #f (list (quote tmp)) (list x1721) #f (gen-syntax-case1634 (build-lexical-reference539 (quote value) #f (quote tmp) x1721) key1717 m1718 r1708 mod1711)) (list (chi605 val1716 r1708 (quote (())) mod1711)))) (syntax-violation (quote syntax-case) "invalid literals list" e1712))) tmp1714) (syntax-violation #f "source expression failed to match any pattern" tmp1713))) ($sc-dispatch tmp1713 (quote (any any each-any . each-any))))) e1712))))) (set! sc-expand (lambda (x1725 . rest1724) (if (and (pair? x1725) (equal? (car x1725) noexpand527)) (cadr x1725) (let ((m1726 (if (null? rest1724) (quote e) (car rest1724))) (esew1727 (if (or (null? rest1724) (null? (cdr rest1724))) (quote (eval)) (cadr rest1724)))) (with-fluid* *mode*528 m1726 (lambda () (chi-top604 x1725 (quote ()) (quote ((top))) m1726 esew1727 (cons (quote hygiene) (module-name (current-module)))))))))) (set! identifier? (lambda (x1728) (nonsymbol-id?568 x1728))) (set! datum->syntax (lambda (id1729 datum1730) (make-syntax-object552 datum1730 (syntax-object-wrap555 id1729) #f))) (set! syntax->datum (lambda (x1731) (strip616 x1731 (quote (()))))) (set! generate-temporaries (lambda (ls1732) (begin (let ((x1733 ls1732)) (if (not (list? x1733)) (syntax-violation (quote generate-temporaries) "invalid argument" x1733))) (map (lambda (x1734) (wrap597 (gensym) (quote ((top))) #f)) ls1732)))) (set! free-identifier=? (lambda (x1735 y1736) (begin (let ((x1737 x1735)) (if (not (nonsymbol-id?568 x1737)) (syntax-violation (quote free-identifier=?) "invalid argument" x1737))) (let ((x1738 y1736)) (if (not (nonsymbol-id?568 x1738)) (syntax-violation (quote free-identifier=?) "invalid argument" x1738))) (free-id=?592 x1735 y1736)))) (set! bound-identifier=? (lambda (x1739 y1740) (begin (let ((x1741 x1739)) (if (not (nonsymbol-id?568 x1741)) (syntax-violation (quote bound-identifier=?) "invalid argument" x1741))) (let ((x1742 y1740)) (if (not (nonsymbol-id?568 x1742)) (syntax-violation (quote bound-identifier=?) "invalid argument" x1742))) (bound-id=?593 x1739 y1740)))) (set! syntax-violation (lambda (who1746 message1745 form1744 . subform1743) (begin (let ((x1747 who1746)) (if (not ((lambda (x1748) (or (not x1748) (string? x1748) (symbol? x1748))) x1747)) (syntax-violation (quote syntax-violation) "invalid argument" x1747))) (let ((x1749 message1745)) (if (not (string? x1749)) (syntax-violation (quote syntax-violation) "invalid argument" x1749))) (scm-error (quote syntax-error) (quote sc-expand) (string-append (if who1746 "~a: " "") "~a " (if (null? subform1743) "in ~a" "in subform `~s' of `~s'")) (let ((tail1750 (cons message1745 (map (lambda (x1751) (strip616 x1751 (quote (())))) (append subform1743 (list form1744)))))) (if who1746 (cons who1746 tail1750) tail1750)) #f)))) (letrec ((match1756 (lambda (e1757 p1758 w1759 r1760 mod1761) (cond ((not r1760) #f) ((eq? p1758 (quote any)) (cons (wrap597 e1757 w1759 mod1761) r1760)) ((syntax-object?553 e1757) (match*1755 (let ((e1762 (syntax-object-expression554 e1757))) (if (annotation? e1762) (annotation-expression e1762) e1762)) p1758 (join-wraps588 w1759 (syntax-object-wrap555 e1757)) r1760 (syntax-object-module556 e1757))) (else (match*1755 (let ((e1763 e1757)) (if (annotation? e1763) (annotation-expression e1763) e1763)) p1758 w1759 r1760 mod1761))))) (match*1755 (lambda (e1764 p1765 w1766 r1767 mod1768) (cond ((null? p1765) (and (null? e1764) r1767)) ((pair? p1765) (and (pair? e1764) (match1756 (car e1764) (car p1765) w1766 (match1756 (cdr e1764) (cdr p1765) w1766 r1767 mod1768) mod1768))) ((eq? p1765 (quote each-any)) (let ((l1769 (match-each-any1753 e1764 w1766 mod1768))) (and l1769 (cons l1769 r1767)))) (else (let ((t1770 (vector-ref p1765 0))) (if (memv t1770 (quote (each))) (if (null? e1764) (match-empty1754 (vector-ref p1765 1) r1767) (let ((l1771 (match-each1752 e1764 (vector-ref p1765 1) w1766 mod1768))) (and l1771 (letrec ((collect1772 (lambda (l1773) (if (null? (car l1773)) r1767 (cons (map car l1773) (collect1772 (map cdr l1773))))))) (collect1772 l1771))))) (if (memv t1770 (quote (free-id))) (and (id?569 e1764) (free-id=?592 (wrap597 e1764 w1766 mod1768) (vector-ref p1765 1)) r1767) (if (memv t1770 (quote (atom))) (and (equal? (vector-ref p1765 1) (strip616 e1764 w1766)) r1767) (if (memv t1770 (quote (vector))) (and (vector? e1764) (match1756 (vector->list e1764) (vector-ref p1765 1) w1766 r1767 mod1768))))))))))) (match-empty1754 (lambda (p1774 r1775) (cond ((null? p1774) r1775) ((eq? p1774 (quote any)) (cons (quote ()) r1775)) ((pair? p1774) (match-empty1754 (car p1774) (match-empty1754 (cdr p1774) r1775))) ((eq? p1774 (quote each-any)) (cons (quote ()) r1775)) (else (let ((t1776 (vector-ref p1774 0))) (if (memv t1776 (quote (each))) (match-empty1754 (vector-ref p1774 1) r1775) (if (memv t1776 (quote (free-id atom))) r1775 (if (memv t1776 (quote (vector))) (match-empty1754 (vector-ref p1774 1) r1775))))))))) (match-each-any1753 (lambda (e1777 w1778 mod1779) (cond ((annotation? e1777) (match-each-any1753 (annotation-expression e1777) w1778 mod1779)) ((pair? e1777) (let ((l1780 (match-each-any1753 (cdr e1777) w1778 mod1779))) (and l1780 (cons (wrap597 (car e1777) w1778 mod1779) l1780)))) ((null? e1777) (quote ())) ((syntax-object?553 e1777) (match-each-any1753 (syntax-object-expression554 e1777) (join-wraps588 w1778 (syntax-object-wrap555 e1777)) mod1779)) (else #f)))) (match-each1752 (lambda (e1781 p1782 w1783 mod1784) (cond ((annotation? e1781) (match-each1752 (annotation-expression e1781) p1782 w1783 mod1784)) ((pair? e1781) (let ((first1785 (match1756 (car e1781) p1782 w1783 (quote ()) mod1784))) (and first1785 (let ((rest1786 (match-each1752 (cdr e1781) p1782 w1783 mod1784))) (and rest1786 (cons first1785 rest1786)))))) ((null? e1781) (quote ())) ((syntax-object?553 e1781) (match-each1752 (syntax-object-expression554 e1781) p1782 (join-wraps588 w1783 (syntax-object-wrap555 e1781)) (syntax-object-module556 e1781))) (else #f))))) (set! $sc-dispatch (lambda (e1787 p1788) (cond ((eq? p1788 (quote any)) (list e1787)) ((syntax-object?553 e1787) (match*1755 (let ((e1789 (syntax-object-expression554 e1787))) (if (annotation? e1789) (annotation-expression e1789) e1789)) p1788 (syntax-object-wrap555 e1787) (quote ()) (syntax-object-module556 e1787))) (else (match*1755 (let ((e1790 e1787)) (if (annotation? e1790) (annotation-expression e1790) e1790)) p1788 (quote (())) (quote ()) #f)))))))))
(define with-syntax (make-syncase-macro (quote macro) (lambda (x1791) ((lambda (tmp1792) ((lambda (tmp1793) (if tmp1793 (apply (lambda (_1794 e11795 e21796) (cons (quote #(syntax-object begin ((top) #(ribcage #(_ e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11795 e21796))) tmp1793) ((lambda (tmp1798) (if tmp1798 (apply (lambda (_1799 out1800 in1801 e11802 e21803) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in1801 (quote ()) (list out1800 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11802 e21803))))) tmp1798) ((lambda (tmp1805) (if tmp1805 (apply (lambda (_1806 out1807 in1808 e11809 e21810) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object list ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) in1808) (quote ()) (list out1807 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11809 e21810))))) tmp1805) (syntax-violation #f "source expression failed to match any pattern" tmp1792))) ($sc-dispatch tmp1792 (quote (any #(each (any any)) any . each-any)))))) ($sc-dispatch tmp1792 (quote (any ((any any)) any . each-any)))))) ($sc-dispatch tmp1792 (quote (any () any . each-any))))) x1791))))
(define syntax-rules (make-syncase-macro (quote macro) (lambda (x1814) ((lambda (tmp1815) ((lambda (tmp1816) (if tmp1816 (apply (lambda (_1817 k1818 keyword1819 pattern1820 template1821) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (cons (quote #(syntax-object syntax-case ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote #(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons k1818 (map (lambda (tmp1824 tmp1823) (list (cons (quote #(syntax-object dummy ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp1823) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) tmp1824))) template1821 pattern1820)))))) tmp1816) (syntax-violation #f "source expression failed to match any pattern" tmp1815))) ($sc-dispatch tmp1815 (quote (any each-any . #(each ((any . any) any))))))) x1814))))
(define let* (make-extended-syncase-macro (module-ref (current-module) (quote let*)) (quote macro) (lambda (x1825) ((lambda (tmp1826) ((lambda (tmp1827) (if (if tmp1827 (apply (lambda (let*1828 x1829 v1830 e11831 e21832) (and-map identifier? x1829)) tmp1827) #f) (apply (lambda (let*1834 x1835 v1836 e11837 e21838) (letrec ((f1839 (lambda (bindings1840) (if (null? bindings1840) (cons (quote #(syntax-object let ((top) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons (quote ()) (cons e11837 e21838))) ((lambda (tmp1844) ((lambda (tmp1845) (if tmp1845 (apply (lambda (body1846 binding1847) (list (quote #(syntax-object let ((top) #(ribcage #(body binding) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list binding1847) body1846)) tmp1845) (syntax-violation #f "source expression failed to match any pattern" tmp1844))) ($sc-dispatch tmp1844 (quote (any any))))) (list (f1839 (cdr bindings1840)) (car bindings1840))))))) (f1839 (map list x1835 v1836)))) tmp1827) (syntax-violation #f "source expression failed to match any pattern" tmp1826))) ($sc-dispatch tmp1826 (quote (any #(each (any any)) any . each-any))))) x1825))))
(define do (make-extended-syncase-macro (module-ref (current-module) (quote do)) (quote macro) (lambda (orig-x1848) ((lambda (tmp1849) ((lambda (tmp1850) (if tmp1850 (apply (lambda (_1851 var1852 init1853 step1854 e01855 e11856 c1857) ((lambda (tmp1858) ((lambda (tmp1859) (if tmp1859 (apply (lambda (step1860) ((lambda (tmp1861) ((lambda (tmp1862) (if tmp1862 (apply (lambda () (list (quote #(syntax-object let ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var1852 init1853) (list (quote #(syntax-object if ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object not ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e01855) (cons (quote #(syntax-object begin ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c1857 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step1860))))))) tmp1862) ((lambda (tmp1867) (if tmp1867 (apply (lambda (e11868 e21869) (list (quote #(syntax-object let ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (map list var1852 init1853) (list (quote #(syntax-object if ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) e01855 (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (cons e11868 e21869)) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) (append c1857 (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))) (hygiene guile))) step1860))))))) tmp1867) (syntax-violation #f "source expression failed to match any pattern" tmp1861))) ($sc-dispatch tmp1861 (quote (any . each-any)))))) ($sc-dispatch tmp1861 (quote ())))) e11856)) tmp1859) (syntax-violation #f "source expression failed to match any pattern" tmp1858))) ($sc-dispatch tmp1858 (quote each-any)))) (map (lambda (v1876 s1877) ((lambda (tmp1878) ((lambda (tmp1879) (if tmp1879 (apply (lambda () v1876) tmp1879) ((lambda (tmp1880) (if tmp1880 (apply (lambda (e1881) e1881) tmp1880) ((lambda (_1882) (syntax-violation (quote do) "bad step expression" orig-x1848 s1877)) tmp1878))) ($sc-dispatch tmp1878 (quote (any)))))) ($sc-dispatch tmp1878 (quote ())))) s1877)) var1852 step1854))) tmp1850) (syntax-violation #f "source expression failed to match any pattern" tmp1849))) ($sc-dispatch tmp1849 (quote (any #(each (any any . any)) (any . each-any) . each-any))))) orig-x1848))))
(define quasiquote (make-extended-syncase-macro (module-ref (current-module) (quote quasiquote)) (quote macro) (letrec ((quasicons1885 (lambda (x1889 y1890) ((lambda (tmp1891) ((lambda (tmp1892) (if tmp1892 (apply (lambda (x1893 y1894) ((lambda (tmp1895) ((lambda (tmp1896) (if tmp1896 (apply (lambda (dy1897) ((lambda (tmp1898) ((lambda (tmp1899) (if tmp1899 (apply (lambda (dx1900) (list (quote #(syntax-object quote ((top) #(ribcage #(dx) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons dx1900 dy1897))) tmp1899) ((lambda (_1901) (if (null? dy1897) (list (quote #(syntax-object list ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1893) (list (quote #(syntax-object cons ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1893 y1894))) tmp1898))) ($sc-dispatch tmp1898 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) x1893)) tmp1896) ((lambda (tmp1902) (if tmp1902 (apply (lambda (stuff1903) (cons (quote #(syntax-object list ((top) #(ribcage #(stuff) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (cons x1893 stuff1903))) tmp1902) ((lambda (else1904) (list (quote #(syntax-object cons ((top) #(ribcage #(else) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1893 y1894)) tmp1895))) ($sc-dispatch tmp1895 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . any)))))) ($sc-dispatch tmp1895 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) y1894)) tmp1892) (syntax-violation #f "source expression failed to match any pattern" tmp1891))) ($sc-dispatch tmp1891 (quote (any any))))) (list x1889 y1890)))) (quasiappend1886 (lambda (x1905 y1906) ((lambda (tmp1907) ((lambda (tmp1908) (if tmp1908 (apply (lambda (x1909 y1910) ((lambda (tmp1911) ((lambda (tmp1912) (if tmp1912 (apply (lambda () x1909) tmp1912) ((lambda (_1913) (list (quote #(syntax-object append ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1909 y1910)) tmp1911))) ($sc-dispatch tmp1911 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) ()))))) y1910)) tmp1908) (syntax-violation #f "source expression failed to match any pattern" tmp1907))) ($sc-dispatch tmp1907 (quote (any any))))) (list x1905 y1906)))) (quasivector1887 (lambda (x1914) ((lambda (tmp1915) ((lambda (x1916) ((lambda (tmp1917) ((lambda (tmp1918) (if tmp1918 (apply (lambda (x1919) (list (quote #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) (list->vector x1919))) tmp1918) ((lambda (tmp1921) (if tmp1921 (apply (lambda (x1922) (cons (quote #(syntax-object vector ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1922)) tmp1921) ((lambda (_1924) (list (quote #(syntax-object list->vector ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) x1916)) tmp1917))) ($sc-dispatch tmp1917 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) . each-any)))))) ($sc-dispatch tmp1917 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) each-any))))) x1916)) tmp1915)) x1914))) (quasi1888 (lambda (p1925 lev1926) ((lambda (tmp1927) ((lambda (tmp1928) (if tmp1928 (apply (lambda (p1929) (if (= lev1926 0) p1929 (quasicons1885 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1888 (list p1929) (- lev1926 1))))) tmp1928) ((lambda (tmp1930) (if tmp1930 (apply (lambda (p1931 q1932) (if (= lev1926 0) (quasiappend1886 p1931 (quasi1888 q1932 lev1926)) (quasicons1885 (quasicons1885 (quote (#(syntax-object quote ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object unquote-splicing ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1888 (list p1931) (- lev1926 1))) (quasi1888 q1932 lev1926)))) tmp1930) ((lambda (tmp1933) (if tmp1933 (apply (lambda (p1934) (quasicons1885 (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)) #(syntax-object quasiquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile)))) (quasi1888 (list p1934) (+ lev1926 1)))) tmp1933) ((lambda (tmp1935) (if tmp1935 (apply (lambda (p1936 q1937) (quasicons1885 (quasi1888 p1936 lev1926) (quasi1888 q1937 lev1926))) tmp1935) ((lambda (tmp1938) (if tmp1938 (apply (lambda (x1939) (quasivector1887 (quasi1888 x1939 lev1926))) tmp1938) ((lambda (p1941) (list (quote #(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) p1941)) tmp1927))) ($sc-dispatch tmp1927 (quote #(vector each-any)))))) ($sc-dispatch tmp1927 (quote (any . any)))))) ($sc-dispatch tmp1927 (quote (#(free-id #(syntax-object quasiquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any)))))) ($sc-dispatch tmp1927 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any) . any)))))) ($sc-dispatch tmp1927 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))) (hygiene guile))) any))))) p1925)))) (lambda (x1942) ((lambda (tmp1943) ((lambda (tmp1944) (if tmp1944 (apply (lambda (_1945 e1946) (quasi1888 e1946 0)) tmp1944) (syntax-violation #f "source expression failed to match any pattern" tmp1943))) ($sc-dispatch tmp1943 (quote (any any))))) x1942)))))
(define include (make-syncase-macro (quote macro) (lambda (x1947) (letrec ((read-file1948 (lambda (fn1949 k1950) (let ((p1951 (open-input-file fn1949))) (letrec ((f1952 (lambda (x1953) (if (eof-object? x1953) (begin (close-input-port p1951) (quote ())) (cons (datum->syntax k1950 x1953) (f1952 (read p1951))))))) (f1952 (read p1951))))))) ((lambda (tmp1954) ((lambda (tmp1955) (if tmp1955 (apply (lambda (k1956 filename1957) (let ((fn1958 (syntax->datum filename1957))) ((lambda (tmp1959) ((lambda (tmp1960) (if tmp1960 (apply (lambda (exp1961) (cons (quote #(syntax-object begin ((top) #(ribcage #(exp) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(fn) #((top)) #("i")) #(ribcage #(k filename) #((top) (top)) #("i" "i")) #(ribcage (read-file) ((top)) ("i")) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) exp1961)) tmp1960) (syntax-violation #f "source expression failed to match any pattern" tmp1959))) ($sc-dispatch tmp1959 (quote each-any)))) (read-file1948 fn1958 k1956)))) tmp1955) (syntax-violation #f "source expression failed to match any pattern" tmp1954))) ($sc-dispatch tmp1954 (quote (any any))))) x1947)))))
(define unquote (make-syncase-macro (quote macro) (lambda (x1963) ((lambda (tmp1964) ((lambda (tmp1965) (if tmp1965 (apply (lambda (_1966 e1967) (syntax-violation (quote unquote) "expression not valid outside of quasiquote" x1963)) tmp1965) (syntax-violation #f "source expression failed to match any pattern" tmp1964))) ($sc-dispatch tmp1964 (quote (any any))))) x1963))))
(define unquote-splicing (make-syncase-macro (quote macro) (lambda (x1968) ((lambda (tmp1969) ((lambda (tmp1970) (if tmp1970 (apply (lambda (_1971 e1972) (syntax-violation (quote unquote-splicing) "expression not valid outside of quasiquote" x1968)) tmp1970) (syntax-violation #f "source expression failed to match any pattern" tmp1969))) ($sc-dispatch tmp1969 (quote (any any))))) x1968))))
(define case (make-extended-syncase-macro (module-ref (current-module) (quote case)) (quote macro) (lambda (x1973) ((lambda (tmp1974) ((lambda (tmp1975) (if tmp1975 (apply (lambda (_1976 e1977 m11978 m21979) ((lambda (tmp1980) ((lambda (body1981) (list (quote #(syntax-object let ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (list (quote #(syntax-object t ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e1977)) body1981)) tmp1980)) (letrec ((f1982 (lambda (clause1983 clauses1984) (if (null? clauses1984) ((lambda (tmp1986) ((lambda (tmp1987) (if tmp1987 (apply (lambda (e11988 e21989) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11988 e21989))) tmp1987) ((lambda (tmp1991) (if tmp1991 (apply (lambda (k1992 e11993 e21994) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k1992)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e11993 e21994)))) tmp1991) ((lambda (_1997) (syntax-violation (quote case) "bad clause" x1973 clause1983)) tmp1986))) ($sc-dispatch tmp1986 (quote (each-any any . each-any)))))) ($sc-dispatch tmp1986 (quote (#(free-id #(syntax-object else ((top) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) any . each-any))))) clause1983) ((lambda (tmp1998) ((lambda (rest1999) ((lambda (tmp2000) ((lambda (tmp2001) (if tmp2001 (apply (lambda (k2002 e12003 e22004) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) k2002)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e12003 e22004)) rest1999)) tmp2001) ((lambda (_2007) (syntax-violation (quote case) "bad clause" x1973 clause1983)) tmp2000))) ($sc-dispatch tmp2000 (quote (each-any any . each-any))))) clause1983)) tmp1998)) (f1982 (car clauses1984) (cdr clauses1984))))))) (f1982 m11978 m21979)))) tmp1975) (syntax-violation #f "source expression failed to match any pattern" tmp1974))) ($sc-dispatch tmp1974 (quote (any any any . each-any))))) x1973))))
(define identifier-syntax (make-syncase-macro (quote macro) (lambda (x2008) ((lambda (tmp2009) ((lambda (tmp2010) (if tmp2010 (apply (lambda (_2011 e2012) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote #(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote ()) (list (quote #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (quote (#(syntax-object identifier? ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) (#(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) e2012)) (list (cons _2011 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile))) (cons e2012 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))) (hygiene guile)))))))))) tmp2010) (syntax-violation #f "source expression failed to match any pattern" tmp2009))) ($sc-dispatch tmp2009 (quote (any any))))) x2008))))
