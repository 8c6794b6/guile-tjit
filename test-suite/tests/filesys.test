;;;; filesys.test --- test file system functions -*- scheme -*-
;;;; 
;;;; Copyright (C) 2004, 2006, 2013 Free Software Foundation, Inc.
;;;; 
;;;; This library is free software; you can redistribute it and/or
;;;; modify it under the terms of the GNU Lesser General Public
;;;; License as published by the Free Software Foundation; either
;;;; version 3 of the License, or (at your option) any later version.
;;;; 
;;;; This library is distributed in the hope that it will be useful,
;;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
;;;; Lesser General Public License for more details.
;;;; 
;;;; You should have received a copy of the GNU Lesser General Public
;;;; License along with this library; if not, write to the Free Software
;;;; Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

(define-module (test-suite test-filesys)
  #:use-module (ice-9 rdelim)
  #:use-module (ice-9 binary-ports)
  #:use-module (test-suite lib)
  #:use-module (test-suite guile-test))

(define (test-file)
  (data-file-name "filesys-test.tmp"))
(define (test-symlink)
  (data-file-name "filesys-test-link.tmp"))


;;;
;;; copy-file
;;;

(with-test-prefix "copy-file"

  ;; return next prospective file descriptor number
  (define (next-fd)
    (let ((fd (dup 0)))
      (close fd)
      fd))

  ;; in guile 1.6.4 and earlier, copy-file didn't close the input fd when
  ;; the output could not be opened
  (pass-if "fd leak when dest unwritable"
    (let ((old-next (next-fd)))
      (false-if-exception (copy-file "/dev/null" "no/such/dir/foo"))
      (= old-next (next-fd)))))

;;;
;;; lstat
;;;

(with-test-prefix "lstat"

  (pass-if "normal file"
    (call-with-output-file (test-file)
      (lambda (port)
	(display "hello" port)))
    (eqv? 5 (stat:size (lstat (test-file)))))

  (call-with-output-file (test-file)
    (lambda (port)
      (display "hello" port)))
  (false-if-exception (delete-file (test-symlink)))
  (if (not (false-if-exception
	    (begin (symlink (test-file) (test-symlink)) #t)))
      (display "cannot create symlink, lstat test skipped\n")
      (pass-if "symlink"
	;; not much to test, except that it works
	(->bool (lstat (test-symlink))))))

;;;
;;; opendir and friends
;;;

(with-test-prefix "opendir"

  (with-test-prefix "root directory"
    (let ((d (opendir "/")))
      (pass-if "not empty"
	(string? (readdir d)))
      (pass-if "all entries are strings"
	(let more ()
	  (let ((f (readdir d)))
	    (cond ((string? f)
		   (more))
		  ((eof-object? f)
		   #t)
		  (else
		   #f)))))
      (closedir d))))

;;;
;;; stat
;;;

(with-test-prefix "stat"

  (with-test-prefix "filename"

    (pass-if "size"
      (call-with-output-file (test-file)
	(lambda (port)
	  (display "hello" port)))
      (eqv? 5 (stat:size (stat (test-file))))))

  (with-test-prefix "file descriptor"

    (pass-if "size"
      (call-with-output-file (test-file)
	(lambda (port)
	  (display "hello" port)))
      (let* ((fd (open-fdes (test-file) O_RDONLY))
	     (st (stat fd)))
	(close-fdes fd)
	(eqv? 5 (stat:size st)))))

  (with-test-prefix "port"

    (pass-if "size"
      (call-with-output-file (test-file)
	(lambda (port)
	  (display "hello" port)))
      (let* ((port (open-file (test-file) "r+"))
	     (st   (stat port)))
	(close-port port)
	(eqv? 5 (stat:size st))))))

(delete-file (test-file))
(delete-file (test-symlink))

(let ((s "\ufeffHello, world!"))
  (define* (test-encoding encoding #:optional (ambient "ISO-8859-1"))
    (with-fluids ((%default-port-encoding ambient))
      (let* ((bytes (catch 'misc-error
                      (lambda ()
                        (call-with-values open-bytevector-output-port
                          (lambda (port get-bytevector)
                            (set-port-encoding! port encoding)
                            (display s port)
                            (get-bytevector))))
                      (lambda args
                        (throw 'unresolved))))
             (name (string-copy "myfile-XXXXXX"))
             (port (mkstemp! name)))
        (put-bytevector port bytes)
        (close-port port)
        (let ((contents (call-with-input-file name read-string)))
          (delete-file name)
          contents))))

  (pass-if "UTF-8"
    (equal? (test-encoding "UTF-8")
            "Hello, world!"))

  (pass-if "UTF-16BE"
    (equal? (test-encoding "UTF-16BE")
            "Hello, world!"))

  (pass-if "UTF-16LE"
    (equal? (test-encoding "UTF-16LE")
            "Hello, world!"))

  (pass-if "UTF-8 (ambient)"
    (equal? (test-encoding "UTF-8" "UTF-8")
            "Hello, world!"))

  (pass-if "UTF-8 (UTF-16 ambient)"
    (equal? (test-encoding "UTF-8" "UTF-16")
            "Hello, world!"))

  ;; Unicode 6.2 section 16.8:
  ;;
  ;; For compatibility with versions of the Unicode Standard prior to
  ;; Version 3.2, the code point U+FEFF has the word-joining semantics
  ;; of zero width no-break space when it is not used as a BOM.  [...]
  ;;
  ;; Where the byte order is explicitly specified, such as in UTF-16BE
  ;; or UTF-16LE, then all U+FEFF characters -- even at the very
  ;; beginning of the text -- are to be interpreted as zero width
  ;; no-break spaces.
  ;;
  (pass-if "UTF-16LE (ambient)"
    (equal? (test-encoding "UTF-16LE" "UTF-16LE")
            "\ufeffHello, world!")))
