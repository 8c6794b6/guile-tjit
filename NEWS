Guile NEWS --- history of user-visible changes.  -*- text -*-
Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
See the end for copying conditions.

Please send Guile bug reports to bug-guile@gnu.org.

Changes since Guile 1.3:

* Changes to the stand-alone interpreter

** New options interface: readline-options,
readline-enable, readline-disable, readline-set!

** Command line history is now restored from and saved to file

If readline is used and the readline option `history-file' is enabled,
the command line history is read from file when the interpreter is
entered, and written to file on exit.  The filename used can be
specified with the environment variable GUILE_HISTORY.  Default file
name is "$HOME/.guile_history".  Nothing special happens if errors
occur during read or write.

** Command line history length can now be customized.
Command line history length is now controlled by the readline option
`history-length'.  Default is 200 lines.

** All builtins now print as primitives.
Previously builtin procedures not belonging to the fundamental subr
types printed as #<compiled closure #<primitive-procedure gsubr-apply>>.
Now, they print as #<primitive-procedure NAME>.

** Backtraces slightly more intelligible.
gsubr-apply and macro transformer application frames no longer appear
in backtraces.

* Changes to Scheme functions and syntax

** New function: sorted? SEQUENCE LESS?
Returns `#t' when the sequence argument is in non-decreasing order
according to LESS? (that is, there is no adjacent pair `... x y
...' for which `(less? y x)').

Returns `#f' when the sequence contains at least one out-of-order
pair.  It is an error if the sequence is neither a list nor a
vector.

** New function: merge LIST1 LIST2 LESS?
LIST1 and LIST2 are sorted lists.
Returns the sorted list of all elements in LIST1 and LIST2.

Assume that the elements a and b1 in LIST1 and b2 in LIST2 are "equal"
in the sense that (LESS? x y) --> #f for x, y in {a, b1, b2},
and that a < b1 in LIST1.  Then a < b1 < b2 in the result.
(Here "<" should read "comes before".)

** New procedure: merge! LIST1 LIST2 LESS?
Merges two lists, re-using the pairs of LIST1 and LIST2 to build
the result.  If the code is compiled, and LESS? constructs no new
pairs, no pairs at all will be allocated.  The first pair of the
result will be either the first pair of LIST1 or the first pair of
LIST2.

** New function: sort SEQUENCE LESS?
Accepts either a list or a vector, and returns a new sequence
which is sorted.  The new sequence is the same type as the input.
Always `(sorted? (sort sequence less?) less?)'.  The original
sequence is not altered in any way.  The new sequence shares its
elements with the old one; no elements are copied.

** New procedure: sort! SEQUENCE LESS
Returns its sorted result in the original boxes.  No new storage is
allocated at all.  Proper usage: (set! slist (sort! slist <))

** New function: stable-sort SEQUENCE LESS?
Similar to `sort' but stable.  That is, if "equal" elements are
ordered a < b in the original sequence, they will have the same order
in the result.

** New function: stable-sort! SEQUENCE LESS?
Similar to `sort!' but stable.
Uses temporary storage when sorting vectors.

** New functions: sort-list, sort-list!
Added for compatibility with scsh.

** The range of logand, logior, logxor, logtest, and logbit? have changed.

These functions now operate on numbers in the range of a C unsigned
long.

These functions used to operate on numbers in the range of a C signed
long; however, this seems inappropriate, because Guile integers don't
overflow.

** New function: make-guardian
This is an implementation of guardians as described in
R. Kent Dybvig, Carl Bruggeman, and David Eby (1993) "Guardians in a
Generation-Based Garbage Collector" ACM SIGPLAN Conference on
Programming Language Design and Implementation, June 1993
ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/guardians.ps.gz

** New functions: delq1!, delv1!, delete1!
These procedures behave similar to delq! and friends but delete only
one object if at all.

** New function: unread-string STRING PORT
Unread STRING to PORT, that is, push it back onto the port so that
next read operation will work on the pushed back characters.

** unread-char can now be called multiple times
If unread-char is called multiple times, the unread characters will be
read again in last-in first-out order.

** New function: map-in-order PROC LIST1 LIST2 ...
Version of `map' which guarantees that the procedure is applied to the
lists in serial order.

** Renamed `serial-array-copy!' and `serial-array-map!' to
`array-copy-in-order!' and `array-map-in-order!'.  The old names are
now obsolete and will go away in release 1.5.

** New syntax: collect BODY1 ...
Version of `begin' which returns a list of the results of the body
forms instead of the result of the last body form.  In contrast to
`begin', `collect' allows an empty body.

** New functions: read-history FILENAME, write-history FILENAME
Read/write command line history from/to file.  Returns #t on success
and #f if an error occured.

* Changes to the gh_ interface

** gh_scm2doubles

Now takes a second argument which is the result array.  If this
pointer is NULL, a new array is malloced (the old behaviour).

** gh_chars2byvect, gh_shorts2svect, gh_floats2fvect, gh_scm2chars,
   gh_scm2shorts, gh_scm2longs, gh_scm2floats

New functions.


Changes in Guile 1.3 (released Monday, October 19, 1998):

* Changes to the distribution

** We renamed the SCHEME_LOAD_PATH environment variable to GUILE_LOAD_PATH.
To avoid conflicts, programs should name environment variables after
themselves, except when there's a common practice establishing some
other convention.

For now, Guile supports both GUILE_LOAD_PATH and SCHEME_LOAD_PATH,
giving the former precedence, and printing a warning message if the
latter is set.  Guile 1.4 will not recognize SCHEME_LOAD_PATH at all.

** The header files related to multi-byte characters have been removed.
They were: libguile/extchrs.h and libguile/mbstrings.h.  Any C code
which referred to these explicitly will probably need to be rewritten,
since the support for the variant string types has been removed; see
below.

** The header files append.h and sequences.h have been removed.  These
files implemented non-R4RS operations which would encourage
non-portable programming style and less easy-to-read code.

* Changes to the stand-alone interpreter

** New procedures have been added to implement a "batch mode":

*** Function: batch-mode?

    Returns a boolean indicating whether the interpreter is in batch
    mode.

*** Function: set-batch-mode?! ARG

    If ARG is true, switches the interpreter to batch mode.  The `#f'
    case has not been implemented.

** Guile now provides full command-line editing, when run interactively.
To use this feature, you must have the readline library installed.
The Guile build process will notice it, and automatically include
support for it.

The readline library is available via anonymous FTP from any GNU
mirror site; the canonical location is "ftp://prep.ai.mit.edu/pub/gnu".

** the-last-stack is now a fluid.

* Changes to the procedure for linking libguile with your programs

** You can now use the `guile-config' utility to build programs that use Guile.

Guile now includes a command-line utility called `guile-config', which
can provide information about how to compile and link programs that
use Guile.

*** `guile-config compile' prints any C compiler flags needed to use Guile.
You should include this command's output on the command line you use
to compile C or C++ code that #includes the Guile header files.  It's
usually just a `-I' flag to help the compiler find the Guile headers.


*** `guile-config link' prints any linker flags necessary to link with Guile.

This command writes to its standard output a list of flags which you
must pass to the linker to link your code against the Guile library.
The flags include '-lguile' itself, any other libraries the Guile
library depends upon, and any `-L' flags needed to help the linker
find those libraries.

For example, here is a Makefile rule that builds a program named 'foo'
from the object files ${FOO_OBJECTS}, and links them against Guile:

  foo: ${FOO_OBJECTS}
	  ${CC} ${CFLAGS} ${FOO_OBJECTS} `guile-config link` -o foo

Previous Guile releases recommended that you use autoconf to detect
which of a predefined set of libraries were present on your system.
It is more robust to use `guile-config', since it records exactly which
libraries the installed Guile library requires.

This was originally called `build-guile', but was renamed to
`guile-config' before Guile 1.3 was released, to be consistent with
the analogous script for the GTK+ GUI toolkit, which is called
`gtk-config'.


** Use the GUILE_FLAGS macro in your configure.in file to find Guile.

If you are using the GNU autoconf package to configure your program,
you can use the GUILE_FLAGS autoconf macro to call `guile-config'
(described above) and gather the necessary values for use in your
Makefiles.

The GUILE_FLAGS macro expands to configure script code which runs the
`guile-config' script, to find out where Guile's header files and
libraries are installed.  It sets two variables, marked for
substitution, as by AC_SUBST.

  GUILE_CFLAGS --- flags to pass to a C or C++ compiler to build
    code that uses Guile header files.  This is almost always just a
    -I flag.

  GUILE_LDFLAGS --- flags to pass to the linker to link a
    program against Guile.  This includes `-lguile' for the Guile
    library itself, any libraries that Guile itself requires (like
    -lqthreads), and so on.  It may also include a -L flag to tell the
    compiler where to find the libraries.

GUILE_FLAGS is defined in the file guile.m4, in the top-level
directory of the Guile distribution.  You can copy it into your
package's aclocal.m4 file, and then use it in your configure.in file.

If you are using the `aclocal' program, distributed with GNU automake,
to maintain your aclocal.m4 file, the Guile installation process
installs guile.m4 where aclocal will find it.  All you need to do is
use GUILE_FLAGS in your configure.in file, and then run `aclocal';
this will copy the definition of GUILE_FLAGS into your aclocal.m4
file.


* Changes to Scheme functions and syntax

** Multi-byte strings have been removed, as have multi-byte and wide
ports.  We felt that these were the wrong approach to
internationalization support.

** New function: readline [PROMPT]
Read a line from the terminal, and allow the user to edit it,
prompting with PROMPT.  READLINE provides a large set of Emacs-like
editing commands, lets the user recall previously typed lines, and
works on almost every kind of terminal, including dumb terminals.

READLINE assumes that the cursor is at the beginning of the line when
it is invoked.  Thus, you can't print a prompt yourself, and then call
READLINE; you need to package up your prompt as a string, pass it to
the function, and let READLINE print the prompt itself.  This is
because READLINE needs to know the prompt's screen width.

For Guile to provide this function, you must have the readline
library, version 2.1 or later, installed on your system.  Readline is
available via anonymous FTP from prep.ai.mit.edu in pub/gnu, or from
any GNU mirror site.

See also ADD-HISTORY function.

** New function: add-history STRING
Add STRING as the most recent line in the history used by the READLINE
command.  READLINE does not add lines to the history itself; you must
call ADD-HISTORY to make previous input available to the user.

** The behavior of the read-line function has changed.

This function now uses standard C library functions to read the line,
for speed.  This means that it doesn not respect the value of
scm-line-incrementors; it assumes that lines are delimited with
#\newline.

(Note that this is read-line, the function that reads a line of text
from a port, not readline, the function that reads a line from a
terminal, providing full editing capabilities.)

** New module (ice-9 getopt-gnu-style): Parse command-line arguments.

This module provides some simple argument parsing.  It exports one
function:

Function: getopt-gnu-style ARG-LS
    Parse a list of program arguments into an alist of option
    descriptions.

    Each item in the list of program arguments is examined to see if
    it meets the syntax of a GNU long-named option.  An argument like
    `--MUMBLE' produces an element of the form (MUMBLE . #t) in the
    returned alist, where MUMBLE is a keyword object with the same
    name as the argument.  An argument like `--MUMBLE=FROB' produces
    an element of the form (MUMBLE . FROB), where FROB is a string.

    As a special case, the returned alist also contains a pair whose
    car is the symbol `rest'.  The cdr of this pair is a list
    containing all the items in the argument list that are not options
    of the form mentioned above.

    The argument `--' is treated specially: all items in the argument
    list appearing after such an argument are not examined, and are
    returned in the special `rest' list.

    This function does not parse normal single-character switches.
    You will need to parse them out of the `rest' list yourself.

** The read syntax for byte vectors and short vectors has changed.

Instead of #bytes(...), write #y(...).

Instead of #short(...), write #h(...).

This may seem nutty, but, like the other uniform vectors, byte vectors
and short vectors want to have the same print and read syntax (and,
more basic, want to have read syntax!).  Changing the read syntax to
use multiple characters after the hash sign breaks with the
conventions used in R5RS and the conventions used for the other
uniform vectors.  It also introduces complexity in the current reader,
both on the C and Scheme levels.  (The Right solution is probably to
change the syntax and prototypes for uniform vectors entirely.)


** The new module (ice-9 session) provides useful interactive functions.

*** New procedure: (apropos REGEXP OPTION ...)

Display a list of top-level variables whose names match REGEXP, and
the modules they are imported from.  Each OPTION should be one of the
following symbols:

  value  --- Show the value of each matching variable.
  shadow --- Show bindings shadowed by subsequently imported modules.
  full   --- Same as both `shadow' and `value'.

For example:

    guile> (apropos "trace" 'full)
    debug: trace    #<procedure trace args>
    debug: untrace  #<procedure untrace args>
    the-scm-module: display-backtrace       #<compiled-closure #<primitive-procedure gsubr-apply>>
    the-scm-module: before-backtrace-hook   ()
    the-scm-module: backtrace       #<primitive-procedure backtrace>
    the-scm-module: after-backtrace-hook    ()
    the-scm-module: has-shown-backtrace-hint?       #f
    guile> 

** There are new functions and syntax for working with macros.

Guile implements macros as a special object type.  Any variable whose
top-level binding is a macro object acts as a macro.  The macro object
specifies how the expression should be transformed before evaluation.

*** Macro objects now print in a reasonable way, resembling procedures.

*** New function: (macro? OBJ)
True iff OBJ is a macro object.

*** New function: (primitive-macro? OBJ)
Like (macro? OBJ), but true only if OBJ is one of the Guile primitive
macro transformers, implemented in eval.c rather than Scheme code.

Why do we have this function?
- For symmetry with procedure? and primitive-procedure?,
- to allow custom print procedures to tell whether a macro is
  primitive, and display it differently, and
- to allow compilers and user-written evaluators to distinguish
  builtin special forms from user-defined ones, which could be
  compiled.

*** New function: (macro-type OBJ)
Return a value indicating what kind of macro OBJ is.  Possible return
values are:

    The symbol `syntax' --- a macro created by procedure->syntax.
    The symbol `macro' --- a macro created by procedure->macro.
    The symbol `macro!' --- a macro created by procedure->memoizing-macro.
    The boolean #f --- if OBJ is not a macro object.  

*** New function: (macro-name MACRO)
Return the name of the macro object MACRO's procedure, as returned by
procedure-name.

*** New function: (macro-transformer MACRO)
Return the transformer procedure for MACRO.

*** New syntax: (use-syntax MODULE ... TRANSFORMER)

Specify a new macro expander to use in the current module.  Each
MODULE is a module name, with the same meaning as in the `use-modules'
form; each named module's exported bindings are added to the current
top-level environment.  TRANSFORMER is an expression evaluated in the
resulting environment which must yield a procedure to use as the
module's eval transformer: every expression evaluated in this module
is passed to this function, and the result passed to the Guile
interpreter. 

*** macro-eval! is removed.  Use local-eval instead.

** Some magic has been added to the printer to better handle user
written printing routines (like record printers, closure printers).

The problem is that these user written routines must have access to
the current `print-state' to be able to handle fancy things like
detection of circular references.  These print-states have to be
passed to the builtin printing routines (display, write, etc) to
properly continue the print chain.

We didn't want to change all existing print code so that it
explicitly passes thru a print state in addition to a port.  Instead,
we extented the possible values that the builtin printing routines
accept as a `port'.  In addition to a normal port, they now also take
a pair of a normal port and a print-state.  Printing will go to the
port and the print-state will be used to control the detection of
circular references, etc.  If the builtin function does not care for a
print-state, it is simply ignored.

User written callbacks are now called with such a pair as their
`port', but because every function now accepts this pair as a PORT
argument, you don't have to worry about that.  In fact, it is probably
safest to not check for these pairs.

However, it is sometimes necessary to continue a print chain on a
different port, for example to get a intermediate string
representation of the printed value, mangle that string somehow, and
then to finally print the mangled string.  Use the new function

    inherit-print-state OLD-PORT NEW-PORT

for this.  It constructs a new `port' that prints to NEW-PORT but
inherits the print-state of OLD-PORT.

** struct-vtable-offset renamed to vtable-offset-user

** New constants: vtable-index-layout, vtable-index-vtable, vtable-index-printer

** There is now a fourth (optional) argument to make-vtable-vtable and
   make-struct when constructing new types (vtables).  This argument
   initializes field vtable-index-printer of the vtable.

** The detection of circular references has been extended to structs.
That is, a structure that -- in the process of being printed -- prints
itself does not lead to infinite recursion.

** There is now some basic support for fluids.  Please read
"libguile/fluid.h" to find out more. It is accessible from Scheme with
the following functions and macros:

Function: make-fluid

    Create a new fluid object.  Fluids are not special variables or
    some other extension to the semantics of Scheme, but rather
    ordinary Scheme objects.  You can store them into variables (that
    are still lexically scoped, of course) or into any other place you
    like.  Every fluid has a initial value of `#f'.

Function: fluid? OBJ

    Test whether OBJ is a fluid.

Function: fluid-ref FLUID
Function: fluid-set! FLUID VAL

    Access/modify the fluid FLUID.  Modifications are only visible
    within the current dynamic root (that includes threads).

Function: with-fluids* FLUIDS VALUES THUNK

    FLUIDS is a list of fluids and VALUES a corresponding list of
    values for these fluids.  Before THUNK gets called the values are
    installed in the fluids and the old values of the fluids are 
    saved in the VALUES list.  When the flow of control leaves THUNK
    or reenters it, the values get swapped again.  You might think of
    this as a `safe-fluid-excursion'.  Note that the VALUES list is
    modified by `with-fluids*'.

Macro: with-fluids ((FLUID VALUE) ...) FORM ...

    The same as `with-fluids*' but with a different syntax.  It looks
    just like `let', but both FLUID and VALUE are evaluated.  Remember,
    fluids are not special variables but ordinary objects.  FLUID
    should evaluate to a fluid.

** Changes to system call interfaces:

*** close-port, close-input-port and close-output-port now return a
boolean instead of an `unspecified' object.  #t means that the port
was successfully closed, while #f means it was already closed.  It is
also now possible for these procedures to raise an exception if an
error occurs (some errors from write can be delayed until close.)

*** the first argument to chmod, fcntl, ftell and fseek can now be a
file descriptor.

*** the third argument to fcntl is now optional.

*** the first argument to chown can now be a file descriptor or a port.

*** the argument to stat can now be a port.

*** The following new procedures have been added (most use scsh
interfaces):

*** procedure: close PORT/FD
     Similar to close-port (*note close-port: Closing Ports.), but also
     works on file descriptors.  A side effect of closing a file
     descriptor is that any ports using that file descriptor are moved
     to a different file descriptor and have their revealed counts set
     to zero.

*** procedure: port->fdes PORT
     Returns the integer file descriptor underlying PORT.  As a side
     effect the revealed count of PORT is incremented.

*** procedure: fdes->ports FDES
     Returns a list of existing ports which have FDES as an underlying
     file descriptor, without changing their revealed counts.

*** procedure: fdes->inport FDES
     Returns an existing input port which has FDES as its underlying
     file descriptor, if one exists, and increments its revealed count.
     Otherwise, returns a new input port with a revealed count of 1.

*** procedure: fdes->outport FDES
     Returns an existing output port which has FDES as its underlying
     file descriptor, if one exists, and increments its revealed count.
     Otherwise, returns a new output port with a revealed count of 1.

   The next group of procedures perform a `dup2' system call, if NEWFD
(an integer) is supplied, otherwise a `dup'.  The file descriptor to be
duplicated can be supplied as an integer or contained in a port.  The
type of value returned varies depending on which procedure is used.

   All procedures also have the side effect when performing `dup2' that
any ports using NEWFD are moved to a different file descriptor and have
their revealed counts set to zero.

*** procedure: dup->fdes PORT/FD [NEWFD]
     Returns an integer file descriptor.

*** procedure: dup->inport PORT/FD [NEWFD]
     Returns a new input port using the new file descriptor.

*** procedure: dup->outport PORT/FD [NEWFD]
     Returns a new output port using the new file descriptor.

*** procedure: dup PORT/FD [NEWFD]
     Returns a new port if PORT/FD is a port, with the same mode as the
     supplied port, otherwise returns an integer file descriptor.

*** procedure: dup->port PORT/FD MODE [NEWFD]
     Returns a new port using the new file descriptor.  MODE supplies a
     mode string for the port (*note open-file: File Ports.).

*** procedure: setenv NAME VALUE
     Modifies the environment of the current process, which is also the
     default environment inherited by child processes.

     If VALUE is `#f', then NAME is removed from the environment.
     Otherwise, the string NAME=VALUE is added to the environment,
     replacing any existing string with name matching NAME.

     The return value is unspecified.

*** procedure: truncate-file OBJ SIZE
     Truncates the file referred to by OBJ to at most SIZE bytes.  OBJ
     can be a string containing a file name or an integer file
     descriptor or port open for output on the file.  The underlying
     system calls are `truncate' and `ftruncate'.

     The return value is unspecified.

*** procedure: setvbuf PORT MODE [SIZE]
     Set the buffering mode for PORT.  MODE can be:
    `_IONBF'
          non-buffered

    `_IOLBF'
          line buffered

    `_IOFBF'
          block buffered, using a newly allocated buffer of SIZE bytes.
          However if SIZE is zero or unspecified, the port will be made
          non-buffered.

     This procedure should not be used after I/O has been performed with
     the port.

     Ports are usually block buffered by default, with a default buffer
     size.  Procedures e.g., *Note open-file: File Ports, which accept a
     mode string allow `0' to be added to request an unbuffered port.

*** procedure: fsync PORT/FD
     Copies any unwritten data for the specified output file descriptor
     to disk.  If PORT/FD is a port, its buffer is flushed before the
     underlying file descriptor is fsync'd.  The return value is
     unspecified.

*** procedure: open-fdes PATH FLAGS [MODES]
     Similar to `open' but returns a file descriptor instead of a port.

*** procedure: execle PATH ENV [ARG] ...
     Similar to `execl', but the environment of the new process is
     specified by ENV, which must be a list of strings as returned by
     the `environ' procedure.

     This procedure is currently implemented using the `execve' system
     call, but we call it `execle' because of its Scheme calling
     interface.

*** procedure: strerror ERRNO
     Returns the Unix error message corresponding to ERRNO, an integer.

*** procedure: primitive-exit [STATUS]
     Terminate the current process without unwinding the Scheme stack.
     This is would typically be useful after a fork.  The exit status
     is STATUS if supplied, otherwise zero.

*** procedure: times
     Returns an object with information about real and processor time.
     The following procedures accept such an object as an argument and
     return a selected component:

    `tms:clock'
          The current real time, expressed as time units relative to an
          arbitrary base.

    `tms:utime'
          The CPU time units used by the calling process.

    `tms:stime'
          The CPU time units used by the system on behalf of the
          calling process.

    `tms:cutime'
          The CPU time units used by terminated child processes of the
          calling process, whose status has been collected (e.g., using
          `waitpid').

    `tms:cstime'
          Similarly, the CPU times units used by the system on behalf of
          terminated child processes.

** Removed: list-length
** Removed: list-append, list-append!
** Removed: list-reverse, list-reverse!

** array-map renamed to array-map!

** serial-array-map renamed to serial-array-map!

** catch doesn't take #f as first argument any longer

Previously, it was possible to pass #f instead of a key to `catch'.
That would cause `catch' to pass a jump buffer object to the procedure
passed as second argument.  The procedure could then use this jump
buffer objekt as an argument to throw.

This mechanism has been removed since its utility doesn't motivate the
extra complexity it introduces.

** The `#/' notation for lists now provokes a warning message from Guile.
This syntax will be removed from Guile in the near future.

To disable the warning message, set the GUILE_HUSH environment
variable to any non-empty value.

** The newline character now prints as `#\newline', following the
normal Scheme notation, not `#\nl'.

* Changes to the gh_ interface

** The gh_enter function now takes care of loading the Guile startup files.
gh_enter works by calling scm_boot_guile; see the remarks below.

** Function: void gh_write (SCM x)

Write the printed representation of the scheme object x to the current
output port.  Corresponds to the scheme level `write'.

** gh_list_length renamed to gh_length.

** vector handling routines

Several major changes.  In particular, gh_vector() now resembles
(vector ...) (with a caveat -- see manual), and gh_make_vector() now
exists and behaves like (make-vector ...).  gh_vset() and gh_vref()
have been renamed gh_vector_set_x() and gh_vector_ref().  Some missing
vector-related gh_ functions have been implemented.

** pair and list routines

Implemented several of the R4RS pair and list functions that were
missing.

** gh_scm2doubles, gh_doubles2scm, gh_doubles2dvect

New function.  Converts double arrays back and forth between Scheme
and C.

* Changes to the scm_ interface

** The function scm_boot_guile now takes care of loading the startup files.

Guile's primary initialization function, scm_boot_guile, now takes
care of loading `boot-9.scm', in the `ice-9' module, to initialize
Guile, define the module system, and put together some standard
bindings.  It also loads `init.scm', which is intended to hold
site-specific initialization code.

Since Guile cannot operate properly until boot-9.scm is loaded, there
is no reason to separate loading boot-9.scm from Guile's other
initialization processes.

This job used to be done by scm_compile_shell_switches, which didn't
make much sense; in particular, it meant that people using Guile for
non-shell-like applications had to jump through hoops to get Guile
initialized properly.

** The function scm_compile_shell_switches no longer loads the startup files.
Now, Guile always loads the startup files, whenever it is initialized;
see the notes above for scm_boot_guile and scm_load_startup_files.

** Function: scm_load_startup_files
This new function takes care of loading Guile's initialization file
(`boot-9.scm'), and the site initialization file, `init.scm'.  Since
this is always called by the Guile initialization process, it's
probably not too useful to call this yourself, but it's there anyway.

** The semantics of smob marking have changed slightly.

The smob marking function (the `mark' member of the scm_smobfuns
structure) is no longer responsible for setting the mark bit on the
smob.  The generic smob handling code in the garbage collector will
set this bit.  The mark function need only ensure that any other
objects the smob refers to get marked.

Note that this change means that the smob's GC8MARK bit is typically
already set upon entry to the mark function.  Thus, marking functions
which look like this:

	{
	  if (SCM_GC8MARKP (ptr))
	    return SCM_BOOL_F;
          SCM_SETGC8MARK (ptr);
	  ... mark objects to which the smob refers ...
	}

are now incorrect, since they will return early, and fail to mark any
other objects the smob refers to.  Some code in the Guile library used
to work this way.

** The semantics of the I/O port functions in scm_ptobfuns have changed.

If you have implemented your own I/O port type, by writing the
functions required by the scm_ptobfuns and then calling scm_newptob,
you will need to change your functions slightly.

The functions in a scm_ptobfuns structure now expect the port itself
as their argument; they used to expect the `stream' member of the
port's scm_port_table structure.  This allows functions in an
scm_ptobfuns structure to easily access the port's cell (and any flags
it its CAR), and the port's scm_port_table structure.

Guile now passes the I/O port itself as the `port' argument in the
following scm_ptobfuns functions:

  int (*free) (SCM port);
  int (*fputc) (int, SCM port);
  int (*fputs) (char *, SCM port);
  scm_sizet (*fwrite) SCM_P ((char *ptr,
			      scm_sizet size,
			      scm_sizet nitems,
			      SCM port));
  int (*fflush) (SCM port);
  int (*fgetc) (SCM port);
  int (*fclose) (SCM port);

The interfaces to the `mark', `print', `equalp', and `fgets' methods
are unchanged.

If you have existing code which defines its own port types, it is easy
to convert your code to the new interface; simply apply SCM_STREAM to
the port argument to yield the value you code used to expect.

Note that since both the port and the stream have the same type in the
C code --- they are both SCM values --- the C compiler will not remind
you if you forget to update your scm_ptobfuns functions.


** Function: int scm_internal_select (int fds,
				      SELECT_TYPE *rfds,
				      SELECT_TYPE *wfds,
				      SELECT_TYPE *efds,
				      struct timeval *timeout);

This is a replacement for the `select' function provided by the OS.
It enables I/O blocking and sleeping to happen for one cooperative
thread without blocking other threads.  It also avoids busy-loops in
these situations.  It is intended that all I/O blocking and sleeping
will finally go through this function.  Currently, this function is
only available on systems providing `gettimeofday' and `select'.

** Function: SCM scm_internal_stack_catch (SCM tag,
					   scm_catch_body_t body,
					   void *body_data,
					   scm_catch_handler_t handler,
					   void *handler_data)

A new sibling to the other two C level `catch' functions
scm_internal_catch and scm_internal_lazy_catch.  Use it if you want
the stack to be saved automatically into the variable `the-last-stack'
(scm_the_last_stack_var) on error.  This is necessary if you want to
use advanced error reporting, such as calling scm_display_error and
scm_display_backtrace.  (They both take a stack object as argument.)

** Function: SCM scm_spawn_thread (scm_catch_body_t body,
				   void *body_data,
				   scm_catch_handler_t handler,
				   void *handler_data)

Spawns a new thread.  It does a job similar to
scm_call_with_new_thread but takes arguments more suitable when
spawning threads from application C code.

** The hook scm_error_callback has been removed.  It was originally
intended as a way for the user to install his own error handler.  But
that method works badly since it intervenes between throw and catch,
thereby changing the semantics of expressions like (catch #t ...).
The correct way to do it is to use one of the C level catch functions
in throw.c: scm_internal_catch/lazy_catch/stack_catch.

** Removed functions:

scm_obj_length, scm_list_length, scm_list_append, scm_list_append_x,
scm_list_reverse, scm_list_reverse_x

** New macros: SCM_LISTn where n is one of the integers 0-9.

These can be used for pretty list creation from C.  The idea is taken
from Erick Gallesio's STk.

** scm_array_map renamed to scm_array_map_x

** mbstrings are now removed

This means that the type codes scm_tc7_mb_string and
scm_tc7_mb_substring has been removed.

** scm_gen_putc, scm_gen_puts, scm_gen_write, and scm_gen_getc have changed.

Since we no longer support multi-byte strings, these I/O functions
have been simplified, and renamed.  Here are their old names, and
their new names and arguments:

scm_gen_putc   ->   void scm_putc (int c, SCM port);
scm_gen_puts   ->   void scm_puts (char *s, SCM port);
scm_gen_write  ->   void scm_lfwrite (char *ptr, scm_sizet size, SCM port);
scm_gen_getc   ->   void scm_getc (SCM port);


** The macros SCM_TYP7D and SCM_TYP7SD has been removed.

** The macro SCM_TYP7S has taken the role of the old SCM_TYP7D

SCM_TYP7S now masks away the bit which distinguishes substrings from
strings.

** scm_catch_body_t: Backward incompatible change!

Body functions to scm_internal_catch and friends do not any longer
take a second argument.  This is because it is no longer possible to
pass a #f arg to catch.

** Calls to scm_protect_object and scm_unprotect now nest properly.

The function scm_protect_object protects its argument from being freed
by the garbage collector.  scm_unprotect_object removes that
protection.

These functions now nest properly.  That is, for every object O, there
is a counter which scm_protect_object(O) increments and
scm_unprotect_object(O) decrements, if the counter is greater than
zero.  Every object's counter is zero when it is first created.  If an
object's counter is greater than zero, the garbage collector will not
reclaim its storage.

This allows you to use scm_protect_object in your code without
worrying that some other function you call will call
scm_unprotect_object, and allow it to be freed.  Assuming that the
functions you call are well-behaved, and unprotect only those objects
they protect, you can follow the same rule and have confidence that
objects will be freed only at appropriate times.


Changes in Guile 1.2 (released Tuesday, June 24 1997):

* Changes to the distribution

** Nightly snapshots are now available from ftp.red-bean.com.
The old server, ftp.cyclic.com, has been relinquished to its rightful
owner.

Nightly snapshots of the Guile development sources are now available via
anonymous FTP from ftp.red-bean.com, as /pub/guile/guile-snap.tar.gz.

Via the web, that's:  ftp://ftp.red-bean.com/pub/guile/guile-snap.tar.gz
For getit, that's:    ftp.red-bean.com:/pub/guile/guile-snap.tar.gz

** To run Guile without installing it, the procedure has changed a bit.

If you used a separate build directory to compile Guile, you'll need
to include the build directory in SCHEME_LOAD_PATH, as well as the
source directory.  See the `INSTALL' file for examples.

* Changes to the procedure for linking libguile with your programs

** The standard Guile load path for Scheme code now includes
$(datadir)/guile (usually /usr/local/share/guile).  This means that
you can install your own Scheme files there, and Guile will find them.
(Previous versions of Guile only checked a directory whose name
contained the Guile version number, so you had to re-install or move
your Scheme sources each time you installed a fresh version of Guile.)

The load path also includes $(datadir)/guile/site; we recommend
putting individual Scheme files there.  If you want to install a
package with multiple source files, create a directory for them under
$(datadir)/guile.

** Guile 1.2 will now use the Rx regular expression library, if it is
installed on your system.  When you are linking libguile into your own
programs, this means you will have to link against -lguile, -lqt (if
you configured Guile with thread support), and -lrx.

If you are using autoconf to generate configuration scripts for your
application, the following lines should suffice to add the appropriate
libraries to your link command:

### Find Rx, quickthreads and libguile.
AC_CHECK_LIB(rx, main)
AC_CHECK_LIB(qt, main)
AC_CHECK_LIB(guile, scm_shell)

The Guile 1.2 distribution does not contain sources for the Rx
library, as Guile 1.0 did.  If you want to use Rx, you'll need to
retrieve it from a GNU FTP site and install it separately.

* Changes to Scheme functions and syntax

** The dynamic linking features of Guile are now enabled by default.
You can disable them by giving the `--disable-dynamic-linking' option
to configure.

  (dynamic-link FILENAME)

    Find the object file denoted by FILENAME (a string) and link it
    into the running Guile application.  When everything works out,
    return a Scheme object suitable for representing the linked object
    file.  Otherwise an error is thrown.  How object files are
    searched is system dependent.

  (dynamic-object? VAL)

    Determine whether VAL represents a dynamically linked object file.

  (dynamic-unlink DYNOBJ)

    Unlink the indicated object file from the application.  DYNOBJ
    should be one of the values returned by `dynamic-link'.

  (dynamic-func FUNCTION DYNOBJ)

    Search the C function indicated by FUNCTION (a string or symbol)
    in DYNOBJ and return some Scheme object that can later be used
    with `dynamic-call' to actually call this function.  Right now,
    these Scheme objects are formed by casting the address of the
    function to `long' and converting this number to its Scheme
    representation.

  (dynamic-call FUNCTION DYNOBJ)

    Call the C function indicated by FUNCTION and DYNOBJ.  The
    function is passed no arguments and its return value is ignored.
    When FUNCTION is something returned by `dynamic-func', call that
    function and ignore DYNOBJ.  When FUNCTION is a string (or symbol,
    etc.), look it up in DYNOBJ; this is equivalent to

	(dynamic-call (dynamic-func FUNCTION DYNOBJ) #f)

    Interrupts are deferred while the C function is executing (with
    SCM_DEFER_INTS/SCM_ALLOW_INTS).

  (dynamic-args-call FUNCTION DYNOBJ ARGS)

    Call the C function indicated by FUNCTION and DYNOBJ, but pass it
    some arguments and return its return value.  The C function is
    expected to take two arguments and return an `int', just like
    `main':

	int c_func (int argc, char **argv);

    ARGS must be a list of strings and is converted into an array of
    `char *'.  The array is passed in ARGV and its size in ARGC.  The
    return value is converted to a Scheme number and returned from the
    call to `dynamic-args-call'.

When dynamic linking is disabled or not supported on your system,
the above functions throw errors, but they are still available.

Here is a small example that works on GNU/Linux:

  (define libc-obj (dynamic-link "libc.so"))
  (dynamic-args-call 'rand libc-obj '())

See the file `libguile/DYNAMIC-LINKING' for additional comments.

** The #/ syntax for module names is depreciated, and will be removed
in a future version of Guile.  Instead of 

	#/foo/bar/baz

instead write

	(foo bar baz)

The latter syntax is more consistent with existing Lisp practice.

** Guile now does fancier printing of structures.  Structures are the
underlying implementation for records, which in turn are used to
implement modules, so all of these object now print differently and in
a more informative way.

The Scheme printer will examine the builtin variable *struct-printer*
whenever it needs to print a structure object.  When this variable is
not `#f' it is deemed to be a procedure and will be applied to the
structure object and the output port.  When *struct-printer* is `#f'
or the procedure return `#f' the structure object will be printed in
the boring #<struct 80458270> form.

This hook is used by some routines in ice-9/boot-9.scm to implement
type specific printing routines.  Please read the comments there about
"printing structs".

One of the more specific uses of structs are records.  The printing
procedure that could be passed to MAKE-RECORD-TYPE is now actually
called.  It should behave like a *struct-printer* procedure (described
above).

** Guile now supports a new R4RS-compliant syntax for keywords.  A
token of the form #:NAME, where NAME has the same syntax as a Scheme
symbol, is the external representation of the keyword named NAME.
Keyword objects print using this syntax as well, so values containing
keyword objects can be read back into Guile.  When used in an
expression, keywords are self-quoting objects.

Guile suports this read syntax, and uses this print syntax, regardless
of the current setting of the `keyword' read option.  The `keyword'
read option only controls whether Guile recognizes the `:NAME' syntax,
which is incompatible with R4RS.  (R4RS says such token represent
symbols.)

** Guile has regular expression support again.  Guile 1.0 included
functions for matching regular expressions, based on the Rx library.
In Guile 1.1, the Guile/Rx interface was removed to simplify the
distribution, and thus Guile had no regular expression support.  Guile
1.2 again supports the most commonly used functions, and supports all
of SCSH's regular expression functions.

If your system does not include a POSIX regular expression library,
and you have not linked Guile with a third-party regexp library such as
Rx, these functions will not be available.  You can tell whether your
Guile installation includes regular expression support by checking
whether the `*features*' list includes the `regex' symbol.

*** regexp functions

By default, Guile supports POSIX extended regular expressions.  That
means that the characters `(', `)', `+' and `?' are special, and must
be escaped if you wish to match the literal characters.

This regular expression interface was modeled after that implemented
by SCSH, the Scheme Shell.  It is intended to be upwardly compatible
with SCSH regular expressions.

**** Function: string-match PATTERN STR [START]
     Compile the string PATTERN into a regular expression and compare
     it with STR.  The optional numeric argument START specifies the
     position of STR at which to begin matching.

     `string-match' returns a "match structure" which describes what,
     if anything, was matched by the regular expression.  *Note Match
     Structures::.  If STR does not match PATTERN at all,
     `string-match' returns `#f'.

   Each time `string-match' is called, it must compile its PATTERN
argument into a regular expression structure.  This operation is
expensive, which makes `string-match' inefficient if the same regular
expression is used several times (for example, in a loop).  For better
performance, you can compile a regular expression in advance and then
match strings against the compiled regexp.

**** Function: make-regexp STR [FLAGS]
     Compile the regular expression described by STR, and return the
     compiled regexp structure.  If STR does not describe a legal
     regular expression, `make-regexp' throws a
     `regular-expression-syntax' error.

     FLAGS may be the bitwise-or of one or more of the following:

**** Constant: regexp/extended
     Use POSIX Extended Regular Expression syntax when interpreting
     STR.  If not set, POSIX Basic Regular Expression syntax is used.
     If the FLAGS argument is omitted, we assume regexp/extended.

**** Constant: regexp/icase
     Do not differentiate case.  Subsequent searches using the
     returned regular expression will be case insensitive.

**** Constant: regexp/newline
     Match-any-character operators don't match a newline.

     A non-matching list ([^...]) not containing a newline matches a
     newline.

     Match-beginning-of-line operator (^) matches the empty string
     immediately after a newline, regardless of whether the FLAGS
     passed to regexp-exec contain regexp/notbol.

     Match-end-of-line operator ($) matches the empty string
     immediately before a newline, regardless of whether the FLAGS
     passed to regexp-exec contain regexp/noteol.

**** Function: regexp-exec REGEXP STR [START [FLAGS]]
     Match the compiled regular expression REGEXP against `str'.  If
     the optional integer START argument is provided, begin matching
     from that position in the string.  Return a match structure
     describing the results of the match, or `#f' if no match could be
     found.

     FLAGS may be the bitwise-or of one or more of the following:

**** Constant: regexp/notbol
     The match-beginning-of-line operator always fails to match (but
     see the compilation flag regexp/newline above) This flag may be
     used when different portions of a string are passed to
     regexp-exec and the beginning of the string should not be
     interpreted as the beginning of the line.

**** Constant: regexp/noteol
     The match-end-of-line operator always fails to match (but see the
     compilation flag regexp/newline above)

**** Function: regexp? OBJ
     Return `#t' if OBJ is a compiled regular expression, or `#f'
     otherwise.

   Regular expressions are commonly used to find patterns in one string
and replace them with the contents of another string.

**** Function: regexp-substitute PORT MATCH [ITEM...]
     Write to the output port PORT selected contents of the match
     structure MATCH.  Each ITEM specifies what should be written, and
     may be one of the following arguments:

        * A string.  String arguments are written out verbatim.

        * An integer.  The submatch with that number is written.

        * The symbol `pre'.  The portion of the matched string preceding
          the regexp match is written.

        * The symbol `post'.  The portion of the matched string
          following the regexp match is written.

     PORT may be `#f', in which case nothing is written; instead,
     `regexp-substitute' constructs a string from the specified ITEMs
     and returns that.

**** Function: regexp-substitute/global PORT REGEXP TARGET [ITEM...]
     Similar to `regexp-substitute', but can be used to perform global
     substitutions on STR.  Instead of taking a match structure as an
     argument, `regexp-substitute/global' takes two string arguments: a
     REGEXP string describing a regular expression, and a TARGET string
     which should be matched against this regular expression.

     Each ITEM behaves as in REGEXP-SUBSTITUTE, with the following
     exceptions:

        * A function may be supplied.  When this function is called, it
          will be passed one argument: a match structure for a given
          regular expression match.  It should return a string to be
          written out to PORT.

        * The `post' symbol causes `regexp-substitute/global' to recurse
          on the unmatched portion of STR.  This *must* be supplied in
          order to perform global search-and-replace on STR; if it is
          not present among the ITEMs, then `regexp-substitute/global'
          will return after processing a single match.

*** Match Structures

   A "match structure" is the object returned by `string-match' and
`regexp-exec'.  It describes which portion of a string, if any, matched
the given regular expression.  Match structures include: a reference to
the string that was checked for matches; the starting and ending
positions of the regexp match; and, if the regexp included any
parenthesized subexpressions, the starting and ending positions of each
submatch.

   In each of the regexp match functions described below, the `match'
argument must be a match structure returned by a previous call to
`string-match' or `regexp-exec'.  Most of these functions return some
information about the original target string that was matched against a
regular expression; we will call that string TARGET for easy reference.

**** Function: regexp-match? OBJ
     Return `#t' if OBJ is a match structure returned by a previous
     call to `regexp-exec', or `#f' otherwise.

**** Function: match:substring MATCH [N]
     Return the portion of TARGET matched by subexpression number N.
     Submatch 0 (the default) represents the entire regexp match.  If
     the regular expression as a whole matched, but the subexpression
     number N did not match, return `#f'.

**** Function: match:start MATCH [N]
     Return the starting position of submatch number N.

**** Function: match:end MATCH [N]
     Return the ending position of submatch number N.

**** Function: match:prefix MATCH
     Return the unmatched portion of TARGET preceding the regexp match.

**** Function: match:suffix MATCH
     Return the unmatched portion of TARGET following the regexp match.

**** Function: match:count MATCH
     Return the number of parenthesized subexpressions from MATCH.
     Note that the entire regular expression match itself counts as a
     subexpression, and failed submatches are included in the count.

**** Function: match:string MATCH
     Return the original TARGET string.

*** Backslash Escapes

   Sometimes you will want a regexp to match characters like `*' or `$'
exactly.  For example, to check whether a particular string represents
a menu entry from an Info node, it would be useful to match it against
a regexp like `^* [^:]*::'.  However, this won't work; because the
asterisk is a metacharacter, it won't match the `*' at the beginning of
the string.  In this case, we want to make the first asterisk un-magic.

   You can do this by preceding the metacharacter with a backslash
character `\'.  (This is also called "quoting" the metacharacter, and
is known as a "backslash escape".)  When Guile sees a backslash in a
regular expression, it considers the following glyph to be an ordinary
character, no matter what special meaning it would ordinarily have.
Therefore, we can make the above example work by changing the regexp to
`^\* [^:]*::'.  The `\*' sequence tells the regular expression engine
to match only a single asterisk in the target string.

   Since the backslash is itself a metacharacter, you may force a
regexp to match a backslash in the target string by preceding the
backslash with itself.  For example, to find variable references in a
TeX program, you might want to find occurrences of the string `\let\'
followed by any number of alphabetic characters.  The regular expression
`\\let\\[A-Za-z]*' would do this: the double backslashes in the regexp
each match a single backslash in the target string.

**** Function: regexp-quote STR
     Quote each special character found in STR with a backslash, and
     return the resulting string.

   *Very important:* Using backslash escapes in Guile source code (as
in Emacs Lisp or C) can be tricky, because the backslash character has
special meaning for the Guile reader.  For example, if Guile encounters
the character sequence `\n' in the middle of a string while processing
Scheme code, it replaces those characters with a newline character.
Similarly, the character sequence `\t' is replaced by a horizontal tab.
Several of these "escape sequences" are processed by the Guile reader
before your code is executed.  Unrecognized escape sequences are
ignored: if the characters `\*' appear in a string, they will be
translated to the single character `*'.

   This translation is obviously undesirable for regular expressions,
since we want to be able to include backslashes in a string in order to
escape regexp metacharacters.  Therefore, to make sure that a backslash
is preserved in a string in your Guile program, you must use *two*
consecutive backslashes:

     (define Info-menu-entry-pattern (make-regexp "^\\* [^:]*"))

   The string in this example is preprocessed by the Guile reader before
any code is executed.  The resulting argument to `make-regexp' is the
string `^\* [^:]*', which is what we really want.

   This also means that in order to write a regular expression that
matches a single backslash character, the regular expression string in
the source code must include *four* backslashes.  Each consecutive pair
of backslashes gets translated by the Guile reader to a single
backslash, and the resulting double-backslash is interpreted by the
regexp engine as matching a single backslash character.  Hence:

     (define tex-variable-pattern (make-regexp "\\\\let\\\\=[A-Za-z]*"))

   The reason for the unwieldiness of this syntax is historical.  Both
regular expression pattern matchers and Unix string processing systems
have traditionally used backslashes with the special meanings described
above.  The POSIX regular expression specification and ANSI C standard
both require these semantics.  Attempting to abandon either convention
would cause other kinds of compatibility problems, possibly more severe
ones.  Therefore, without extending the Scheme reader to support
strings with different quoting conventions (an ungainly and confusing
extension when implemented in other languages), we must adhere to this
cumbersome escape syntax.

* Changes to the gh_ interface

* Changes to the scm_ interface

* Changes to system call interfaces:

** The value returned by `raise' is now unspecified.  It throws an exception
if an error occurs.

*** A new procedure `sigaction' can be used to install signal handlers

(sigaction signum [action] [flags])

signum is the signal number, which can be specified using the value
of SIGINT etc.

If action is omitted, sigaction returns a pair: the CAR is the current
signal hander, which will be either an integer with the value SIG_DFL
(default action) or SIG_IGN (ignore), or the Scheme procedure which
handles the signal, or #f if a non-Scheme procedure handles the
signal.  The CDR contains the current sigaction flags for the handler.

If action is provided, it is installed as the new handler for signum.
action can be a Scheme procedure taking one argument, or the value of
SIG_DFL (default action) or SIG_IGN (ignore), or #f to restore
whatever signal handler was installed before sigaction was first used.
Flags can optionally be specified for the new handler (SA_RESTART is
always used if the system provides it, so need not be specified.)  The
return value is a pair with information about the old handler as
described above.

This interface does not provide access to the "signal blocking"
facility.  Maybe this is not needed, since the thread support may
provide solutions to the problem of consistent access to data
structures.

*** A new procedure `flush-all-ports' is equivalent to running
`force-output' on every port open for output.

** Guile now provides information on how it was built, via the new
global variable, %guile-build-info.  This variable records the values
of the standard GNU makefile directory variables as an assocation
list, mapping variable names (symbols) onto directory paths (strings).
For example, to find out where the Guile link libraries were
installed, you can say:

guile -c "(display (assq-ref %guile-build-info 'libdir)) (newline)"


* Changes to the scm_ interface

** The new function scm_handle_by_message_noexit is just like the
existing scm_handle_by_message function, except that it doesn't call
exit to terminate the process.  Instead, it prints a message and just
returns #f.  This might be a more appropriate catch-all handler for
new dynamic roots and threads.


Changes in Guile 1.1 (released Friday, May 16 1997):

* Changes to the distribution.

The Guile 1.0 distribution has been split up into several smaller
pieces:
guile-core --- the Guile interpreter itself.
guile-tcltk --- the interface between the Guile interpreter and
	Tcl/Tk; Tcl is an interpreter for a stringy language, and Tk
	is a toolkit for building graphical user interfaces.
guile-rgx-ctax --- the interface between Guile and the Rx regular
	expression matcher, and the translator for the Ctax
	programming language.  These are packaged together because the
	Ctax translator uses Rx to parse Ctax source code.

This NEWS file describes the changes made to guile-core since the 1.0
release.

We no longer distribute the documentation, since it was either out of
date, or incomplete.  As soon as we have current documentation, we
will distribute it.



* Changes to the stand-alone interpreter

** guile now accepts command-line arguments compatible with SCSH, Olin
Shivers' Scheme Shell.

In general, arguments are evaluated from left to right, but there are
exceptions.  The following switches stop argument processing, and
stash all remaining command-line arguments as the value returned by
the (command-line) function.
  -s SCRIPT      load Scheme source code from FILE, and exit
  -c EXPR        evalute Scheme expression EXPR, and exit
  --             stop scanning arguments; run interactively

The switches below are processed as they are encountered.
  -l FILE        load Scheme source code from FILE
  -e FUNCTION    after reading script, apply FUNCTION to
                 command line arguments
  -ds            do -s script at this point
  --emacs        enable Emacs protocol (experimental)
  -h, --help     display this help and exit
  -v, --version  display version information and exit
  \              read arguments from following script lines

So, for example, here is a Guile script named `ekko' (thanks, Olin)
which re-implements the traditional "echo" command:

#!/usr/local/bin/guile -s
!#
(define (main args)
	(map (lambda (arg) (display arg) (display " "))
	     (cdr args))
	(newline))

(main (command-line))

Suppose we invoke this script as follows:

	ekko a speckled gecko

Through the magic of Unix script processing (triggered by the `#!'
token at the top of the file), /usr/local/bin/guile receives the
following list of command-line arguments:

	("-s" "./ekko" "a" "speckled" "gecko")

Unix inserts the name of the script after the argument specified on
the first line of the file (in this case, "-s"), and then follows that
with the arguments given to the script.  Guile loads the script, which
defines the `main' function, and then applies it to the list of
remaining command-line arguments, ("a" "speckled" "gecko").

In Unix, the first line of a script file must take the following form:

#!INTERPRETER ARGUMENT

where INTERPRETER is the absolute filename of the interpreter
executable, and ARGUMENT is a single command-line argument to pass to
the interpreter.

You may only pass one argument to the interpreter, and its length is
limited.  These restrictions can be annoying to work around, so Guile
provides a general mechanism (borrowed from, and compatible with,
SCSH) for circumventing them.

If the ARGUMENT in a Guile script is a single backslash character,
`\', Guile will open the script file, parse arguments from its second
and subsequent lines, and replace the `\' with them.  So, for example,
here is another implementation of the `ekko' script:

#!/usr/local/bin/guile \
-e main -s
!#
(define (main args)
  (for-each (lambda (arg) (display arg) (display " "))
            (cdr args))
  (newline))

If the user invokes this script as follows:

	ekko a speckled gecko

Unix expands this into

	/usr/local/bin/guile \ ekko a speckled gecko

When Guile sees the `\' argument, it replaces it with the arguments
read from the second line of the script, producing:

	/usr/local/bin/guile -e main -s ekko a speckled gecko

This tells Guile to load the `ekko' script, and apply the function
`main' to the argument list ("a" "speckled" "gecko").

Here is how Guile parses the command-line arguments:
- Each space character terminates an argument.  This means that two
  spaces in a row introduce an empty-string argument.
- The tab character is not permitted (unless you quote it with the
  backslash character, as described below), to avoid confusion.
- The newline character terminates the sequence of arguments, and will
  also terminate a final non-empty argument.  (However, a newline
  following a space will not introduce a final empty-string argument;
  it only terminates the argument list.)
- The backslash character is the escape character.  It escapes
  backslash, space, tab, and newline.  The ANSI C escape sequences
  like \n and \t are also supported.  These produce argument
  constituents; the two-character combination \n doesn't act like a
  terminating newline.  The escape sequence \NNN for exactly three
  octal digits reads as the character whose ASCII code is NNN.  As
  above, characters produced this way are argument constituents.
  Backslash followed by other characters is not allowed.

* Changes to the procedure for linking libguile with your programs

** Guile now builds and installs a shared guile library, if your
system support shared libraries.  (It still builds a static library on
all systems.)  Guile automatically detects whether your system
supports shared libraries.  To prevent Guile from buildisg shared
libraries, pass the `--disable-shared' flag to the configure script.

Guile takes longer to compile when it builds shared libraries, because
it must compile every file twice --- once to produce position-
independent object code, and once to produce normal object code.

** The libthreads library has been merged into libguile.

To link a program against Guile, you now need only link against
-lguile and -lqt; -lthreads is no longer needed.  If you are using
autoconf to generate configuration scripts for your application, the
following lines should suffice to add the appropriate libraries to
your link command:

### Find quickthreads and libguile.
AC_CHECK_LIB(qt, main)
AC_CHECK_LIB(guile, scm_shell)

* Changes to Scheme functions

** Guile Scheme's special syntax for keyword objects is now optional,
and disabled by default.

The syntax variation from R4RS made it difficult to port some
interesting packages to Guile.  The routines which accepted keyword
arguments (mostly in the module system) have been modified to also
accept symbols whose names begin with `:'.

To change the keyword syntax, you must first import the (ice-9 debug)
module:
	(use-modules (ice-9 debug))

Then you can enable the keyword syntax as follows:
	(read-set! keywords 'prefix)

To disable keyword syntax, do this:
	(read-set! keywords #f)

** Many more primitive functions accept shared substrings as
arguments.  In the past, these functions required normal, mutable
strings as arguments, although they never made use of this
restriction.

** The uniform array functions now operate on byte vectors.  These
functions are `array-fill!', `serial-array-copy!', `array-copy!',
`serial-array-map', `array-map', `array-for-each', and
`array-index-map!'.

** The new functions `trace' and `untrace' implement simple debugging
support for Scheme functions.

The `trace' function accepts any number of procedures as arguments,
and tells the Guile interpreter to display each procedure's name and
arguments each time the procedure is invoked.  When invoked with no
arguments, `trace' returns the list of procedures currently being
traced.

The `untrace' function accepts any number of procedures as arguments,
and tells the Guile interpreter not to trace them any more.  When
invoked with no arguments, `untrace' untraces all curretly traced
procedures.

The tracing in Guile has an advantage over most other systems: we
don't create new procedure objects, but mark the procedure objects
themselves.  This means that anonymous and internal procedures can be
traced.

** The function `assert-repl-prompt' has been renamed to
`set-repl-prompt!'.  It takes one argument, PROMPT.
- If PROMPT is #f, the Guile read-eval-print loop will not prompt.
- If PROMPT is a string, we use it as a prompt.
- If PROMPT is a procedure accepting no arguments, we call it, and
  display the result as a prompt.
- Otherwise, we display "> ".

** The new function `eval-string' reads Scheme expressions from a
string and evaluates them, returning the value of the last expression
in the string.  If the string contains no expressions, it returns an
unspecified value.

** The new function `thunk?' returns true iff its argument is a
procedure of zero arguments.

** `defined?' is now a builtin function, instead of syntax.  This
means that its argument should be quoted.  It returns #t iff its
argument is bound in the current module.

** The new syntax `use-modules' allows you to add new modules to your
environment without re-typing a complete `define-module' form.  It
accepts any number of module names as arguments, and imports their
public bindings into the current module.

** The new function (module-defined? NAME MODULE) returns true iff
NAME, a symbol, is defined in MODULE, a module object.

** The new function `builtin-bindings' creates and returns a hash
table containing copies of all the root module's bindings.

** The new function `builtin-weak-bindings' does the same as
`builtin-bindings', but creates a doubly-weak hash table.

** The `equal?' function now considers variable objects to be
equivalent if they have the same name and the same value.

** The new function `command-line' returns the command-line arguments
given to Guile, as a list of strings.

When using guile as a script interpreter, `command-line' returns the
script's arguments; those processed by the interpreter (like `-s' or
`-c') are omitted.  (In other words, you get the normal, expected
behavior.)  Any application that uses scm_shell to process its
command-line arguments gets this behavior as well.

** The new function `load-user-init' looks for a file called `.guile'
in the user's home directory, and loads it if it exists.  This is
mostly for use by the code generated by scm_compile_shell_switches,
but we thought it might also be useful in other circumstances.

** The new function `log10' returns the base-10 logarithm of its
argument.

** Changes to I/O functions

*** The functions `read', `primitive-load', `read-and-eval!', and 
`primitive-load-path' no longer take optional arguments controlling
case insensitivity and a `#' parser.

Case sensitivity is now controlled by a read option called
`case-insensitive'.  The user can add new `#' syntaxes with the
`read-hash-extend' function (see below).

*** The new function `read-hash-extend' allows the user to change the
syntax of Guile Scheme in a somewhat controlled way.

(read-hash-extend CHAR PROC)
  When parsing S-expressions, if we read a `#' character followed by
  the character CHAR, use PROC to parse an object from the stream.
  If PROC is #f, remove any parsing procedure registered for CHAR.

  The reader applies PROC to two arguments: CHAR and an input port.

*** The new functions read-delimited and read-delimited! provide a 
general mechanism for doing delimited input on streams.

(read-delimited DELIMS [PORT HANDLE-DELIM])
  Read until we encounter one of the characters in DELIMS (a string),
  or end-of-file.  PORT is the input port to read from; it defaults to
  the current input port.  The HANDLE-DELIM parameter determines how
  the terminating character is handled; it should be one of the
  following symbols:

    'trim     omit delimiter from result
    'peek     leave delimiter character in input stream
    'concat   append delimiter character to returned value
    'split    return a pair: (RESULT . TERMINATOR)

  HANDLE-DELIM defaults to 'peek.

(read-delimited! DELIMS BUF [PORT HANDLE-DELIM START END])
  A side-effecting variant of `read-delimited'.

  The data is written into the string BUF at the indices in the
  half-open interval [START, END); the default interval is the whole
  string: START = 0 and END = (string-length BUF).  The values of
  START and END must specify a well-defined interval in BUF, i.e.
  0 <= START <= END <= (string-length BUF).

  It returns NBYTES, the number of bytes read.  If the buffer filled
  up without a delimiter character being found, it returns #f.  If the
  port is at EOF when the read starts, it returns the EOF object.

  If an integer is returned (i.e., the read is successfully terminated
  by reading a delimiter character), then the HANDLE-DELIM parameter
  determines how to handle the terminating character.  It is described
  above, and defaults to 'peek.

(The descriptions of these functions were borrowed from the SCSH
manual, by Olin Shivers and Brian Carlstrom.)

*** The `%read-delimited!' function is the primitive used to implement
`read-delimited' and `read-delimited!'.

(%read-delimited! DELIMS BUF GOBBLE? [PORT START END])

This returns a pair of values: (TERMINATOR . NUM-READ).
- TERMINATOR describes why the read was terminated.  If it is a
  character or the eof object, then that is the value that terminated
  the read.  If it is #f, the function filled the buffer without finding
  a delimiting character.
- NUM-READ is the number of characters read into BUF.

If the read is successfully terminated by reading a delimiter
character, then the gobble? parameter determines what to do with the
terminating character.  If true, the character is removed from the
input stream; if false, the character is left in the input stream
where a subsequent read operation will retrieve it.  In either case,
the character is also the first value returned by the procedure call.

(The descriptions of this function was borrowed from the SCSH manual,
by Olin Shivers and Brian Carlstrom.)

*** The `read-line' and `read-line!' functions have changed; they now
trim the terminator by default; previously they appended it to the
returned string.  For the old behavior, use (read-line PORT 'concat).

*** The functions `uniform-array-read!' and `uniform-array-write!' now
take new optional START and END arguments, specifying the region of
the array to read and write.

*** The `ungetc-char-ready?' function has been removed.  We feel it's
inappropriate for an interface to expose implementation details this
way.

** Changes to the Unix library and system call interface

*** The new fcntl function provides access to the Unix `fcntl' system
call.

(fcntl PORT COMMAND VALUE)
  Apply COMMAND to PORT's file descriptor, with VALUE as an argument.
  Values for COMMAND are:

    F_DUPFD	duplicate a file descriptor
    F_GETFD	read the descriptor's close-on-exec flag
    F_SETFD     set the descriptor's close-on-exec flag to VALUE
    F_GETFL	read the descriptor's flags, as set on open
    F_SETFL	set the descriptor's flags, as set on open to VALUE
    F_GETOWN    return the process ID of a socket's owner, for SIGIO
    F_SETOWN    set the process that owns a socket to VALUE, for SIGIO
    FD_CLOEXEC  not sure what this is

For details, see the documentation for the fcntl system call.

*** The arguments to `select' have changed, for compatibility with
SCSH.  The TIMEOUT parameter may now be non-integral, yielding the
expected behavior.  The MILLISECONDS parameter has been changed to
MICROSECONDS, to more closely resemble the underlying system call.
The RVEC, WVEC, and EVEC arguments can now be vectors; the type of the
corresponding return set will be the same.

*** The arguments to the `mknod' system call have changed.  They are
now:

(mknod PATH TYPE PERMS DEV)
  Create a new file (`node') in the file system.  PATH is the name of
  the file to create.  TYPE is the kind of file to create; it should
  be 'fifo, 'block-special, or 'char-special.  PERMS specifies the
  permission bits to give the newly created file.  If TYPE is
  'block-special or 'char-special, DEV specifies which device the
  special file refers to; its interpretation depends on the kind of
  special file being created.

*** The `fork' function has been renamed to `primitive-fork', to avoid
clashing with various SCSH forks.

*** The `recv' and `recvfrom' functions have been renamed to `recv!'
and `recvfrom!'.  They no longer accept a size for a second argument;
you must pass a string to hold the received value.  They no longer
return the buffer.  Instead, `recv' returns the length of the message
received, and `recvfrom' returns a pair containing the packet's length
and originating address. 

*** The file descriptor datatype has been removed, as have the
`read-fd', `write-fd', `close', `lseek', and `dup' functions.
We plan to replace these functions with a SCSH-compatible interface.

*** The `create' function has been removed; it's just a special case
of `open'.

*** There are new functions to break down process termination status
values.  In the descriptions below, STATUS is a value returned by
`waitpid'.

(status:exit-val STATUS)
  If the child process exited normally, this function returns the exit
  code for the child process (i.e., the value passed to exit, or
  returned from main).  If the child process did not exit normally,
  this function returns #f.

(status:stop-sig STATUS)
  If the child process was suspended by a signal, this function
  returns the signal that suspended the child.  Otherwise, it returns
  #f.

(status:term-sig STATUS)
  If the child process terminated abnormally, this function returns
  the signal that terminated the child.  Otherwise, this function
  returns false.

POSIX promises that exactly one of these functions will return true on
a valid STATUS value.

These functions are compatible with SCSH.

*** There are new accessors and setters for the broken-out time vectors
returned by `localtime', `gmtime', and that ilk.  They are:

  Component                 Accessor     Setter
  ========================= ============ ============
  seconds                   tm:sec       set-tm:sec
  minutes                   tm:min       set-tm:min
  hours                     tm:hour      set-tm:hour
  day of the month          tm:mday      set-tm:mday
  month                     tm:mon       set-tm:mon
  year                      tm:year      set-tm:year
  day of the week           tm:wday      set-tm:wday
  day in the year           tm:yday      set-tm:yday
  daylight saving time      tm:isdst     set-tm:isdst
  GMT offset, seconds       tm:gmtoff    set-tm:gmtoff
  name of time zone         tm:zone      set-tm:zone

*** There are new accessors for the vectors returned by `uname',
describing the host system:

  Component                                      Accessor
  ============================================== ================
  name of the operating system implementation    utsname:sysname
  network name of this machine                   utsname:nodename
  release level of the operating system          utsname:release
  version level of the operating system          utsname:version
  machine hardware platform                      utsname:machine

*** There are new accessors for the vectors returned by `getpw',
`getpwnam', `getpwuid', and `getpwent', describing entries from the
system's user database:

  Component              Accessor
  ====================== =================
  user name              passwd:name
  user password		 passwd:passwd
  user id		 passwd:uid
  group id		 passwd:gid
  real name		 passwd:gecos
  home directory	 passwd:dir
  shell program		 passwd:shell

*** There are new accessors for the vectors returned by `getgr',
`getgrnam', `getgrgid', and `getgrent', describing entries from the
system's group database:

  Component               Accessor
  ======================= ============
  group name              group:name
  group password 	  group:passwd
  group id       	  group:gid
  group members  	  group:mem

*** There are new accessors for the vectors returned by `gethost',
`gethostbyaddr', `gethostbyname', and `gethostent', describing
internet hosts:

  Component                 Accessor
  ========================= ===============
  official name of host     hostent:name
  alias list		    hostent:aliases
  host address type	    hostent:addrtype
  length of address	    hostent:length
  list of addresses	    hostent:addr-list

*** There are new accessors for the vectors returned by `getnet',
`getnetbyaddr', `getnetbyname', and `getnetent', describing internet
networks:

  Component                 Accessor
  ========================= ===============
  official name of net      netent:name
  alias list		    netent:aliases
  net number type	    netent:addrtype
  net number		    netent:net

*** There are new accessors for the vectors returned by `getproto',
`getprotobyname', `getprotobynumber', and `getprotoent', describing
internet protocols:

  Component                 Accessor
  ========================= ===============
  official protocol name    protoent:name
  alias list		    protoent:aliases
  protocol number	    protoent:proto

*** There are new accessors for the vectors returned by `getserv',
`getservbyname', `getservbyport', and `getservent', describing
internet protocols:

  Component                 Accessor
  ========================= ===============
  official service name     servent:name   
  alias list		    servent:aliases
  port number		    servent:port   
  protocol to use	    servent:proto  

*** There are new accessors for the sockaddr structures returned by
`accept', `getsockname', `getpeername', `recvfrom!':

  Component                                Accessor
  ======================================== ===============
  address format (`family')                sockaddr:fam 
  path, for file domain addresses	   sockaddr:path
  address, for internet domain addresses   sockaddr:addr
  TCP or UDP port, for internet		   sockaddr:port

*** The `getpwent', `getgrent', `gethostent', `getnetent',
`getprotoent', and `getservent' functions now return #f at the end of
the user database.  (They used to throw an exception.)

Note that calling MUMBLEent function is equivalent to calling the
corresponding MUMBLE function with no arguments.

*** The `setpwent', `setgrent', `sethostent', `setnetent',
`setprotoent', and `setservent' routines now take no arguments.

*** The `gethost', `getproto', `getnet', and `getserv' functions now
provide more useful information when they throw an exception.

*** The `lnaof' function has been renamed to `inet-lnaof'.

*** Guile now claims to have the `current-time' feature.

*** The `mktime' function now takes an optional second argument ZONE,
giving the time zone to use for the conversion.  ZONE should be a
string, in the same format as expected for the "TZ" environment variable.

*** The `strptime' function now returns a pair (TIME . COUNT), where
TIME is the parsed time as a vector, and COUNT is the number of
characters from the string left unparsed.  This function used to
return the remaining characters as a string.

*** The `gettimeofday' function has replaced the old `time+ticks' function.
The return value is now (SECONDS . MICROSECONDS); the fractional
component is no longer expressed in "ticks".

*** The `ticks/sec' constant has been removed, in light of the above change.

* Changes to the gh_ interface

** gh_eval_str() now returns an SCM object which is the result of the
evaluation

** gh_scm2str() now copies the Scheme data to a caller-provided C
array

** gh_scm2newstr() now makes a C array, copies the Scheme data to it,
and returns the array

** gh_scm2str0() is gone: there is no need to distinguish
null-terminated from non-null-terminated, since gh_scm2newstr() allows
the user to interpret the data both ways.

* Changes to the scm_ interface

** The new function scm_symbol_value0 provides an easy way to get a
symbol's value from C code:

SCM scm_symbol_value0 (char *NAME)
  Return the value of the symbol named by the null-terminated string
  NAME in the current module.  If the symbol named NAME is unbound in
  the current module, return SCM_UNDEFINED.

** The new function scm_sysintern0 creates new top-level variables,
without assigning them a value.

SCM scm_sysintern0 (char *NAME)
  Create a new Scheme top-level variable named NAME.  NAME is a
  null-terminated string.  Return the variable's value cell.

** The function scm_internal_catch is the guts of catch.  It handles
all the mechanics of setting up a catch target, invoking the catch
body, and perhaps invoking the handler if the body does a throw.

The function is designed to be usable from C code, but is general
enough to implement all the semantics Guile Scheme expects from throw.

TAG is the catch tag.  Typically, this is a symbol, but this function
doesn't actually care about that.

BODY is a pointer to a C function which runs the body of the catch;
this is the code you can throw from.  We call it like this:
   BODY (BODY_DATA, JMPBUF)
where:
   BODY_DATA is just the BODY_DATA argument we received; we pass it
      through to BODY as its first argument.  The caller can make
      BODY_DATA point to anything useful that BODY might need.
   JMPBUF is the Scheme jmpbuf object corresponding to this catch,
      which we have just created and initialized.

HANDLER is a pointer to a C function to deal with a throw to TAG,
should one occur.  We call it like this:
   HANDLER (HANDLER_DATA, THROWN_TAG, THROW_ARGS)
where
   HANDLER_DATA is the HANDLER_DATA argument we recevied; it's the
      same idea as BODY_DATA above.
   THROWN_TAG is the tag that the user threw to; usually this is
      TAG, but it could be something else if TAG was #t (i.e., a
      catch-all), or the user threw to a jmpbuf.
   THROW_ARGS is the list of arguments the user passed to the THROW
      function.

BODY_DATA is just a pointer we pass through to BODY.  HANDLER_DATA
is just a pointer we pass through to HANDLER.  We don't actually
use either of those pointers otherwise ourselves.  The idea is
that, if our caller wants to communicate something to BODY or
HANDLER, it can pass a pointer to it as MUMBLE_DATA, which BODY and
HANDLER can then use.  Think of it as a way to make BODY and
HANDLER closures, not just functions; MUMBLE_DATA points to the
enclosed variables.

Of course, it's up to the caller to make sure that any data a
MUMBLE_DATA needs is protected from GC.  A common way to do this is
to make MUMBLE_DATA a pointer to data stored in an automatic
structure variable; since the collector must scan the stack for
references anyway, this assures that any references in MUMBLE_DATA
will be found.

** The new function scm_internal_lazy_catch is exactly like
scm_internal_catch, except:

- It does not unwind the stack (this is the major difference).
- If handler returns, its value is returned from the throw.
- BODY always receives #f as its JMPBUF argument (since there's no
  jmpbuf associated with a lazy catch, because we don't unwind the
  stack.)

** scm_body_thunk is a new body function you can pass to
scm_internal_catch if you want the body to be like Scheme's `catch'
--- a thunk, or a function of one argument if the tag is #f.

BODY_DATA is a pointer to a scm_body_thunk_data structure, which
contains the Scheme procedure to invoke as the body, and the tag
we're catching.  If the tag is #f, then we pass JMPBUF (created by
scm_internal_catch) to the body procedure; otherwise, the body gets
no arguments.

** scm_handle_by_proc is a new handler function you can pass to
scm_internal_catch if you want the handler to act like Scheme's catch
--- call a procedure with the tag and the throw arguments.

If the user does a throw to this catch, this function runs a handler
procedure written in Scheme.  HANDLER_DATA is a pointer to an SCM
variable holding the Scheme procedure object to invoke.  It ought to
be a pointer to an automatic variable (i.e., one living on the stack),
or the procedure object should be otherwise protected from GC.

** scm_handle_by_message is a new handler function to use with
`scm_internal_catch' if you want Guile to print a message and die.
It's useful for dealing with throws to uncaught keys at the top level.

HANDLER_DATA, if non-zero, is assumed to be a char * pointing to a
message header to print; if zero, we use "guile" instead.  That
text is followed by a colon, then the message described by ARGS.

** The return type of scm_boot_guile is now void; the function does
not return a value, and indeed, never returns at all.

** The new function scm_shell makes it easy for user applications to
process command-line arguments in a way that is compatible with the
stand-alone guile interpreter (which is in turn compatible with SCSH,
the Scheme shell).

To use the scm_shell function, first initialize any guile modules
linked into your application, and then call scm_shell with the values
of ARGC and ARGV your `main' function received.  scm_shell will add
any SCSH-style meta-arguments from the top of the script file to the
argument vector, and then process the command-line arguments.  This
generally means loading a script file or starting up an interactive
command interpreter.  For details, see "Changes to the stand-alone
interpreter" above.

** The new functions scm_get_meta_args and scm_count_argv help you
implement the SCSH-style meta-argument, `\'.  

char **scm_get_meta_args (int ARGC, char **ARGV)
  If the second element of ARGV is a string consisting of a single
  backslash character (i.e. "\\" in Scheme notation), open the file
  named by the following argument, parse arguments from it, and return
  the spliced command line.  The returned array is terminated by a
  null pointer.
  
  For details of argument parsing, see above, under "guile now accepts
  command-line arguments compatible with SCSH..."

int scm_count_argv (char **ARGV)
  Count the arguments in ARGV, assuming it is terminated by a null
  pointer.

For an example of how these functions might be used, see the source
code for the function scm_shell in libguile/script.c.

You will usually want to use scm_shell instead of calling this
function yourself.

** The new function scm_compile_shell_switches turns an array of
command-line arguments into Scheme code to carry out the actions they
describe.  Given ARGC and ARGV, it returns a Scheme expression to
evaluate, and calls scm_set_program_arguments to make any remaining
command-line arguments available to the Scheme code.  For example,
given the following arguments:

	-e main -s ekko a speckled gecko

scm_set_program_arguments will return the following expression:

	(begin (load "ekko") (main (command-line)) (quit))

You will usually want to use scm_shell instead of calling this
function yourself.

** The function scm_shell_usage prints a usage message appropriate for
an interpreter that uses scm_compile_shell_switches to handle its
command-line arguments.

void scm_shell_usage (int FATAL, char *MESSAGE)
  Print a usage message to the standard error output.  If MESSAGE is
  non-zero, write it before the usage message, followed by a newline.
  If FATAL is non-zero, exit the process, using FATAL as the
  termination status.  (If you want to be compatible with Guile,
  always use 1 as the exit status when terminating due to command-line
  usage problems.)

You will usually want to use scm_shell instead of calling this
function yourself.

** scm_eval_0str now returns SCM_UNSPECIFIED if the string contains no
expressions.  It used to return SCM_EOL.  Earth-shattering.

** The macros for declaring scheme objects in C code have been
rearranged slightly.  They are now:

SCM_SYMBOL (C_NAME, SCHEME_NAME)
  Declare a static SCM variable named C_NAME, and initialize it to
  point to the Scheme symbol whose name is SCHEME_NAME.  C_NAME should
  be a C identifier, and SCHEME_NAME should be a C string.

SCM_GLOBAL_SYMBOL (C_NAME, SCHEME_NAME)
  Just like SCM_SYMBOL, but make C_NAME globally visible.

SCM_VCELL (C_NAME, SCHEME_NAME)
  Create a global variable at the Scheme level named SCHEME_NAME.
  Declare a static SCM variable named C_NAME, and initialize it to
  point to the Scheme variable's value cell.

SCM_GLOBAL_VCELL (C_NAME, SCHEME_NAME)
  Just like SCM_VCELL, but make C_NAME globally visible.

The `guile-snarf' script writes initialization code for these macros
to its standard output, given C source code as input.

The SCM_GLOBAL macro is gone.

** The scm_read_line and scm_read_line_x functions have been replaced
by Scheme code based on the %read-delimited! procedure (known to C
code as scm_read_delimited_x).  See its description above for more
information.

** The function scm_sys_open has been renamed to scm_open.  It now
returns a port instead of an FD object.

* The dynamic linking support has changed.  For more information, see
libguile/DYNAMIC-LINKING.


Guile 1.0b3

User-visible changes from Thursday, September 5, 1996 until Guile 1.0
(Sun 5 Jan 1997):

* Changes to the 'guile' program:

** Guile now loads some new files when it starts up.  Guile first
searches the load path for init.scm, and loads it if found.  Then, if
Guile is not being used to execute a script, and the user's home
directory contains a file named `.guile', Guile loads that.

** You can now use Guile as a shell script interpreter.

To paraphrase the SCSH manual:

    When Unix tries to execute an executable file whose first two
    characters are the `#!', it treats the file not as machine code to
    be directly executed by the native processor, but as source code
    to be executed by some interpreter.  The interpreter to use is
    specified immediately after the #! sequence on the first line of
    the source file.  The kernel reads in the name of the interpreter,
    and executes that instead.  It passes the interpreter the source
    filename as its first argument, with the original arguments
    following.  Consult the Unix man page for the `exec' system call
    for more information.

Now you can use Guile as an interpreter, using a mechanism which is a
compatible subset of that provided by SCSH.

Guile now recognizes a '-s' command line switch, whose argument is the
name of a file of Scheme code to load.  It also treats the two
characters `#!' as the start of a comment, terminated by `!#'.  Thus,
to make a file of Scheme code directly executable by Unix, insert the
following two lines at the top of the file:

#!/usr/local/bin/guile -s
!#

Guile treats the argument of the `-s' command-line switch as the name
of a file of Scheme code to load, and treats the sequence `#!' as the
start of a block comment, terminated by `!#'.

For example, here's a version of 'echo' written in Scheme:

#!/usr/local/bin/guile -s
!#
(let loop ((args (cdr (program-arguments))))
  (if (pair? args)
      (begin
	(display (car args))
	(if (pair? (cdr args))
	    (display " "))
	(loop (cdr args)))))
(newline)

Why does `#!' start a block comment terminated by `!#', instead of the
end of the line?  That is the notation SCSH uses, and although we
don't yet support the other SCSH features that motivate that choice,
we would like to be backward-compatible with any existing Guile
scripts once we do.  Furthermore, if the path to Guile on your system
is too long for your kernel, you can start the script with this
horrible hack:

#!/bin/sh
exec /really/long/path/to/guile -s "$0" ${1+"$@"}
!#

Note that some very old Unix systems don't support the `#!' syntax.


** You can now run Guile without installing it.

Previous versions of the interactive Guile interpreter (`guile')
couldn't start up unless Guile's Scheme library had been installed;
they used the value of the environment variable `SCHEME_LOAD_PATH'
later on in the startup process, but not to find the startup code
itself.  Now Guile uses `SCHEME_LOAD_PATH' in all searches for Scheme
code.

To run Guile without installing it, build it in the normal way, and
then set the environment variable `SCHEME_LOAD_PATH' to a
colon-separated list of directories, including the top-level directory
of the Guile sources.  For example, if you unpacked Guile so that the
full filename of this NEWS file is /home/jimb/guile-1.0b3/NEWS, then
you might say

	export SCHEME_LOAD_PATH=/home/jimb/my-scheme:/home/jimb/guile-1.0b3


** Guile's read-eval-print loop no longer prints #<unspecified>
results.  If the user wants to see this, she can evaluate the
expression (assert-repl-print-unspecified #t), perhaps in her startup
file.

** Guile no longer shows backtraces by default when an error occurs;
however, it does display a message saying how to get one, and how to
request that they be displayed by default.  After an error, evaluate
   (backtrace)
to see a backtrace, and
   (debug-enable 'backtrace)
to see them by default.



* Changes to Guile Scheme:

** Guile now distinguishes between #f and the empty list.

This is for compatibility with the IEEE standard, the (possibly)
upcoming Revised^5 Report on Scheme, and many extant Scheme
implementations.

Guile used to have #f and '() denote the same object, to make Scheme's
type system more compatible with Emacs Lisp's.  However, the change
caused too much trouble for Scheme programmers, and we found another
way to reconcile Emacs Lisp with Scheme that didn't require this.


** Guile's delq, delv, delete functions, and their destructive
counterparts, delq!, delv!, and delete!, now remove all matching
elements from the list, not just the first.  This matches the behavior
of the corresponding Emacs Lisp functions, and (I believe) the Maclisp
functions which inspired them.

I recognize that this change may break code in subtle ways, but it
seems best to make the change before the FSF's first Guile release,
rather than after.


** The compiled-library-path function has been deleted from libguile.

** The facilities for loading Scheme source files have changed.

*** The variable %load-path now tells Guile which directories to search
for Scheme code.  Its value is a list of strings, each of which names
a directory.

*** The variable %load-extensions now tells Guile which extensions to
try appending to a filename when searching the load path.  Its value
is a list of strings.  Its default value is ("" ".scm").

*** (%search-load-path FILENAME) searches the directories listed in the
value of the %load-path variable for a Scheme file named FILENAME,
with all the extensions listed in %load-extensions.  If it finds a
match, then it returns its full filename.  If FILENAME is absolute, it
returns it unchanged.  Otherwise, it returns #f.

%search-load-path will not return matches that refer to directories.

*** (primitive-load FILENAME :optional CASE-INSENSITIVE-P SHARP)
uses %seach-load-path to find a file named FILENAME, and loads it if
it finds it.  If it can't read FILENAME for any reason, it throws an
error.

The arguments CASE-INSENSITIVE-P and SHARP are interpreted as by the
`read' function.

*** load uses the same searching semantics as primitive-load.

*** The functions %try-load, try-load-with-path, %load, load-with-path,
basic-try-load-with-path, basic-load-with-path, try-load-module-with-
path, and load-module-with-path have been deleted.  The functions
above should serve their purposes.

*** If the value of the variable %load-hook is a procedure,
`primitive-load' applies its value to the name of the file being
loaded (without the load path directory name prepended).  If its value
is #f, it is ignored.  Otherwise, an error occurs.

This is mostly useful for printing load notification messages.


** The function `eval!' is no longer accessible from the scheme level.
We can't allow operations which introduce glocs into the scheme level,
because Guile's type system can't handle these as data.  Use `eval' or
`read-and-eval!' (see below) as replacement.

** The new function read-and-eval! reads an expression from PORT,
evaluates it, and returns the result.  This is more efficient than
simply calling `read' and `eval', since it is not necessary to make a
copy of the expression for the evaluator to munge.

Its optional arguments CASE_INSENSITIVE_P and SHARP are interpreted as
for the `read' function.


** The function `int?' has been removed; its definition was identical
to that of `integer?'.

** The functions `<?', `<?', `<=?', `=?', `>?', and `>=?'.  Code should
use the R4RS names for these functions.

** The function object-properties no longer returns the hash handle;
it simply returns the object's property list.

** Many functions have been changed to throw errors, instead of
returning #f on failure.  The point of providing exception handling in
the language is to simplify the logic of user code, but this is less
useful if Guile's primitives don't throw exceptions.

** The function `fileno' has been renamed from `%fileno'.

** The function primitive-mode->fdes returns #t or #f now, not 1 or 0.


* Changes to Guile's C interface:

** The library's initialization procedure has been simplified.
scm_boot_guile now has the prototype:

void scm_boot_guile (int ARGC,
                     char **ARGV,
	             void (*main_func) (),
	             void *closure);

scm_boot_guile calls MAIN_FUNC, passing it CLOSURE, ARGC, and ARGV.
MAIN_FUNC should do all the work of the program (initializing other
packages, reading user input, etc.) before returning.  When MAIN_FUNC
returns, call exit (0); this function never returns.  If you want some
other exit value, MAIN_FUNC may call exit itself.

scm_boot_guile arranges for program-arguments to return the strings
given by ARGC and ARGV.  If MAIN_FUNC modifies ARGC/ARGV, should call
scm_set_program_arguments with the final list, so Scheme code will
know which arguments have been processed.

scm_boot_guile establishes a catch-all catch handler which prints an
error message and exits the process.  This means that Guile exits in a
coherent way when system errors occur and the user isn't prepared to
handle it.  If the user doesn't like this behavior, they can establish
their own universal catcher in MAIN_FUNC to shadow this one.

Why must the caller do all the real work from MAIN_FUNC?  The garbage
collector assumes that all local variables of type SCM will be above
scm_boot_guile's stack frame on the stack.  If you try to manipulate
SCM values after this function returns, it's the luck of the draw
whether the GC will be able to find the objects you allocate.  So,
scm_boot_guile function exits, rather than returning, to discourage
people from making that mistake.

The IN, OUT, and ERR arguments were removed; there are other
convenient ways to override these when desired.

The RESULT argument was deleted; this function should never return.

The BOOT_CMD argument was deleted; the MAIN_FUNC argument is more
general.


** Guile's header files should no longer conflict with your system's
header files.

In order to compile code which #included <libguile.h>, previous
versions of Guile required you to add a directory containing all the
Guile header files to your #include path.  This was a problem, since
Guile's header files have names which conflict with many systems'
header files.

Now only <libguile.h> need appear in your #include path; you must
refer to all Guile's other header files as <libguile/mumble.h>.
Guile's installation procedure puts libguile.h in $(includedir), and
the rest in $(includedir)/libguile.


** Two new C functions, scm_protect_object and scm_unprotect_object,
have been added to the Guile library.

scm_protect_object (OBJ) protects OBJ from the garbage collector.
OBJ will not be freed, even if all other references are dropped,
until someone does scm_unprotect_object (OBJ).  Both functions
return OBJ.

Note that calls to scm_protect_object do not nest.  You can call
scm_protect_object any number of times on a given object, and the
next call to scm_unprotect_object will unprotect it completely.

Basically, scm_protect_object and scm_unprotect_object just
maintain a list of references to things.  Since the GC knows about
this list, all objects it mentions stay alive.  scm_protect_object
adds its argument to the list; scm_unprotect_object remove its
argument from the list.


** scm_eval_0str now returns the value of the last expression
evaluated.

** The new function scm_read_0str reads an s-expression from a
null-terminated string, and returns it.

** The new function `scm_stdio_to_port' converts a STDIO file pointer
to a Scheme port object.

** The new function `scm_set_program_arguments' allows C code to set
the value returned by the Scheme `program-arguments' function.


Older changes:

* Guile no longer includes sophisticated Tcl/Tk support.

The old Tcl/Tk support was unsatisfying to us, because it required the
user to link against the Tcl library, as well as Tk and Guile.  The
interface was also un-lispy, in that it preserved Tcl/Tk's practice of
referring to widgets by names, rather than exporting widgets to Scheme
code as a special datatype.

In the Usenix Tk Developer's Workshop held in July 1996, the Tcl/Tk
maintainers described some very interesting changes in progress to the
Tcl/Tk internals, which would facilitate clean interfaces between lone
Tk and other interpreters --- even for garbage-collected languages
like Scheme.  They expected the new Tk to be publicly available in the
fall of 1996.

Since it seems that Guile might soon have a new, cleaner interface to
lone Tk, and that the old Guile/Tk glue code would probably need to be
completely rewritten, we (Jim Blandy and Richard Stallman) have
decided not to support the old code.  We'll spend the time instead on
a good interface to the newer Tk, as soon as it is available.

Until then, gtcltk-lib provides trivial, low-maintenance functionality.


Copyright information:

Copyright (C) 1996,1997 Free Software Foundation, Inc.

   Permission is granted to anyone to make or distribute verbatim copies
   of this document as received, in any medium, provided that the
   copyright notice and this permission notice are preserved,
   thus giving the recipient permission to redistribute in turn.

   Permission is granted to distribute modified versions
   of this document, or of portions of it,
   under the above conditions, provided also that they
   carry prominent notices stating who last changed them.


Local variables:
mode: outline
paragraph-separate: "[ 	]*$"
end:

