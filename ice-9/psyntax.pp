(letrec ((lambda-var-list (lambda (vars203) (let lvl ((vars204 vars203) (ls (quote ())) (w205 (quote (())))) (cond ((pair? vars204) (lvl (cdr vars204) (cons (wrap (car vars204) w205) ls) w205)) ((id? vars204) (cons (wrap vars204 w205) ls)) ((null? vars204) ls) ((syntax-object? vars204) (lvl (syntax-object-expression vars204) ls (join-wraps w205 (syntax-object-wrap vars204)))) ((annotation? vars204) (lvl (annotation-expression vars204) ls w205)) (else (cons vars204 ls)))))) (gen-var (lambda (id206) (let ((id207 (if (syntax-object? id206) (syntax-object-expression id206) id206))) (if (annotation? id207) (gensym (annotation-expression id207) generated-symbols) (gensym id207 generated-symbols))))) (strip (lambda (x208 w209) (if (memq (quote top) (wrap-marks w209)) (if (or (annotation? x208) (and (pair? x208) (annotation? (car x208)))) (strip-annotation x208 (quote #f)) x208) (let f210 ((x211 x208)) (cond ((syntax-object? x211) (strip (syntax-object-expression x211) (syntax-object-wrap x211))) ((pair? x211) (let ((a (f210 (car x211))) (d (f210 (cdr x211)))) (if (and (eq? a (car x211)) (eq? d (cdr x211))) x211 (cons a d)))) ((vector? x211) (let ((old212 (vector->list x211))) (let ((new213 (map f210 old212))) (if (andmap eq? old212 new213) x211 (list->vector new213))))) (else x211)))))) (strip-annotation (lambda (x214 parent) (cond ((pair? x214) (let ((new215 (cons (quote #f) (quote #f)))) (begin (when parent (set-annotation-stripped! parent new215)) (set-car! new215 (strip-annotation (car x214) (quote #f))) (set-cdr! new215 (strip-annotation (cdr x214) (quote #f))) new215))) ((annotation? x214) (or (annotation-stripped x214) (strip-annotation (annotation-expression x214) x214))) ((vector? x214) (let ((new216 (make-vector (vector-length x214)))) (begin (when parent (set-annotation-stripped! parent new216)) (let loop ((i217 (- (vector-length x214) (quote 1)))) (unless (fx< i217 (quote 0)) (vector-set! new216 i217 (strip-annotation (vector-ref x214 i217) (quote #f))) (loop (fx- i217 (quote 1))))) new216))) (else x214)))) (ellipsis? (lambda (x218) (and (nonsymbol-id? x218) (free-id=? x218 (quote #(syntax-object ... ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))))))))) (chi-void (lambda () (list (quote void)))) (eval-local-transformer (lambda (expanded) (let ((p (local-eval-hook expanded))) (if (procedure? p) p (syntax-error p (quote "nonprocedure transfomer")))))) (chi-local-syntax (lambda (rec? e219 r w220 s k) ((lambda (tmp221) ((lambda (tmp222) (if tmp222 (apply (lambda (_223 id224 val e1 e2) (let ((ids225 id224)) (if (not (valid-bound-ids? ids225)) (syntax-error e219 (quote "duplicate bound keyword in")) (let ((labels (gen-labels ids225))) (let ((new-w (make-binding-wrap ids225 labels w220))) (k (cons e1 e2) (extend-env labels (let ((w228 (if rec? new-w w220)) (trans-r (macros-only-env r))) (map (lambda (x229) (cons (quote macro) (eval-local-transformer (chi x229 trans-r w228)))) val)) r) new-w s)))))) tmp222) ((lambda (_231) (syntax-error (source-wrap e219 w220 s))) tmp221))) (syntax-dispatch tmp221 (quote (any #(each (any any)) any . each-any))))) e219))) (chi-lambda-clause (lambda (e232 c r233 w234 k235) ((lambda (tmp236) ((lambda (tmp237) (if tmp237 (apply (lambda (id238 e1239 e2240) (let ((ids241 id238)) (if (not (valid-bound-ids? ids241)) (syntax-error e232 (quote "invalid parameter list in")) (let ((labels243 (gen-labels ids241)) (new-vars (map gen-var ids241))) (k235 new-vars (chi-body (cons e1239 e2240) e232 (extend-var-env labels243 new-vars r233) (make-binding-wrap ids241 labels243 w234))))))) tmp237) ((lambda (tmp245) (if tmp245 (apply (lambda (ids246 e1247 e2248) (let ((old-ids (lambda-var-list ids246))) (if (not (valid-bound-ids? old-ids)) (syntax-error e232 (quote "invalid parameter list in")) (let ((labels249 (gen-labels old-ids)) (new-vars250 (map gen-var old-ids))) (k235 (let f251 ((ls1 (cdr new-vars250)) (ls2 (car new-vars250))) (if (null? ls1) ls2 (f251 (cdr ls1) (cons (car ls1) ls2)))) (chi-body (cons e1247 e2248) e232 (extend-var-env labels249 new-vars250 r233) (make-binding-wrap old-ids labels249 w234))))))) tmp245) ((lambda (_253) (syntax-error e232)) tmp236))) (syntax-dispatch tmp236 (quote (any any . each-any)))))) (syntax-dispatch tmp236 (quote (each-any any . each-any))))) c))) (chi-body (lambda (body outer-form r254 w255) (let ((r256 (cons (quote ("placeholder" placeholder)) r254))) (let ((ribcage (make-ribcage (quote ()) (quote ()) (quote ())))) (let ((w257 (make-wrap (wrap-marks w255) (cons ribcage (wrap-subst w255))))) (let parse ((body258 (map (lambda (x262) (cons r256 (wrap x262 w257))) body)) (ids259 (quote ())) (labels260 (quote ())) (vars261 (quote ())) (vals (quote ())) (bindings (quote ()))) (if (null? body258) (syntax-error outer-form (quote "no expressions in body")) (let ((e263 (cdar body258)) (er (caar body258))) (call-with-values (lambda () (syntax-type e263 er (quote (())) (quote #f) ribcage)) (lambda (type264 value265 e266 w267 s268) (let ((t type264)) (if (memv t (quote (define-form))) (let ((id269 (wrap value265 w267)) (label (gen-label))) (let ((var270 (gen-var id269))) (begin (extend-ribcage! ribcage id269 label) (parse (cdr body258) (cons id269 ids259) (cons label labels260) (cons var270 vars261) (cons (cons er (wrap e266 w267)) vals) (cons (cons (quote lexical) var270) bindings))))) (if (memv t (quote (define-syntax-form))) (let ((id271 (wrap value265 w267)) (label272 (gen-label))) (begin (extend-ribcage! ribcage id271 label272) (parse (cdr body258) (cons id271 ids259) (cons label272 labels260) vars261 vals (cons (cons (quote macro) (cons er (wrap e266 w267))) bindings)))) (if (memv t (quote (begin-form))) ((lambda (tmp273) ((lambda (tmp274) (if tmp274 (apply (lambda (_275 e1276) (parse (let f277 ((forms e1276)) (if (null? forms) (cdr body258) (cons (cons er (wrap (car forms) w267)) (f277 (cdr forms))))) ids259 labels260 vars261 vals bindings)) tmp274) (syntax-error tmp273))) (syntax-dispatch tmp273 (quote (any . each-any))))) e266) (if (memv t (quote (local-syntax-form))) (chi-local-syntax value265 e266 er w267 s268 (lambda (forms279 er280 w281 s282) (parse (let f283 ((forms284 forms279)) (if (null? forms284) (cdr body258) (cons (cons er280 (wrap (car forms284) w281)) (f283 (cdr forms284))))) ids259 labels260 vars261 vals bindings))) (if (null? ids259) (build-sequence (quote #f) (map (lambda (x285) (chi (cdr x285) (car x285) (quote (())))) (cons (cons er (source-wrap e266 w267 s268)) (cdr body258)))) (begin (if (not (valid-bound-ids? ids259)) (syntax-error outer-form (quote "invalid or duplicate identifier in definition"))) (let loop286 ((bs bindings) (er-cache (quote #f)) (r-cache (quote #f))) (if (not (null? bs)) (let ((b (car bs))) (if (eq? (car b) (quote macro)) (let ((er287 (cadr b))) (let ((r-cache288 (if (eq? er287 er-cache) r-cache (macros-only-env er287)))) (begin (set-cdr! b (eval-local-transformer (chi (cddr b) r-cache288 (quote (()))))) (loop286 (cdr bs) er287 r-cache288)))) (loop286 (cdr bs) er-cache r-cache))))) (set-cdr! r256 (extend-env labels260 bindings (cdr r256))) (build-letrec (quote #f) vars261 (map (lambda (x289) (chi (cdr x289) (car x289) (quote (())))) vals) (build-sequence (quote #f) (map (lambda (x290) (chi (cdr x290) (car x290) (quote (())))) (cons (cons er (source-wrap e266 w267 s268)) (cdr body258)))))))))))))))))))))) (chi-macro (lambda (p291 e292 r293 w294 rib) (letrec ((rebuild-macro-output (lambda (x295 m) (cond ((pair? x295) (cons (rebuild-macro-output (car x295) m) (rebuild-macro-output (cdr x295) m))) ((syntax-object? x295) (let ((w296 (syntax-object-wrap x295))) (let ((ms (wrap-marks w296)) (s297 (wrap-subst w296))) (make-syntax-object (syntax-object-expression x295) (if (and (pair? ms) (eq? (car ms) (quote #f))) (make-wrap (cdr ms) (if rib (cons rib (cdr s297)) (cdr s297))) (make-wrap (cons m ms) (if rib (cons rib (cons (quote shift) s297)) (cons (quote shift) s297)))))))) ((vector? x295) (let ((n (vector-length x295))) (let ((v (make-vector n))) (let doloop ((i298 (quote 0))) (if (fx= i298 n) v (begin (vector-set! v i298 (rebuild-macro-output (vector-ref x295 i298) m)) (doloop (fx+ i298 (quote 1))))))))) ((symbol? x295) (syntax-error x295 (quote "encountered raw symbol in macro output"))) (else x295))))) (rebuild-macro-output (p291 (wrap e292 (anti-mark w294))) (string (quote #\m)))))) (chi-application (lambda (x299 e300 r301 w302 s303) ((lambda (tmp304) ((lambda (tmp305) (if tmp305 (apply (lambda (e0 e1306) (cons x299 (map (lambda (e307) (chi e307 r301 w302)) e1306))) tmp305) (syntax-error tmp304))) (syntax-dispatch tmp304 (quote (any . each-any))))) e300))) (chi-expr (lambda (type309 value310 e311 r312 w313 s314) (let ((t315 type309)) (if (memv t315 (quote (lexical))) value310 (if (memv t315 (quote (core))) (value310 e311 r312 w313 s314) (if (memv t315 (quote (lexical-call))) (chi-application value310 e311 r312 w313 s314) (if (memv t315 (quote (global-call))) (chi-application value310 e311 r312 w313 s314) (if (memv t315 (quote (constant))) (list (quote quote) (strip (source-wrap e311 w313 s314) (quote (())))) (if (memv t315 (quote (global))) value310 (if (memv t315 (quote (call))) (chi-application (chi (car e311) r312 w313) e311 r312 w313 s314) (if (memv t315 (quote (begin-form))) ((lambda (tmp316) ((lambda (tmp317) (if tmp317 (apply (lambda (_318 e1319 e2320) (chi-sequence (cons e1319 e2320) r312 w313 s314)) tmp317) (syntax-error tmp316))) (syntax-dispatch tmp316 (quote (any any . each-any))))) e311) (if (memv t315 (quote (local-syntax-form))) (chi-local-syntax value310 e311 r312 w313 s314 chi-sequence) (if (memv t315 (quote (eval-when-form))) ((lambda (tmp322) ((lambda (tmp323) (if tmp323 (apply (lambda (_324 x325 e1326 e2327) (let ((when-list (chi-when-list e311 x325 w313))) (if (memq (quote eval) when-list) (chi-sequence (cons e1326 e2327) r312 w313 s314) (chi-void)))) tmp323) (syntax-error tmp322))) (syntax-dispatch tmp322 (quote (any each-any any . each-any))))) e311) (if (memv t315 (quote (define-form define-syntax-form))) (syntax-error (wrap value310 w313) (quote "invalid context for definition of")) (if (memv t315 (quote (syntax))) (syntax-error (source-wrap e311 w313 s314) (quote "reference to pattern variable outside syntax form")) (if (memv t315 (quote (displaced-lexical))) (syntax-error (source-wrap e311 w313 s314) (quote "reference to identifier outside its scope")) (syntax-error (source-wrap e311 w313 s314)))))))))))))))))) (chi (lambda (e330 r331 w332) (call-with-values (lambda () (syntax-type e330 r331 w332 (quote #f) (quote #f))) (lambda (type333 value334 e335 w336 s337) (chi-expr type333 value334 e335 r331 w336 s337))))) (chi-top (lambda (e338 r339 w340 m341 esew) (call-with-values (lambda () (syntax-type e338 r339 w340 (quote #f) (quote #f))) (lambda (type348 value349 e350 w351 s352) (let ((t353 type348)) (if (memv t353 (quote (begin-form))) ((lambda (tmp354) ((lambda (tmp355) (if tmp355 (apply (lambda (_356) (chi-void)) tmp355) ((lambda (tmp357) (if tmp357 (apply (lambda (_358 e1359 e2360) (chi-top-sequence (cons e1359 e2360) r339 w351 s352 m341 esew)) tmp357) (syntax-error tmp354))) (syntax-dispatch tmp354 (quote (any any . each-any)))))) (syntax-dispatch tmp354 (quote (any))))) e350) (if (memv t353 (quote (local-syntax-form))) (chi-local-syntax value349 e350 r339 w351 s352 (lambda (body362 r363 w364 s365) (chi-top-sequence body362 r363 w364 s365 m341 esew))) (if (memv t353 (quote (eval-when-form))) ((lambda (tmp366) ((lambda (tmp367) (if tmp367 (apply (lambda (_368 x369 e1370 e2371) (let ((when-list372 (chi-when-list e350 x369 w351)) (body373 (cons e1370 e2371))) (cond ((eq? m341 (quote e)) (if (memq (quote eval) when-list372) (chi-top-sequence body373 r339 w351 s352 (quote e) (quote (eval))) (chi-void))) ((memq (quote load) when-list372) (if (or (memq (quote compile) when-list372) (and (eq? m341 (quote c&e)) (memq (quote eval) when-list372))) (chi-top-sequence body373 r339 w351 s352 (quote c&e) (quote (compile load))) (if (memq m341 (quote (c c&e))) (chi-top-sequence body373 r339 w351 s352 (quote c) (quote (load))) (chi-void)))) ((or (memq (quote compile) when-list372) (and (eq? m341 (quote c&e)) (memq (quote eval) when-list372))) (top-level-eval-hook (chi-top-sequence body373 r339 w351 s352 (quote e) (quote (eval)))) (chi-void)) (else (chi-void))))) tmp367) (syntax-error tmp366))) (syntax-dispatch tmp366 (quote (any each-any any . each-any))))) e350) (if (memv t353 (quote (define-syntax-form))) (let ((n376 (id-var-name value349 w351)) (r377 (macros-only-env r339))) (let ((t378 m341)) (if (memv t378 (quote (c))) (if (memq (quote compile) esew) (let ((e379 (chi-install-global n376 (chi e350 r377 w351)))) (begin (top-level-eval-hook e379) (if (memq (quote load) esew) e379 (chi-void)))) (if (memq (quote load) esew) (chi-install-global n376 (chi e350 r377 w351)) (chi-void))) (if (memv t378 (quote (c&e))) (let ((e380 (chi-install-global n376 (chi e350 r377 w351)))) (begin (top-level-eval-hook e380) e380)) (begin (if (memq (quote eval) esew) (top-level-eval-hook (chi-install-global n376 (chi e350 r377 w351)))) (chi-void)))))) (if (memv t353 (quote (define-form))) (let ((n381 (id-var-name value349 w351))) (let ((t382 (binding-type (lookup n381 r339)))) (if (memv t382 (quote (global))) (let ((x383 (list (quote define) n381 (chi e350 r339 w351)))) (begin (if (eq? m341 (quote c&e)) (top-level-eval-hook x383)) x383)) (if (memv t382 (quote (displaced-lexical))) (syntax-error (wrap value349 w351) (quote "identifier out of context")) (syntax-error (wrap value349 w351) (quote "cannot define keyword at top level")))))) (let ((x384 (chi-expr type348 value349 e350 r339 w351 s352))) (begin (if (eq? m341 (quote c&e)) (top-level-eval-hook x384)) x384)))))))))))) (syntax-type (lambda (e385 r386 w387 s388 rib389) (cond ((symbol? e385) (let ((n390 (id-var-name e385 w387))) (let ((b391 (lookup n390 r386))) (let ((type392 (binding-type b391))) (let ((t393 type392)) (if (memv t393 (quote (lexical))) (values type392 (binding-value b391) e385 w387 s388) (if (memv t393 (quote (global))) (values type392 n390 e385 w387 s388) (if (memv t393 (quote (macro))) (syntax-type (chi-macro (binding-value b391) e385 r386 w387 rib389) r386 (quote (())) s388 rib389) (values type392 (binding-value b391) e385 w387 s388))))))))) ((pair? e385) (let ((first (car e385))) (if (id? first) (let ((n394 (id-var-name first w387))) (let ((b395 (lookup n394 r386))) (let ((type396 (binding-type b395))) (let ((t397 type396)) (if (memv t397 (quote (lexical))) (values (quote lexical-call) (binding-value b395) e385 w387 s388) (if (memv t397 (quote (global))) (values (quote global-call) n394 e385 w387 s388) (if (memv t397 (quote (macro))) (syntax-type (chi-macro (binding-value b395) e385 r386 w387 rib389) r386 (quote (())) s388 rib389) (if (memv t397 (quote (core))) (values type396 (binding-value b395) e385 w387 s388) (if (memv t397 (quote (local-syntax))) (values (quote local-syntax-form) (binding-value b395) e385 w387 s388) (if (memv t397 (quote (begin))) (values (quote begin-form) (quote #f) e385 w387 s388) (if (memv t397 (quote (eval-when))) (values (quote eval-when-form) (quote #f) e385 w387 s388) (if (memv t397 (quote (define))) ((lambda (tmp398) ((lambda (tmp399) (if (if tmp399 (apply (lambda (_400 name401 val402) (id? name401)) tmp399) (quote #f)) (apply (lambda (_403 name404 val405) (values (quote define-form) name404 val405 w387 s388)) tmp399) ((lambda (tmp406) (if (if tmp406 (apply (lambda (_407 name408 args409 e1410 e2411) (and (id? name408) (valid-bound-ids? (lambda-var-list args409)))) tmp406) (quote #f)) (apply (lambda (_412 name413 args414 e1415 e2416) (values (quote define-form) (wrap name413 w387) (cons (quote #(syntax-object lambda ((top) #(ribcage #(_ name args e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))))) (wrap (cons args414 (cons e1415 e2416)) w387)) (quote (())) s388)) tmp406) ((lambda (tmp418) (if (if tmp418 (apply (lambda (_419 name420) (id? name420)) tmp418) (quote #f)) (apply (lambda (_421 name422) (values (quote define-form) (wrap name422 w387) (quote (#(syntax-object void ((top) #(ribcage #(_ name) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(t) #(("m" top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(type) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(b) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(n) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(first) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(e r w s rib) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i")))))) (quote (())) s388)) tmp418) (syntax-error tmp398))) (syntax-dispatch tmp398 (quote (any any)))))) (syntax-dispatch tmp398 (quote (any (any . any) any . each-any)))))) (syntax-dispatch tmp398 (quote (any any any))))) e385) (if (memv t397 (quote (define-syntax))) ((lambda (tmp423) ((lambda (tmp424) (if (if tmp424 (apply (lambda (_425 name426 val427) (id? name426)) tmp424) (quote #f)) (apply (lambda (_428 name429 val430) (values (quote define-syntax-form) name429 val430 w387 s388)) tmp424) (syntax-error tmp423))) (syntax-dispatch tmp423 (quote (any any any))))) e385) (values (quote call) (quote #f) e385 w387 s388)))))))))))))) (values (quote call) (quote #f) e385 w387 s388)))) ((syntax-object? e385) (syntax-type (syntax-object-expression e385) r386 (join-wraps w387 (syntax-object-wrap e385)) (quote #f) rib389)) ((annotation? e385) (syntax-type (annotation-expression e385) r386 w387 (annotation-source e385) rib389)) ((let ((x431 e385)) (or (boolean? x431) (number? x431) (string? x431) (char? x431) (null? x431) (keyword? x431))) (values (quote constant) (quote #f) e385 w387 s388)) (else (values (quote other) (quote #f) e385 w387 s388))))) (chi-when-list (lambda (e432 when-list433 w434) (let f435 ((when-list436 when-list433) (situations (quote ()))) (if (null? when-list436) situations (f435 (cdr when-list436) (cons (let ((x437 (car when-list436))) (cond ((free-id=? x437 (quote #(syntax-object compile ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i")))))) (quote compile)) ((free-id=? x437 (quote #(syntax-object load ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i")))))) (quote load)) ((free-id=? x437 (quote #(syntax-object eval ((top) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f when-list situations) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(e when-list w) #((top) (top) (top)) #("i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i")))))) (quote eval)) (else (syntax-error (wrap x437 w434) (quote "invalid eval-when situation"))))) situations)))))) (chi-install-global (lambda (name438 e439) (list (quote install-global-transformer) (list (quote quote) name438) e439))) (chi-top-sequence (lambda (body440 r441 w442 s443 m444 esew445) (build-sequence s443 (let dobody ((body446 body440) (r447 r441) (w448 w442) (m449 m444) (esew450 esew445)) (if (null? body446) (quote ()) (let ((first451 (chi-top (car body446) r447 w448 m449 esew450))) (cons first451 (dobody (cdr body446) r447 w448 m449 esew450)))))))) (chi-sequence (lambda (body452 r453 w454 s455) (build-sequence s455 (let dobody456 ((body457 body452) (r458 r453) (w459 w454)) (if (null? body457) (quote ()) (let ((first460 (chi (car body457) r458 w459))) (cons first460 (dobody456 (cdr body457) r458 w459)))))))) (source-wrap (lambda (x461 w462 s463) (wrap (if s463 (make-annotation x461 s463 (quote #f)) x461) w462))) (wrap (lambda (x464 w465) (cond ((and (null? (wrap-marks w465)) (null? (wrap-subst w465))) x464) ((syntax-object? x464) (make-syntax-object (syntax-object-expression x464) (join-wraps w465 (syntax-object-wrap x464)))) ((null? x464) x464) (else (make-syntax-object x464 w465))))) (bound-id-member? (lambda (x466 list) (and (not (null? list)) (or (bound-id=? x466 (car list)) (bound-id-member? x466 (cdr list)))))) (distinct-bound-ids? (lambda (ids467) (let distinct? ((ids468 ids467)) (or (null? ids468) (and (not (bound-id-member? (car ids468) (cdr ids468))) (distinct? (cdr ids468))))))) (valid-bound-ids? (lambda (ids469) (and (let all-ids? ((ids470 ids469)) (or (null? ids470) (and (id? (car ids470)) (all-ids? (cdr ids470))))) (distinct-bound-ids? ids469)))) (bound-id=? (lambda (i471 j) (if (and (syntax-object? i471) (syntax-object? j)) (and (eq? (let ((e472 (syntax-object-expression i471))) (if (annotation? e472) (annotation-expression e472) e472)) (let ((e473 (syntax-object-expression j))) (if (annotation? e473) (annotation-expression e473) e473))) (same-marks? (wrap-marks (syntax-object-wrap i471)) (wrap-marks (syntax-object-wrap j)))) (eq? (let ((e474 i471)) (if (annotation? e474) (annotation-expression e474) e474)) (let ((e475 j)) (if (annotation? e475) (annotation-expression e475) e475)))))) (free-id=? (lambda (i476 j477) (and (eq? (let ((x478 i476)) (let ((e479 (if (syntax-object? x478) (syntax-object-expression x478) x478))) (if (annotation? e479) (annotation-expression e479) e479))) (let ((x480 j477)) (let ((e481 (if (syntax-object? x480) (syntax-object-expression x480) x480))) (if (annotation? e481) (annotation-expression e481) e481)))) (eq? (id-var-name i476 (quote (()))) (id-var-name j477 (quote (()))))))) (id-var-name (lambda (id482 w483) (letrec ((search-vector-rib (lambda (sym subst marks489 symnames ribcage490) (let ((n491 (vector-length symnames))) (let f492 ((i493 (quote 0))) (cond ((fx= i493 n491) (search sym (cdr subst) marks489)) ((and (eq? (vector-ref symnames i493) sym) (same-marks? marks489 (vector-ref (ribcage-marks ribcage490) i493))) (values (vector-ref (ribcage-labels ribcage490) i493) marks489)) (else (f492 (fx+ i493 (quote 1))))))))) (search-list-rib (lambda (sym494 subst495 marks496 symnames497 ribcage498) (let f499 ((symnames500 symnames497) (i501 (quote 0))) (cond ((null? symnames500) (search sym494 (cdr subst495) marks496)) ((and (eq? (car symnames500) sym494) (same-marks? marks496 (list-ref (ribcage-marks ribcage498) i501))) (values (list-ref (ribcage-labels ribcage498) i501) marks496)) (else (f499 (cdr symnames500) (fx+ i501 (quote 1)))))))) (search (lambda (sym502 subst503 marks504) (if (null? subst503) (values (quote #f) marks504) (let ((fst (car subst503))) (if (eq? fst (quote shift)) (search sym502 (cdr subst503) (cdr marks504)) (let ((symnames505 (ribcage-symnames fst))) (if (vector? symnames505) (search-vector-rib sym502 subst503 marks504 symnames505 fst) (search-list-rib sym502 subst503 marks504 symnames505 fst))))))))) (cond ((symbol? id482) (or (call-with-values (lambda () (search id482 (wrap-subst w483) (wrap-marks w483))) (lambda (x506 . ignore) x506)) id482)) ((syntax-object? id482) (let ((id507 (let ((e508 (syntax-object-expression id482))) (if (annotation? e508) (annotation-expression e508) e508))) (w1 (syntax-object-wrap id482))) (let ((marks509 (join-marks (wrap-marks w483) (wrap-marks w1)))) (call-with-values (lambda () (search id507 (wrap-subst w483) marks509)) (lambda (new-id marks510) (or new-id (call-with-values (lambda () (search id507 (wrap-subst w1) marks510)) (lambda (x512 . ignore511) x512)) id507)))))) ((annotation? id482) (let ((id513 (let ((e514 id482)) (if (annotation? e514) (annotation-expression e514) e514)))) (or (call-with-values (lambda () (search id513 (wrap-subst w483) (wrap-marks w483))) (lambda (x516 . ignore515) x516)) id513))) (else (error-hook (quote id-var-name) (quote "invalid id") id482)))))) (same-marks? (lambda (x517 y) (or (eq? x517 y) (and (not (null? x517)) (not (null? y)) (eq? (car x517) (car y)) (same-marks? (cdr x517) (cdr y)))))) (join-marks (lambda (m1 m2) (smart-append m1 m2))) (join-wraps (lambda (w1518 w2) (let ((m1519 (wrap-marks w1518)) (s1 (wrap-subst w1518))) (if (null? m1519) (if (null? s1) w2 (make-wrap (wrap-marks w2) (smart-append s1 (wrap-subst w2)))) (make-wrap (smart-append m1519 (wrap-marks w2)) (smart-append s1 (wrap-subst w2))))))) (smart-append (lambda (m1520 m2521) (if (null? m2521) m1520 (append m1520 m2521)))) (make-binding-wrap (lambda (ids522 labels523 w524) (if (null? ids522) w524 (make-wrap (wrap-marks w524) (cons (let ((labelvec (list->vector labels523))) (let ((n525 (vector-length labelvec))) (let ((symnamevec (make-vector n525)) (marksvec (make-vector n525))) (begin (let f526 ((ids527 ids522) (i528 (quote 0))) (if (not (null? ids527)) (call-with-values (lambda () (id-sym-name&marks (car ids527) w524)) (lambda (symname marks529) (begin (vector-set! symnamevec i528 symname) (vector-set! marksvec i528 marks529) (f526 (cdr ids527) (fx+ i528 (quote 1)))))))) (make-ribcage symnamevec marksvec labelvec))))) (wrap-subst w524)))))) (extend-ribcage! (lambda (ribcage530 id531 label532) (begin (set-ribcage-symnames! ribcage530 (cons (let ((e533 (syntax-object-expression id531))) (if (annotation? e533) (annotation-expression e533) e533)) (ribcage-symnames ribcage530))) (set-ribcage-marks! ribcage530 (cons (wrap-marks (syntax-object-wrap id531)) (ribcage-marks ribcage530))) (set-ribcage-labels! ribcage530 (cons label532 (ribcage-labels ribcage530)))))) (anti-mark (lambda (w534) (make-wrap (cons (quote #f) (wrap-marks w534)) (cons (quote shift) (wrap-subst w534))))) (set-ribcage-labels! (lambda (x535 update) (vector-set! x535 (quote 3) update))) (set-ribcage-marks! (lambda (x536 update537) (vector-set! x536 (quote 2) update537))) (set-ribcage-symnames! (lambda (x538 update539) (vector-set! x538 (quote 1) update539))) (ribcage-labels (lambda (x540) (vector-ref x540 (quote 3)))) (ribcage-marks (lambda (x541) (vector-ref x541 (quote 2)))) (ribcage-symnames (lambda (x542) (vector-ref x542 (quote 1)))) (ribcage? (lambda (x543) (and (vector? x543) (= (vector-length x543) (quote 4)) (eq? (vector-ref x543 (quote 0)) (quote ribcage))))) (make-ribcage (lambda (symnames544 marks545 labels546) (vector (quote ribcage) symnames544 marks545 labels546))) (gen-labels (lambda (ls547) (if (null? ls547) (quote ()) (cons (gen-label) (gen-labels (cdr ls547)))))) (gen-label (lambda () (string (quote #\i)))) (wrap-subst cdr) (wrap-marks car) (make-wrap cons) (id-sym-name&marks (lambda (x548 w549) (if (syntax-object? x548) (values (let ((e550 (syntax-object-expression x548))) (if (annotation? e550) (annotation-expression e550) e550)) (join-marks (wrap-marks w549) (wrap-marks (syntax-object-wrap x548)))) (values (let ((e551 x548)) (if (annotation? e551) (annotation-expression e551) e551)) (wrap-marks w549))))) (id? (lambda (x552) (cond ((symbol? x552) (quote #t)) ((syntax-object? x552) (symbol? (let ((e553 (syntax-object-expression x552))) (if (annotation? e553) (annotation-expression e553) e553)))) ((annotation? x552) (symbol? (annotation-expression x552))) (else (quote #f))))) (nonsymbol-id? (lambda (x554) (and (syntax-object? x554) (symbol? (let ((e555 (syntax-object-expression x554))) (if (annotation? e555) (annotation-expression e555) e555)))))) (global-extend (lambda (type556 sym557 val558) (put-global-definition-hook sym557 (cons type556 val558)))) (lookup (lambda (x559 r560) (cond ((assq x559 r560) => cdr) ((symbol? x559) (or (get-global-definition-hook x559) (quote (global)))) (else (quote (displaced-lexical)))))) (macros-only-env (lambda (r561) (if (null? r561) (quote ()) (let ((a562 (car r561))) (if (eq? (cadr a562) (quote macro)) (cons a562 (macros-only-env (cdr r561))) (macros-only-env (cdr r561))))))) (extend-var-env (lambda (labels563 vars564 r565) (if (null? labels563) r565 (extend-var-env (cdr labels563) (cdr vars564) (cons (cons (car labels563) (cons (quote lexical) (car vars564))) r565))))) (extend-env (lambda (labels566 bindings567 r568) (if (null? labels566) r568 (extend-env (cdr labels566) (cdr bindings567) (cons (cons (car labels566) (car bindings567)) r568))))) (binding-value cdr) (binding-type car) (source-annotation (lambda (x569) (cond ((annotation? x569) (annotation-source x569)) ((syntax-object? x569) (source-annotation (syntax-object-expression x569))) (else (quote #f))))) (set-syntax-object-wrap! (lambda (x570 update571) (vector-set! x570 (quote 2) update571))) (set-syntax-object-expression! (lambda (x572 update573) (vector-set! x572 (quote 1) update573))) (syntax-object-wrap (lambda (x574) (vector-ref x574 (quote 2)))) (syntax-object-expression (lambda (x575) (vector-ref x575 (quote 1)))) (syntax-object? (lambda (x576) (and (vector? x576) (= (vector-length x576) (quote 3)) (eq? (vector-ref x576 (quote 0)) (quote syntax-object))))) (make-syntax-object (lambda (expression wrap577) (vector (quote syntax-object) expression wrap577))) (build-letrec (lambda (src578 vars579 val-exps body-exp) (if (null? vars579) body-exp (list (quote letrec) (map list vars579 val-exps) body-exp)))) (build-named-let (lambda (src580 vars581 val-exps582 body-exp583) (if (null? vars581) body-exp583 (list (quote let) (car vars581) (map list (cdr vars581) val-exps582) body-exp583)))) (build-let (lambda (src584 vars585 val-exps586 body-exp587) (if (null? vars585) body-exp587 (list (quote let) (map list vars585 val-exps586) body-exp587)))) (build-sequence (lambda (src588 exps) (if (null? (cdr exps)) (car exps) (cons (quote begin) exps)))) (get-global-definition-hook (lambda (symbol) (getprop symbol (quote *sc-expander*)))) (put-global-definition-hook (lambda (symbol589 binding) (putprop symbol589 (quote *sc-expander*) binding))) (error-hook (lambda (who590 why what) (error who590 (quote "~a ~s") why what))) (local-eval-hook (lambda (x591) (eval (list noexpand x591) (interaction-environment)))) (top-level-eval-hook (lambda (x592) (eval (list noexpand x592) (interaction-environment)))) (annotation? (lambda (x593) (quote #f))) (fx< <) (fx= =) (fx- -) (fx+ +) (noexpand (quote "noexpand"))) (begin (global-extend (quote local-syntax) (quote letrec-syntax) (quote #t)) (global-extend (quote local-syntax) (quote let-syntax) (quote #f)) (global-extend (quote core) (quote fluid-let-syntax) (lambda (e594 r595 w596 s597) ((lambda (tmp598) ((lambda (tmp599) (if (if tmp599 (apply (lambda (_600 var601 val602 e1603 e2604) (valid-bound-ids? var601)) tmp599) (quote #f)) (apply (lambda (_606 var607 val608 e1609 e2610) (let ((names (map (lambda (x611) (id-var-name x611 w596)) var607))) (begin (for-each (lambda (id613 n614) (let ((t615 (binding-type (lookup n614 r595)))) (if (memv t615 (quote (displaced-lexical))) (syntax-error (source-wrap id613 w596 s597) (quote "identifier out of context"))))) var607 names) (chi-body (cons e1609 e2610) (source-wrap e594 w596 s597) (extend-env names (let ((trans-r618 (macros-only-env r595))) (map (lambda (x619) (cons (quote macro) (eval-local-transformer (chi x619 trans-r618 w596)))) val608)) r595) w596)))) tmp599) ((lambda (_621) (syntax-error (source-wrap e594 w596 s597))) tmp598))) (syntax-dispatch tmp598 (quote (any #(each (any any)) any . each-any))))) e594))) (global-extend (quote core) (quote quote) (lambda (e622 r623 w624 s625) ((lambda (tmp626) ((lambda (tmp627) (if tmp627 (apply (lambda (_628 e629) (list (quote quote) (strip e629 w624))) tmp627) ((lambda (_630) (syntax-error (source-wrap e622 w624 s625))) tmp626))) (syntax-dispatch tmp626 (quote (any any))))) e622))) (global-extend (quote core) (quote syntax) (letrec ((regen (lambda (x631) (let ((t632 (car x631))) (if (memv t632 (quote (ref))) (cadr x631) (if (memv t632 (quote (primitive))) (cadr x631) (if (memv t632 (quote (quote))) (list (quote quote) (cadr x631)) (if (memv t632 (quote (lambda))) (list (quote lambda) (cadr x631) (regen (caddr x631))) (if (memv t632 (quote (map))) (let ((ls633 (map regen (cdr x631)))) (cons (if (fx= (length ls633) (quote 2)) (quote map) (quote map)) ls633)) (cons (car x631) (map regen (cdr x631))))))))))) (gen-vector (lambda (x634) (cond ((eq? (car x634) (quote list)) (cons (quote vector) (cdr x634))) ((eq? (car x634) (quote quote)) (list (quote quote) (list->vector (cadr x634)))) (else (list (quote list->vector) x634))))) (gen-append (lambda (x635 y636) (if (equal? y636 (quote (quote ()))) x635 (list (quote append) x635 y636)))) (gen-cons (lambda (x637 y638) (let ((t639 (car y638))) (if (memv t639 (quote (quote))) (if (eq? (car x637) (quote quote)) (list (quote quote) (cons (cadr x637) (cadr y638))) (if (eq? (cadr y638) (quote ())) (list (quote list) x637) (list (quote cons) x637 y638))) (if (memv t639 (quote (list))) (cons (quote list) (cons x637 (cdr y638))) (list (quote cons) x637 y638)))))) (gen-map (lambda (e640 map-env) (let ((formals (map cdr map-env)) (actuals (map (lambda (x641) (list (quote ref) (car x641))) map-env))) (cond ((eq? (car e640) (quote ref)) (car actuals)) ((andmap (lambda (x642) (and (eq? (car x642) (quote ref)) (memq (cadr x642) formals))) (cdr e640)) (cons (quote map) (cons (list (quote primitive) (car e640)) (map (let ((r643 (map cons formals actuals))) (lambda (x644) (cdr (assq (cadr x644) r643)))) (cdr e640))))) (else (cons (quote map) (cons (list (quote lambda) formals e640) actuals))))))) (gen-mappend (lambda (e645 map-env646) (list (quote apply) (quote (primitive append)) (gen-map e645 map-env646)))) (gen-ref (lambda (src647 var648 level649 maps) (if (fx= level649 (quote 0)) (values var648 maps) (if (null? maps) (syntax-error src647 (quote "missing ellipsis in syntax form")) (call-with-values (lambda () (gen-ref src647 var648 (fx- level649 (quote 1)) (cdr maps))) (lambda (outer-var outer-maps) (let ((b650 (assq outer-var (car maps)))) (if b650 (values (cdr b650) maps) (let ((inner-var (gen-var (quote tmp)))) (values inner-var (cons (cons (cons outer-var inner-var) (car maps)) outer-maps))))))))))) (gen-syntax (lambda (src651 e652 r653 maps654 ellipsis?655) (if (id? e652) (let ((label656 (id-var-name e652 (quote (()))))) (let ((b657 (lookup label656 r653))) (if (eq? (binding-type b657) (quote syntax)) (call-with-values (lambda () (let ((var.lev (binding-value b657))) (gen-ref src651 (car var.lev) (cdr var.lev) maps654))) (lambda (var658 maps659) (values (list (quote ref) var658) maps659))) (if (ellipsis?655 e652) (syntax-error src651 (quote "misplaced ellipsis in syntax form")) (values (list (quote quote) e652) maps654))))) ((lambda (tmp660) ((lambda (tmp661) (if (if tmp661 (apply (lambda (dots e662) (ellipsis?655 dots)) tmp661) (quote #f)) (apply (lambda (dots663 e664) (gen-syntax src651 e664 r653 maps654 (lambda (x665) (quote #f)))) tmp661) ((lambda (tmp666) (if (if tmp666 (apply (lambda (x667 dots668 y669) (ellipsis?655 dots668)) tmp666) (quote #f)) (apply (lambda (x670 dots671 y672) (let f673 ((y674 y672) (k675 (lambda (maps676) (call-with-values (lambda () (gen-syntax src651 x670 r653 (cons (quote ()) maps676) ellipsis?655)) (lambda (x677 maps678) (if (null? (car maps678)) (syntax-error src651 (quote "extra ellipsis in syntax form")) (values (gen-map x677 (car maps678)) (cdr maps678)))))))) ((lambda (tmp679) ((lambda (tmp680) (if (if tmp680 (apply (lambda (dots681 y682) (ellipsis?655 dots681)) tmp680) (quote #f)) (apply (lambda (dots683 y684) (f673 y684 (lambda (maps685) (call-with-values (lambda () (k675 (cons (quote ()) maps685))) (lambda (x686 maps687) (if (null? (car maps687)) (syntax-error src651 (quote "extra ellipsis in syntax form")) (values (gen-mappend x686 (car maps687)) (cdr maps687)))))))) tmp680) ((lambda (_688) (call-with-values (lambda () (gen-syntax src651 y674 r653 maps654 ellipsis?655)) (lambda (y689 maps690) (call-with-values (lambda () (k675 maps690)) (lambda (x691 maps692) (values (gen-append x691 y689) maps692)))))) tmp679))) (syntax-dispatch tmp679 (quote (any . any))))) y674))) tmp666) ((lambda (tmp693) (if tmp693 (apply (lambda (x694 y695) (call-with-values (lambda () (gen-syntax src651 x694 r653 maps654 ellipsis?655)) (lambda (x696 maps697) (call-with-values (lambda () (gen-syntax src651 y695 r653 maps697 ellipsis?655)) (lambda (y698 maps699) (values (gen-cons x696 y698) maps699)))))) tmp693) ((lambda (tmp700) (if tmp700 (apply (lambda (e1701 e2702) (call-with-values (lambda () (gen-syntax src651 (cons e1701 e2702) r653 maps654 ellipsis?655)) (lambda (e704 maps705) (values (gen-vector e704) maps705)))) tmp700) ((lambda (_706) (values (list (quote quote) e652) maps654)) tmp660))) (syntax-dispatch tmp660 (quote #(vector (any . each-any))))))) (syntax-dispatch tmp660 (quote (any . any)))))) (syntax-dispatch tmp660 (quote (any any . any)))))) (syntax-dispatch tmp660 (quote (any any))))) e652))))) (lambda (e707 r708 w709 s710) (let ((e711 (source-wrap e707 w709 s710))) ((lambda (tmp712) ((lambda (tmp713) (if tmp713 (apply (lambda (_714 x715) (call-with-values (lambda () (gen-syntax e711 x715 r708 (quote ()) ellipsis?)) (lambda (e716 maps717) (regen e716)))) tmp713) ((lambda (_718) (syntax-error e711)) tmp712))) (syntax-dispatch tmp712 (quote (any any))))) e711))))) (global-extend (quote core) (quote lambda) (lambda (e719 r720 w721 s722) ((lambda (tmp723) ((lambda (tmp724) (if tmp724 (apply (lambda (_725 c726) (chi-lambda-clause (source-wrap e719 w721 s722) c726 r720 w721 (lambda (vars727 body728) (list (quote lambda) vars727 body728)))) tmp724) (syntax-error tmp723))) (syntax-dispatch tmp723 (quote (any . any))))) e719))) (global-extend (quote core) (quote let) (letrec ((chi-let (lambda (e729 r730 w731 s732 constructor733 ids734 vals735 exps736) (if (not (valid-bound-ids? ids734)) (syntax-error e729 (quote "duplicate bound variable in")) (let ((labels737 (gen-labels ids734)) (new-vars738 (map gen-var ids734))) (let ((nw (make-binding-wrap ids734 labels737 w731)) (nr (extend-var-env labels737 new-vars738 r730))) (constructor733 s732 new-vars738 (map (lambda (x739) (chi x739 r730 w731)) vals735) (chi-body exps736 (source-wrap e729 nw s732) nr nw)))))))) (lambda (e740 r741 w742 s743) ((lambda (tmp744) ((lambda (tmp745) (if tmp745 (apply (lambda (_746 id747 val748 e1749 e2750) (chi-let e740 r741 w742 s743 build-let id747 val748 (cons e1749 e2750))) tmp745) ((lambda (tmp754) (if (if tmp754 (apply (lambda (_755 f756 id757 val758 e1759 e2760) (id? f756)) tmp754) (quote #f)) (apply (lambda (_761 f762 id763 val764 e1765 e2766) (chi-let e740 r741 w742 s743 build-named-let (cons f762 id763) val764 (cons e1765 e2766))) tmp754) ((lambda (_770) (syntax-error (source-wrap e740 w742 s743))) tmp744))) (syntax-dispatch tmp744 (quote (any any #(each (any any)) any . each-any)))))) (syntax-dispatch tmp744 (quote (any #(each (any any)) any . each-any))))) e740)))) (global-extend (quote core) (quote letrec) (lambda (e771 r772 w773 s774) ((lambda (tmp775) ((lambda (tmp776) (if tmp776 (apply (lambda (_777 id778 val779 e1780 e2781) (let ((ids782 id778)) (if (not (valid-bound-ids? ids782)) (syntax-error e771 (quote "duplicate bound variable in")) (let ((labels784 (gen-labels ids782)) (new-vars785 (map gen-var ids782))) (let ((w786 (make-binding-wrap ids782 labels784 w773)) (r787 (extend-var-env labels784 new-vars785 r772))) (build-letrec s774 new-vars785 (map (lambda (x788) (chi x788 r787 w786)) val779) (chi-body (cons e1780 e2781) (source-wrap e771 w786 s774) r787 w786))))))) tmp776) ((lambda (_791) (syntax-error (source-wrap e771 w773 s774))) tmp775))) (syntax-dispatch tmp775 (quote (any #(each (any any)) any . each-any))))) e771))) (global-extend (quote core) (quote set!) (lambda (e792 r793 w794 s795) ((lambda (tmp796) ((lambda (tmp797) (if (if tmp797 (apply (lambda (_798 id799 val800) (id? id799)) tmp797) (quote #f)) (apply (lambda (_801 id802 val803) (let ((val804 (chi val803 r793 w794)) (n805 (id-var-name id802 w794))) (let ((b806 (lookup n805 r793))) (let ((t807 (binding-type b806))) (if (memv t807 (quote (lexical))) (list (quote set!) (binding-value b806) val804) (if (memv t807 (quote (global))) (list (quote set!) n805 val804) (if (memv t807 (quote (displaced-lexical))) (syntax-error (wrap id802 w794) (quote "identifier out of context")) (syntax-error (source-wrap e792 w794 s795))))))))) tmp797) ((lambda (tmp808) (if tmp808 (apply (lambda (_809 getter arg val810) (cons (chi (list (quote #(syntax-object setter ((top) #(ribcage #(_ getter arg val) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(e r w s) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))))) getter) r793 w794) (map (lambda (e811) (chi e811 r793 w794)) (append arg (list val810))))) tmp808) ((lambda (_813) (syntax-error (source-wrap e792 w794 s795))) tmp796))) (syntax-dispatch tmp796 (quote (any (any . each-any) any)))))) (syntax-dispatch tmp796 (quote (any any any))))) e792))) (global-extend (quote begin) (quote begin) (quote ())) (global-extend (quote define) (quote define) (quote ())) (global-extend (quote define-syntax) (quote define-syntax) (quote ())) (global-extend (quote eval-when) (quote eval-when) (quote ())) (global-extend (quote core) (quote syntax-case) (letrec ((gen-syntax-case (lambda (x814 keys clauses r815) (if (null? clauses) (list (quote syntax-error) x814) ((lambda (tmp816) ((lambda (tmp817) (if tmp817 (apply (lambda (pat exp818) (if (and (id? pat) (andmap (lambda (x819) (not (free-id=? pat x819))) (cons (quote #(syntax-object ... ((top) #(ribcage #(pat exp) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x keys clauses r) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage (gen-syntax-case gen-clause build-dispatch-call convert-pattern) ((top) (top) (top) (top)) ("i" "i" "i" "i")) #(ribcage (lambda-var-list gen-var strip strip-annotation ellipsis? chi-void eval-local-transformer chi-local-syntax chi-lambda-clause chi-body chi-macro chi-application chi-expr chi chi-top syntax-type chi-when-list chi-install-global chi-top-sequence chi-sequence source-wrap wrap bound-id-member? distinct-bound-ids? valid-bound-ids? bound-id=? free-id=? id-var-name same-marks? join-marks join-wraps smart-append make-binding-wrap extend-ribcage! make-empty-ribcage new-mark anti-mark the-anti-mark top-marked? top-wrap empty-wrap set-ribcage-labels! set-ribcage-marks! set-ribcage-symnames! ribcage-labels ribcage-marks ribcage-symnames ribcage? make-ribcage gen-labels gen-label make-rename rename-marks rename-new rename-old subst-rename? wrap-subst wrap-marks make-wrap id-sym-name&marks id-sym-name id? nonsymbol-id? global-extend lookup macros-only-env extend-var-env extend-env null-env binding-value binding-type make-binding arg-check source-annotation no-source unannotate set-syntax-object-wrap! set-syntax-object-expression! syntax-object-wrap syntax-object-expression syntax-object? make-syntax-object self-evaluating? build-lexical-var build-letrec build-named-let build-let build-sequence build-data build-primref build-lambda build-global-definition build-global-assignment build-global-reference build-lexical-assignment build-lexical-reference build-conditional build-application get-global-definition-hook put-global-definition-hook gensym-hook error-hook local-eval-hook top-level-eval-hook annotation? fx< fx= fx- fx+ noexpand) ((top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top) (top)) ("i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i" "i")) #(ribcage (define-structure) ((top)) ("i"))))) keys))) (let ((labels820 (list (gen-label))) (var821 (gen-var pat))) (list (list (quote lambda) (list var821) (chi exp818 (extend-env labels820 (list (cons (quote syntax) (cons var821 (quote 0)))) r815) (make-binding-wrap (list pat) labels820 (quote (()))))) x814)) (gen-clause x814 keys (cdr clauses) r815 pat (quote #t) exp818))) tmp817) ((lambda (tmp822) (if tmp822 (apply (lambda (pat823 fender exp824) (gen-clause x814 keys (cdr clauses) r815 pat823 fender exp824)) tmp822) ((lambda (_825) (syntax-error (car clauses) (quote "invalid syntax-case clause"))) tmp816))) (syntax-dispatch tmp816 (quote (any any any)))))) (syntax-dispatch tmp816 (quote (any any))))) (car clauses))))) (gen-clause (lambda (x826 keys827 clauses828 r829 pat830 fender831 exp832) (call-with-values (lambda () (convert-pattern pat830 keys827)) (lambda (p833 pvars) (cond ((not (distinct-bound-ids? (map car pvars))) (syntax-error pat830 (quote "duplicate pattern variable in syntax-case pattern"))) ((not (andmap (lambda (x834) (not (ellipsis? (car x834)))) pvars)) (syntax-error pat830 (quote "misplaced ellipsis in syntax-case pattern"))) (else (let ((y835 (gen-var (quote tmp)))) (list (list (quote lambda) (list y835) (let ((y836 y835)) (list (quote if) ((lambda (tmp837) ((lambda (tmp838) (if tmp838 (apply (lambda () y836) tmp838) ((lambda (_839) (list (quote if) y836 (build-dispatch-call pvars fender831 y836 r829) (list (quote quote) (quote #f)))) tmp837))) (syntax-dispatch tmp837 (quote #(atom #t))))) fender831) (build-dispatch-call pvars exp832 y836 r829) (gen-syntax-case x826 keys827 clauses828 r829)))) (if (eq? p833 (quote any)) (list (quote list) x826) (list (quote syntax-dispatch) x826 (list (quote quote) p833))))))))))) (build-dispatch-call (lambda (pvars840 exp841 y842 r843) (let ((ids844 (map car pvars840)) (levels (map cdr pvars840))) (let ((labels845 (gen-labels ids844)) (new-vars846 (map gen-var ids844))) (list (quote apply) (list (quote lambda) new-vars846 (chi exp841 (extend-env labels845 (map (lambda (var847 level848) (cons (quote syntax) (cons var847 level848))) new-vars846 (map cdr pvars840)) r843) (make-binding-wrap ids844 labels845 (quote (()))))) y842))))) (convert-pattern (lambda (pattern keys849) (let cvt ((p850 pattern) (n851 (quote 0)) (ids852 (quote ()))) (if (id? p850) (if (bound-id-member? p850 keys849) (values (vector (quote free-id) p850) ids852) (values (quote any) (cons (cons p850 n851) ids852))) ((lambda (tmp853) ((lambda (tmp854) (if (if tmp854 (apply (lambda (x855 dots856) (ellipsis? dots856)) tmp854) (quote #f)) (apply (lambda (x857 dots858) (call-with-values (lambda () (cvt x857 (fx+ n851 (quote 1)) ids852)) (lambda (p859 ids860) (values (if (eq? p859 (quote any)) (quote each-any) (vector (quote each) p859)) ids860)))) tmp854) ((lambda (tmp861) (if tmp861 (apply (lambda (x862 y863) (call-with-values (lambda () (cvt y863 n851 ids852)) (lambda (y864 ids865) (call-with-values (lambda () (cvt x862 n851 ids865)) (lambda (x866 ids867) (values (cons x866 y864) ids867)))))) tmp861) ((lambda (tmp868) (if tmp868 (apply (lambda () (values (quote ()) ids852)) tmp868) ((lambda (tmp869) (if tmp869 (apply (lambda (x870) (call-with-values (lambda () (cvt x870 n851 ids852)) (lambda (p872 ids873) (values (vector (quote vector) p872) ids873)))) tmp869) ((lambda (x874) (values (vector (quote atom) (strip p850 (quote (())))) ids852)) tmp853))) (syntax-dispatch tmp853 (quote #(vector each-any)))))) (syntax-dispatch tmp853 (quote ()))))) (syntax-dispatch tmp853 (quote (any . any)))))) (syntax-dispatch tmp853 (quote (any any))))) p850)))))) (lambda (e875 r876 w877 s878) (let ((e879 (source-wrap e875 w877 s878))) ((lambda (tmp880) ((lambda (tmp881) (if tmp881 (apply (lambda (_882 val883 key m884) (if (andmap (lambda (x885) (and (id? x885) (not (ellipsis? x885)))) key) (let ((x887 (gen-var (quote tmp)))) (list (list (quote lambda) (list x887) (gen-syntax-case x887 key m884 r876)) (chi val883 r876 (quote (()))))) (syntax-error e879 (quote "invalid literals list in")))) tmp881) (syntax-error tmp880))) (syntax-dispatch tmp880 (quote (any any each-any . each-any))))) e879))))) (set! sc-expand (let ((m890 (quote e)) (esew891 (quote (eval)))) (lambda (x892) (if (and (pair? x892) (equal? (car x892) noexpand)) (cadr x892) (chi-top x892 (quote ()) (quote ((top))) m890 esew891))))) (set! sc-expand3 (let ((m893 (quote e)) (esew894 (quote (eval)))) (lambda (x895 . rest) (if (and (pair? x895) (equal? (car x895) noexpand)) (cadr x895) (chi-top x895 (quote ()) (quote ((top))) (if (null? rest) m893 (car rest)) (if (or (null? rest) (null? (cdr rest))) esew894 (cadr rest))))))) (set! identifier? (lambda (x896) (nonsymbol-id? x896))) (set! datum->syntax-object (lambda (id897 datum) (begin (let ((x898 id897)) (if (not (nonsymbol-id? x898)) (error-hook (quote datum->syntax-object) (quote "invalid argument") x898))) (make-syntax-object datum (syntax-object-wrap id897))))) (set! syntax-object->datum (lambda (x899) (strip x899 (quote (()))))) (set! generate-temporaries (lambda (ls900) (begin (let ((x901 ls900)) (if (not (list? x901)) (error-hook (quote generate-temporaries) (quote "invalid argument") x901))) (map (lambda (x902) (wrap (gensym) (quote ((top))))) ls900)))) (set! free-identifier=? (lambda (x903 y904) (begin (let ((x905 x903)) (if (not (nonsymbol-id? x905)) (error-hook (quote free-identifier=?) (quote "invalid argument") x905))) (let ((x906 y904)) (if (not (nonsymbol-id? x906)) (error-hook (quote free-identifier=?) (quote "invalid argument") x906))) (free-id=? x903 y904)))) (set! bound-identifier=? (lambda (x907 y908) (begin (let ((x909 x907)) (if (not (nonsymbol-id? x909)) (error-hook (quote bound-identifier=?) (quote "invalid argument") x909))) (let ((x910 y908)) (if (not (nonsymbol-id? x910)) (error-hook (quote bound-identifier=?) (quote "invalid argument") x910))) (bound-id=? x907 y908)))) (set! syntax-error (lambda (object . messages) (begin (for-each (lambda (x911) (let ((x912 x911)) (if (not (string? x912)) (error-hook (quote syntax-error) (quote "invalid argument") x912)))) messages) (let ((message (if (null? messages) (quote "invalid syntax") (apply string-append messages)))) (error-hook (quote #f) message (strip object (quote (())))))))) (set! install-global-transformer (lambda (sym913 v914) (begin (let ((x915 sym913)) (if (not (symbol? x915)) (error-hook (quote define-syntax) (quote "invalid argument") x915))) (let ((x916 v914)) (if (not (procedure? x916)) (error-hook (quote define-syntax) (quote "invalid argument") x916))) (global-extend (quote macro) sym913 v914)))) (letrec ((match (lambda (e917 p918 w919 r920) (cond ((not r920) (quote #f)) ((eq? p918 (quote any)) (cons (wrap e917 w919) r920)) ((syntax-object? e917) (match* (let ((e921 (syntax-object-expression e917))) (if (annotation? e921) (annotation-expression e921) e921)) p918 (join-wraps w919 (syntax-object-wrap e917)) r920)) (else (match* (let ((e922 e917)) (if (annotation? e922) (annotation-expression e922) e922)) p918 w919 r920))))) (match* (lambda (e923 p924 w925 r926) (cond ((null? p924) (and (null? e923) r926)) ((pair? p924) (and (pair? e923) (match (car e923) (car p924) w925 (match (cdr e923) (cdr p924) w925 r926)))) ((eq? p924 (quote each-any)) (let ((l (match-each-any e923 w925))) (and l (cons l r926)))) (else (let ((t927 (vector-ref p924 (quote 0)))) (if (memv t927 (quote (each))) (if (null? e923) (match-empty (vector-ref p924 (quote 1)) r926) (let ((l928 (match-each e923 (vector-ref p924 (quote 1)) w925))) (and l928 (let collect ((l929 l928)) (if (null? (car l929)) r926 (cons (map car l929) (collect (map cdr l929)))))))) (if (memv t927 (quote (free-id))) (and (id? e923) (free-id=? (wrap e923 w925) (vector-ref p924 (quote 1))) r926) (if (memv t927 (quote (atom))) (and (equal? (vector-ref p924 (quote 1)) (strip e923 w925)) r926) (if (memv t927 (quote (vector))) (and (vector? e923) (match (vector->list e923) (vector-ref p924 (quote 1)) w925 r926))))))))))) (match-empty (lambda (p930 r931) (cond ((null? p930) r931) ((eq? p930 (quote any)) (cons (quote ()) r931)) ((pair? p930) (match-empty (car p930) (match-empty (cdr p930) r931))) ((eq? p930 (quote each-any)) (cons (quote ()) r931)) (else (let ((t932 (vector-ref p930 (quote 0)))) (if (memv t932 (quote (each))) (match-empty (vector-ref p930 (quote 1)) r931) (if (memv t932 (quote (free-id atom))) r931 (if (memv t932 (quote (vector))) (match-empty (vector-ref p930 (quote 1)) r931))))))))) (match-each-any (lambda (e933 w934) (cond ((annotation? e933) (match-each-any (annotation-expression e933) w934)) ((pair? e933) (let ((l935 (match-each-any (cdr e933) w934))) (and l935 (cons (wrap (car e933) w934) l935)))) ((null? e933) (quote ())) ((syntax-object? e933) (match-each-any (syntax-object-expression e933) (join-wraps w934 (syntax-object-wrap e933)))) (else (quote #f))))) (match-each (lambda (e936 p937 w938) (cond ((annotation? e936) (match-each (annotation-expression e936) p937 w938)) ((pair? e936) (let ((first939 (match (car e936) p937 w938 (quote ())))) (and first939 (let ((rest940 (match-each (cdr e936) p937 w938))) (and rest940 (cons first939 rest940)))))) ((null? e936) (quote ())) ((syntax-object? e936) (match-each (syntax-object-expression e936) p937 (join-wraps w938 (syntax-object-wrap e936)))) (else (quote #f)))))) (set! syntax-dispatch (lambda (e941 p942) (cond ((eq? p942 (quote any)) (list e941)) ((syntax-object? e941) (match* (let ((e943 (syntax-object-expression e941))) (if (annotation? e943) (annotation-expression e943) e943)) p942 (syntax-object-wrap e941) (quote ()))) (else (match* (let ((e944 e941)) (if (annotation? e944) (annotation-expression e944) e944)) p942 (quote (())) (quote ())))))))))
(install-global-transformer (quote with-syntax) (lambda (x945) ((lambda (tmp946) ((lambda (tmp947) (if tmp947 (apply (lambda (_948 e1949 e2950) (cons (quote #(syntax-object begin ((top) #(ribcage #(_ e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e1949 e2950))) tmp947) ((lambda (tmp952) (if tmp952 (apply (lambda (_953 out in e1954 e2955) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) in (quote ()) (list out (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e1954 e2955))))) tmp952) ((lambda (tmp957) (if tmp957 (apply (lambda (_958 out959 in960 e1961 e2962) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons (quote #(syntax-object list ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) in960) (quote ()) (list out959 (cons (quote #(syntax-object begin ((top) #(ribcage #(_ out in e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e1961 e2962))))) tmp957) (syntax-error tmp946))) (syntax-dispatch tmp946 (quote (any #(each (any any)) any . each-any)))))) (syntax-dispatch tmp946 (quote (any ((any any)) any . each-any)))))) (syntax-dispatch tmp946 (quote (any () any . each-any))))) x945)))
(install-global-transformer (quote syntax-rules) (lambda (x966) ((lambda (tmp967) ((lambda (tmp968) (if tmp968 (apply (lambda (_969 k970 keyword pattern971 template) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote (#(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))))) (cons (quote #(syntax-object syntax-case ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons (quote #(syntax-object x ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons k970 (map (lambda (tmp973 tmp972) (list (cons (quote #(syntax-object dummy ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) tmp972) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ k keyword pattern template) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) tmp973))) template pattern971)))))) tmp968) (syntax-error tmp967))) (syntax-dispatch tmp967 (quote (any each-any . #(each ((any . any) any))))))) x966)))
(install-global-transformer (quote let*) (lambda (x) ((lambda (tmp974) ((lambda (tmp975) (if (if tmp975 (apply (lambda (let* x976 v e1 e2) (andmap identifier? x976)) tmp975) (quote #f)) (apply (lambda (let*978 x979 v980 e1981 e2982) (let f ((bindings (map list x979 v980))) (if (null? bindings) (cons (quote #(syntax-object let ((top) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons (quote ()) (cons e1981 e2982))) ((lambda (tmp986) ((lambda (tmp987) (if tmp987 (apply (lambda (body binding) (list (quote #(syntax-object let ((top) #(ribcage #(body binding) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f bindings) #((top) (top)) #("i" "i")) #(ribcage #(let* x v e1 e2) #((top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (list binding) body)) tmp987) (syntax-error tmp986))) (syntax-dispatch tmp986 (quote (any any))))) (list (f (cdr bindings)) (car bindings)))))) tmp975) (syntax-error tmp974))) (syntax-dispatch tmp974 (quote (any #(each (any any)) any . each-any))))) x)))
(install-global-transformer (quote do) (lambda (orig-x) ((lambda (tmp988) ((lambda (tmp989) (if tmp989 (apply (lambda (_ var init step e0 e1990 c) ((lambda (tmp991) ((lambda (tmp992) (if tmp992 (apply (lambda (step993) ((lambda (tmp994) ((lambda (tmp995) (if tmp995 (apply (lambda () (list (quote #(syntax-object let ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (map list var init) (list (quote #(syntax-object if ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (list (quote #(syntax-object not ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) e0) (cons (quote #(syntax-object begin ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (append c (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) step993))))))) tmp995) ((lambda (tmp1000) (if tmp1000 (apply (lambda (e11001 e21002) (list (quote #(syntax-object let ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (map list var init) (list (quote #(syntax-object if ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) e0 (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (cons e11001 e21002)) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) (append c (list (cons (quote #(syntax-object doloop ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage #(step) #((top)) #("i")) #(ribcage #(_ var init step e0 e1 c) #((top) (top) (top) (top) (top) (top) (top)) #("i" "i" "i" "i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(orig-x) #((top)) #("i"))))) step993))))))) tmp1000) (syntax-error tmp994))) (syntax-dispatch tmp994 (quote (any . each-any)))))) (syntax-dispatch tmp994 (quote ())))) e1990)) tmp992) (syntax-error tmp991))) (syntax-dispatch tmp991 (quote each-any)))) (map (lambda (v1009 s) ((lambda (tmp1010) ((lambda (tmp1011) (if tmp1011 (apply (lambda () v1009) tmp1011) ((lambda (tmp1012) (if tmp1012 (apply (lambda (e) e) tmp1012) ((lambda (_1013) (syntax-error orig-x)) tmp1010))) (syntax-dispatch tmp1010 (quote (any)))))) (syntax-dispatch tmp1010 (quote ())))) s)) var step))) tmp989) (syntax-error tmp988))) (syntax-dispatch tmp988 (quote (any #(each (any any . any)) (any . each-any) . each-any))))) orig-x)))
(install-global-transformer (quote quasiquote) (letrec ((quasicons (lambda (x1015 y) ((lambda (tmp1016) ((lambda (tmp1017) (if tmp1017 (apply (lambda (x1018 y1019) ((lambda (tmp1020) ((lambda (tmp1021) (if tmp1021 (apply (lambda (dy) ((lambda (tmp1022) ((lambda (tmp1023) (if tmp1023 (apply (lambda (dx) (list (quote #(syntax-object quote ((top) #(ribcage #(dx) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) (cons dx dy))) tmp1023) ((lambda (_1024) (if (null? dy) (list (quote #(syntax-object list ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) x1018) (list (quote #(syntax-object cons ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) x1018 y1019))) tmp1022))) (syntax-dispatch tmp1022 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(dy) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) any))))) x1018)) tmp1021) ((lambda (tmp1025) (if tmp1025 (apply (lambda (stuff) (cons (quote #(syntax-object list ((top) #(ribcage #(stuff) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) (cons x1018 stuff))) tmp1025) ((lambda (else) (list (quote #(syntax-object cons ((top) #(ribcage #(else) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) x1018 y1019)) tmp1020))) (syntax-dispatch tmp1020 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) . any)))))) (syntax-dispatch tmp1020 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) any))))) y1019)) tmp1017) (syntax-error tmp1016))) (syntax-dispatch tmp1016 (quote (any any))))) (list x1015 y)))) (quasiappend (lambda (x1026 y1027) ((lambda (tmp1028) ((lambda (tmp1029) (if tmp1029 (apply (lambda (x1030 y1031) ((lambda (tmp1032) ((lambda (tmp1033) (if tmp1033 (apply (lambda () x1030) tmp1033) ((lambda (_1034) (list (quote #(syntax-object append ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) x1030 y1031)) tmp1032))) (syntax-dispatch tmp1032 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x y) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) ()))))) y1031)) tmp1029) (syntax-error tmp1028))) (syntax-dispatch tmp1028 (quote (any any))))) (list x1026 y1027)))) (quasivector (lambda (x1035) ((lambda (tmp1036) ((lambda (x1037) ((lambda (tmp1038) ((lambda (tmp1039) (if tmp1039 (apply (lambda (x1040) (list (quote #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) (list->vector x1040))) tmp1039) ((lambda (tmp1042) (if tmp1042 (apply (lambda (x1043) (cons (quote #(syntax-object vector ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) x1043)) tmp1042) ((lambda (_1045) (list (quote #(syntax-object list->vector ((top) #(ribcage #(_) #((top)) #("i")) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) x1037)) tmp1038))) (syntax-dispatch tmp1038 (quote (#(free-id #(syntax-object list ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) . each-any)))))) (syntax-dispatch tmp1038 (quote (#(free-id #(syntax-object quote ((top) #(ribcage #(x) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) each-any))))) x1037)) tmp1036)) x1035))) (quasi (lambda (p lev) ((lambda (tmp1046) ((lambda (tmp1047) (if tmp1047 (apply (lambda (p1048) (if (= lev (quote 0)) p1048 (quasicons (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i")))) #(syntax-object unquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i")))))) (quasi (list p1048) (- lev (quote 1)))))) tmp1047) ((lambda (tmp1049) (if tmp1049 (apply (lambda (p1050 q) (if (= lev (quote 0)) (quasiappend p1050 (quasi q lev)) (quasicons (quasicons (quote (#(syntax-object quote ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i")))) #(syntax-object unquote-splicing ((top) #(ribcage #(p q) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i")))))) (quasi (list p1050) (- lev (quote 1)))) (quasi q lev)))) tmp1049) ((lambda (tmp) (if tmp (apply (lambda (p1051) (quasicons (quote (#(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i")))) #(syntax-object quasiquote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i")))))) (quasi (list p1051) (+ lev (quote 1))))) tmp) ((lambda (tmp1052) (if tmp1052 (apply (lambda (p1053 q1054) (quasicons (quasi p1053 lev) (quasi q1054 lev))) tmp1052) ((lambda (tmp1055) (if tmp1055 (apply (lambda (x1056) (quasivector (quasi x1056 lev))) tmp1055) ((lambda (p1058) (list (quote #(syntax-object quote ((top) #(ribcage #(p) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) p1058)) tmp1046))) (syntax-dispatch tmp1046 (quote #(vector each-any)))))) (syntax-dispatch tmp1046 (quote (any . any)))))) (syntax-dispatch tmp1046 (quote (#(free-id #(syntax-object quasiquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) any)))))) (syntax-dispatch tmp1046 (quote ((#(free-id #(syntax-object unquote-splicing ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) any) . any)))))) (syntax-dispatch tmp1046 (quote (#(free-id #(syntax-object unquote ((top) #(ribcage () () ()) #(ribcage #(p lev) #((top) (top)) #("i" "i")) #(ribcage #(quasicons quasiappend quasivector quasi) #((top) (top) (top) (top)) #("i" "i" "i" "i"))))) any))))) p)))) (lambda (x1059) ((lambda (tmp1060) ((lambda (tmp1061) (if tmp1061 (apply (lambda (_1062 e1063) (quasi e1063 (quote 0))) tmp1061) (syntax-error tmp1060))) (syntax-dispatch tmp1060 (quote (any any))))) x1059))))
(install-global-transformer (quote include) (lambda (x1064) (letrec ((read-file (lambda (fn k) (let ((p1065 (open-input-file fn))) (let f1066 ((x1067 (read p1065))) (if (eof-object? x1067) (begin (close-input-port p1065) (quote ())) (cons (datum->syntax-object k x1067) (f1066 (read p1065))))))))) ((lambda (tmp1068) ((lambda (tmp1069) (if tmp1069 (apply (lambda (k1070 filename) (let ((fn1071 (syntax-object->datum filename))) ((lambda (tmp1072) ((lambda (tmp1073) (if tmp1073 (apply (lambda (exp) (cons (quote #(syntax-object begin ((top) #(ribcage #(exp) #((top)) #("i")) #(ribcage () () ()) #(ribcage () () ()) #(ribcage #(fn) #((top)) #("i")) #(ribcage #(k filename) #((top) (top)) #("i" "i")) #(ribcage (read-file) ((top)) ("i")) #(ribcage #(x) #((top)) #("i"))))) exp)) tmp1073) (syntax-error tmp1072))) (syntax-dispatch tmp1072 (quote each-any)))) (read-file fn1071 k1070)))) tmp1069) (syntax-error tmp1068))) (syntax-dispatch tmp1068 (quote (any any))))) x1064))))
(install-global-transformer (quote unquote) (lambda (x1075) ((lambda (tmp1076) ((lambda (tmp1077) (if tmp1077 (apply (lambda (_1078 e1079) (error (quote unquote) (quote "expression ,~s not valid outside of quasiquote") (syntax-object->datum e1079))) tmp1077) (syntax-error tmp1076))) (syntax-dispatch tmp1076 (quote (any any))))) x1075)))
(install-global-transformer (quote unquote-splicing) (lambda (x1080) ((lambda (tmp1081) ((lambda (tmp1082) (if tmp1082 (apply (lambda (_1083 e1084) (error (quote unquote-splicing) (quote "expression ,@~s not valid outside of quasiquote") (syntax-object->datum e1084))) tmp1082) (syntax-error tmp1081))) (syntax-dispatch tmp1081 (quote (any any))))) x1080)))
(install-global-transformer (quote case) (lambda (x1085) ((lambda (tmp1086) ((lambda (tmp1087) (if tmp1087 (apply (lambda (_1088 e1089 m1 m2) ((lambda (tmp1090) ((lambda (body1091) (list (quote #(syntax-object let ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (list (list (quote #(syntax-object t ((top) #(ribcage #(body) #((top)) #("i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) e1089)) body1091)) tmp1090)) (let f1092 ((clause m1) (clauses m2)) (if (null? clauses) ((lambda (tmp1094) ((lambda (tmp1095) (if tmp1095 (apply (lambda (e11096 e21097) (cons (quote #(syntax-object begin ((top) #(ribcage #(e1 e2) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e11096 e21097))) tmp1095) ((lambda (tmp1099) (if tmp1099 (apply (lambda (k1100 e11101 e21102) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) k1100)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e11101 e21102)))) tmp1099) ((lambda (_1105) (syntax-error x1085)) tmp1094))) (syntax-dispatch tmp1094 (quote (each-any any . each-any)))))) (syntax-dispatch tmp1094 (quote (#(free-id #(syntax-object else ((top) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) any . each-any))))) clause) ((lambda (tmp1106) ((lambda (rest) ((lambda (tmp1107) ((lambda (tmp1108) (if tmp1108 (apply (lambda (k1109 e11110 e21111) (list (quote #(syntax-object if ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (list (quote #(syntax-object memv ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote #(syntax-object t ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (list (quote #(syntax-object quote ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) k1109)) (cons (quote #(syntax-object begin ((top) #(ribcage #(k e1 e2) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(rest) #((top)) #("i")) #(ribcage () () ()) #(ribcage #(f clause clauses) #((top) (top) (top)) #("i" "i" "i")) #(ribcage #(_ e m1 m2) #((top) (top) (top) (top)) #("i" "i" "i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e11110 e21111)) rest)) tmp1108) ((lambda (_1114) (syntax-error x1085)) tmp1107))) (syntax-dispatch tmp1107 (quote (each-any any . each-any))))) clause)) tmp1106)) (f1092 (car clauses) (cdr clauses))))))) tmp1087) (syntax-error tmp1086))) (syntax-dispatch tmp1086 (quote (any any any . each-any))))) x1085)))
(install-global-transformer (quote identifier-syntax) (lambda (x1115) ((lambda (tmp1116) ((lambda (tmp1117) (if tmp1117 (apply (lambda (_1118 e1119) (list (quote #(syntax-object lambda ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))))) (list (quote #(syntax-object syntax-case ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote #(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote ()) (list (quote #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (quote (#(syntax-object identifier? ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))) (#(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))) #(syntax-object id ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) e1119)) (list (cons _1118 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))))) (list (quote #(syntax-object syntax ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i"))))) (cons e1119 (quote (#(syntax-object x ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))) #(syntax-object ... ((top) #(ribcage #(_ e) #((top) (top)) #("i" "i")) #(ribcage () () ()) #(ribcage #(x) #((top)) #("i")))))))))))) tmp1117) (syntax-error tmp1116))) (syntax-dispatch tmp1116 (quote (any any))))) x1115)))
