This file gathers entries that have been automatically generated from
docstrings in libguile.  They are not included in the manual, however,
for various reasons, mostly because they have been deprecated.  They
are here in this file to give docstring.el a chance to update them
automatically.

- The 'environments' are only in Guile by accident and are not used at
  all and we don't want to advertise them.

- GOOPS is documented in its own manual.



@deffn {Scheme Procedure} substring-move-right!
implemented by the C function "scm_substring_move_x"
@end deffn

@deffn {Scheme Procedure} substring-move-left!
implemented by the C function "scm_substring_move_x"
@end deffn

@deffn {Scheme Procedure} gentemp [prefix [obarray]]
@deffnx {C Function} scm_gentemp (prefix, obarray)
Create a new symbol with a name unique in an obarray.
The name is constructed from an optional string @var{prefix}
and a counter value.  The default prefix is @code{t}.  The
@var{obarray} is specified as a second optional argument.
Default is the system obarray where all normal symbols are
interned.  The counter is increased by 1 at each
call.  There is no provision for resetting the counter.
@end deffn

@deffn {Scheme Procedure} symbol-set! o s v
@deffnx {C Function} scm_symbol_set_x (o, s, v)
Find the symbol in @var{obarray} whose name is @var{string}, and rebind
it to @var{value}.  An error is signalled if @var{string} is not present
in @var{obarray}.
@end deffn

@deffn {Scheme Procedure} symbol-bound? o s
@deffnx {C Function} scm_symbol_bound_p (o, s)
Return @code{#t} if @var{obarray} contains a symbol with name
@var{string} bound to a defined value.  This differs from
@var{symbol-interned?} in that the mere mention of a symbol
usually causes it to be interned; @code{symbol-bound?}
determines whether a symbol has been given any meaningful
value.
@end deffn

@deffn {Scheme Procedure} symbol-binding o s
@deffnx {C Function} scm_symbol_binding (o, s)
Look up in @var{obarray} the symbol whose name is @var{string}, and
return the value to which it is bound.  If @var{obarray} is @code{#f},
use the global symbol table.  If @var{string} is not interned in
@var{obarray}, an error is signalled.
@end deffn

@deffn {Scheme Procedure} unintern-symbol o s
@deffnx {C Function} scm_unintern_symbol (o, s)
Remove the symbol with name @var{string} from @var{obarray}.  This
function returns @code{#t} if the symbol was present and @code{#f}
otherwise.
@end deffn

@deffn {Scheme Procedure} intern-symbol o s
@deffnx {C Function} scm_intern_symbol (o, s)
Add a new symbol to @var{obarray} with name @var{string}, bound to an
unspecified initial value.  The symbol table is not modified if a symbol
with this name is already present.
@end deffn

@deffn {Scheme Procedure} string->obarray-symbol o s [softp]
@deffnx {C Function} scm_string_to_obarray_symbol (o, s, softp)
Intern a new symbol in @var{obarray}, a symbol table, with name
@var{string}.

If @var{obarray} is @code{#f}, use the default system symbol table.  If
@var{obarray} is @code{#t}, the symbol should not be interned in any
symbol table; merely return the pair (@var{symbol}
. @var{#<undefined>}).

The @var{soft?} argument determines whether new symbol table entries
should be created when the specified symbol is not already present in
@var{obarray}.  If @var{soft?} is specified and is a true value, then
new entries should not be added for symbols not already present in the
table; instead, simply return @code{#f}.
@end deffn

@deffn {Scheme Procedure} read-and-eval! [port]
@deffnx {C Function} scm_read_and_eval_x (port)
Read a form from @var{port} (standard input by default), and evaluate it
(memoizing it in the process) in the top-level environment.  If no data
is left to be read from @var{port}, an @code{end-of-file} error is
signalled.
@end deffn

@deffn {Scheme Procedure} sloppy-member x lst
@deffnx {C Function} scm_sloppy_member (x, lst)
This procedure behaves like @code{member}, but does no type or error checking.
Its use is recommended only in writing Guile internals,
not for high-level Scheme programs.
@end deffn

@deffn {Scheme Procedure} sloppy-memv x lst
@deffnx {C Function} scm_sloppy_memv (x, lst)
This procedure behaves like @code{memv}, but does no type or error checking.
Its use is recommended only in writing Guile internals,
not for high-level Scheme programs.
@end deffn

@deffn {Scheme Procedure} sloppy-memq x lst
@deffnx {C Function} scm_sloppy_memq (x, lst)
This procedure behaves like @code{memq}, but does no type or error checking.
Its use is recommended only in writing Guile internals,
not for high-level Scheme programs.
@end deffn

@deffn {Scheme Procedure} builtin-variable name
@deffnx {C Function} scm_builtin_variable (name)
Do not use this function.
@end deffn

@deffn {Scheme Procedure} variable-set-name-hint! var hint
@deffnx {C Function} scm_variable_set_name_hint (var, hint)
Do not use this function.
@end deffn

@deffn {Scheme Procedure} close-all-ports-except . ports
@deffnx {C Function} scm_close_all_ports_except (ports)
[DEPRECATED] Close all open file ports used by the interpreter
except for those supplied as arguments.  This procedure
was intended to be used before an exec call to close file descriptors
which are not needed in the new process.  However it has the
undesirable side effect of flushing buffers, so it's deprecated.
Use port-for-each instead.
@end deffn

@deffn {Scheme Procedure} c-clear-registered-modules
@deffnx {C Function} scm_clear_registered_modules ()
Destroy the list of modules registered with the current Guile process.
The return value is unspecified.  @strong{Warning:} this function does
not actually unlink or deallocate these modules, but only destroys the
records of which modules have been loaded.  It should therefore be used
only by module bookkeeping operations.
@end deffn

@deffn {Scheme Procedure} c-registered-modules
@deffnx {C Function} scm_registered_modules ()
Return a list of the object code modules that have been imported into
the current Guile process.  Each element of the list is a pair whose
car is the name of the module, and whose cdr is the function handle
for that module's initializer function.  The name is the string that
has been passed to scm_register_module_xxx.
@end deffn

@deffn {Scheme Procedure} module-import-interface module sym
@deffnx {C Function} scm_module_import_interface (module, sym)

@end deffn


@deffn {Scheme Procedure} self-evaluating? obj
@deffnx {C Function} scm_self_evaluating_p (obj)
Return #t for objects which Guile considers self-evaluating
@end deffn

@deffn {Scheme Procedure} unmemoize-expr m
@deffnx {C Function} scm_i_unmemoize_expr (m)
Unmemoize the memoized expression @var{m},
@end deffn

@deffn {Scheme Procedure} weak-key-alist-vector? obj
@deffnx {Scheme Procedure} weak-value-alist-vector? obj
@deffnx {Scheme Procedure} doubly-weak-alist-vector? obj
@deffnx {C Function} scm_weak_key_alist_vector_p (obj)
Return @code{#t} if @var{obj} is the specified weak hash
table. Note that a doubly weak hash table is neither a weak key
nor a weak value hash table.
@end deffn

@deffn {Scheme Procedure} make-weak-key-alist-vector [size]
@deffnx {Scheme Procedure} make-weak-value-alist-vector size
@deffnx {Scheme Procedure} make-doubly-weak-alist-vector size
@deffnx {C Function} scm_make_weak_key_alist_vector (size)
Return a weak hash table with @var{size} buckets. As with any
hash table, choosing a good size for the table requires some
caution.

You can modify weak hash tables in exactly the same way you
would modify regular hash tables. (@pxref{Hash Tables})
@end deffn

@deffn {Scheme Procedure} include-deprecated-features
Return @code{#t} iff deprecated features should be included
in public interfaces.
@end deffn

@deffn {Scheme Procedure} issue-deprecation-warning . msgs
Output @var{msgs} to @code{(current-error-port)} when this
is the first call to @code{issue-deprecation-warning} with
this specific @var{msg}.  Do nothing otherwise.
The argument @var{msgs} should be a list of strings;
they are printed in turn, each one followed by a newline.
@end deffn

@deffn {Scheme Procedure} valid-object-procedure? proc
@deffnx {C Function} scm_valid_object_procedure_p (proc)
Return @code{#t} iff @var{proc} is a procedure that can be used with @code{set-object-procedure}.  It is always valid to use a closure constructed by @code{lambda}.
@end deffn

@deffn {Scheme Procedure} %get-pre-modules-obarray
@deffnx {C Function} scm_get_pre_modules_obarray ()
Return the obarray that is used for all new bindings before the module system is booted.  The first call to @code{set-current-module} will boot the module system.
@end deffn

@deffn {Scheme Procedure} standard-interface-eval-closure module
@deffnx {C Function} scm_standard_interface_eval_closure (module)
Return a interface eval closure for the module @var{module}. Such a closure does not allow new bindings to be added.
@end deffn

@deffn {Scheme Procedure} env-module env
@deffnx {C Function} scm_env_module (env)
Return the module of @var{ENV}, a lexical environment.
@end deffn

@deffn {Scheme Procedure} single-active-thread?
implemented by the C function "scm_single_thread_p"
@end deffn

@deffn {Scheme Procedure} set-debug-cell-accesses! flag
@deffnx {C Function} scm_set_debug_cell_accesses_x (flag)
This function is used to turn on checking for a debug version of GUILE. This version does not support this functionality

@end deffn

@deffn {Scheme Procedure} standard-eval-closure module
@deffnx {C Function} scm_standard_eval_closure (module)
Return an eval closure for the module @var{module}.
@end deffn

@deffn {Scheme Procedure} mask-signals
@deffnx {C Function} scm_mask_signals ()
Mask signals. The returned value is not specified.
@end deffn

@deffn {Scheme Procedure} unmask-signals
@deffnx {C Function} scm_unmask_signals ()
Unmask signals. The returned value is not specified.
@end deffn

@deffn {Scheme Procedure} noop . args
@deffnx {C Function} scm_noop (args)
Do nothing.  When called without arguments, return @code{#f},
otherwise return the first argument.
@end deffn

@deffn {Scheme Procedure} system-async thunk
@deffnx {C Function} scm_system_async (thunk)
This function is deprecated.  You can use @var{thunk} directly
instead of explicitly creating an async object.

@end deffn

@deffn {Scheme Procedure} object-address obj
@deffnx {C Function} scm_object_address (obj)
Return an integer that for the lifetime of @var{obj} is uniquely
returned by this function for @var{obj}
@end deffn

@deffn {Scheme Procedure} environment? obj
@deffnx {C Function} scm_environment_p (obj)
Return @code{#t} if @var{obj} is an environment, or @code{#f}
otherwise.
@end deffn

@deffn {Scheme Procedure} environment-bound? env sym
@deffnx {C Function} scm_environment_bound_p (env, sym)
Return @code{#t} if @var{sym} is bound in @var{env}, or
@code{#f} otherwise.
@end deffn

@deffn {Scheme Procedure} environment-ref env sym
@deffnx {C Function} scm_environment_ref (env, sym)
Return the value of the location bound to @var{sym} in
@var{env}. If @var{sym} is unbound in @var{env}, signal an
@code{environment:unbound} error.
@end deffn

@deffn {Scheme Procedure} environment-fold env proc init
@deffnx {C Function} scm_environment_fold (env, proc, init)
Iterate over all the bindings in @var{env}, accumulating some
value.
For each binding in @var{env}, apply @var{proc} to the symbol
bound, its value, and the result from the previous application
of @var{proc}.
Use @var{init} as @var{proc}'s third argument the first time
@var{proc} is applied.
If @var{env} contains no bindings, this function simply returns
@var{init}.
If @var{env} binds the symbol sym1 to the value val1, sym2 to
val2, and so on, then this procedure computes:
@lisp
  (proc sym1 val1
        (proc sym2 val2
              ...
              (proc symn valn
                    init)))
@end lisp
Each binding in @var{env} will be processed exactly once.
@code{environment-fold} makes no guarantees about the order in
which the bindings are processed.
Here is a function which, given an environment, constructs an
association list representing that environment's bindings,
using environment-fold:
@lisp
  (define (environment->alist env)
    (environment-fold env
                      (lambda (sym val tail)
                        (cons (cons sym val) tail))
                      '()))
@end lisp
@end deffn

@deffn {Scheme Procedure} environment-define env sym val
@deffnx {C Function} scm_environment_define (env, sym, val)
Bind @var{sym} to a new location containing @var{val} in
@var{env}. If @var{sym} is already bound to another location
in @var{env} and the binding is mutable, that binding is
replaced.  The new binding and location are both mutable. The
return value is unspecified.
If @var{sym} is already bound in @var{env}, and the binding is
immutable, signal an @code{environment:immutable-binding} error.
@end deffn

@deffn {Scheme Procedure} environment-undefine env sym
@deffnx {C Function} scm_environment_undefine (env, sym)
Remove any binding for @var{sym} from @var{env}. If @var{sym}
is unbound in @var{env}, do nothing.  The return value is
unspecified.
If @var{sym} is already bound in @var{env}, and the binding is
immutable, signal an @code{environment:immutable-binding} error.
@end deffn

@deffn {Scheme Procedure} environment-set! env sym val
@deffnx {C Function} scm_environment_set_x (env, sym, val)
If @var{env} binds @var{sym} to some location, change that
location's value to @var{val}.  The return value is
unspecified.
If @var{sym} is not bound in @var{env}, signal an
@code{environment:unbound} error.  If @var{env} binds @var{sym}
to an immutable location, signal an
@code{environment:immutable-location} error.
@end deffn

@deffn {Scheme Procedure} environment-cell env sym for_write
@deffnx {C Function} scm_environment_cell (env, sym, for_write)
Return the value cell which @var{env} binds to @var{sym}, or
@code{#f} if the binding does not live in a value cell.
The argument @var{for-write} indicates whether the caller
intends to modify the variable's value by mutating the value
cell.  If the variable is immutable, then
@code{environment-cell} signals an
@code{environment:immutable-location} error.
If @var{sym} is unbound in @var{env}, signal an
@code{environment:unbound} error.
If you use this function, you should consider using
@code{environment-observe}, to be notified when @var{sym} gets
re-bound to a new value cell, or becomes undefined.
@end deffn

@deffn {Scheme Procedure} environment-observe env proc
@deffnx {C Function} scm_environment_observe (env, proc)
Whenever @var{env}'s bindings change, apply @var{proc} to
@var{env}.
This function returns an object, token, which you can pass to
@code{environment-unobserve} to remove @var{proc} from the set
of procedures observing @var{env}.  The type and value of
token is unspecified.
@end deffn

@deffn {Scheme Procedure} environment-observe-weak env proc
@deffnx {C Function} scm_environment_observe_weak (env, proc)
This function is the same as environment-observe, except that
the reference @var{env} retains to @var{proc} is a weak
reference. This means that, if there are no other live,
non-weak references to @var{proc}, it will be
garbage-collected, and dropped from @var{env}'s
list of observing procedures.
@end deffn

@deffn {Scheme Procedure} environment-unobserve token
@deffnx {C Function} scm_environment_unobserve (token)
Cancel the observation request which returned the value
@var{token}.  The return value is unspecified.
If a call @code{(environment-observe env proc)} returns
@var{token}, then the call @code{(environment-unobserve token)}
will cause @var{proc} to no longer be called when @var{env}'s
bindings change.
@end deffn

@deffn {Scheme Procedure} make-leaf-environment
@deffnx {C Function} scm_make_leaf_environment ()
Create a new leaf environment, containing no bindings.
All bindings and locations created in the new environment
will be mutable.
@end deffn

@deffn {Scheme Procedure} leaf-environment? object
@deffnx {C Function} scm_leaf_environment_p (object)
Return @code{#t} if object is a leaf environment, or @code{#f}
otherwise.
@end deffn

@deffn {Scheme Procedure} make-eval-environment local imported
@deffnx {C Function} scm_make_eval_environment (local, imported)
Return a new environment object eval whose bindings are the
union of the bindings in the environments @var{local} and
@var{imported}, with bindings from @var{local} taking
precedence. Definitions made in eval are placed in @var{local}.
Applying @code{environment-define} or
@code{environment-undefine} to eval has the same effect as
applying the procedure to @var{local}.
Note that eval incorporates @var{local} and @var{imported} by
reference:
If, after creating eval, the program changes the bindings of
@var{local} or @var{imported}, those changes will be visible
in eval.
Since most Scheme evaluation takes place in eval environments,
they transparently cache the bindings received from @var{local}
and @var{imported}. Thus, the first time the program looks up
a symbol in eval, eval may make calls to @var{local} or
@var{imported} to find their bindings, but subsequent
references to that symbol will be as fast as references to
bindings in finite environments.
In typical use, @var{local} will be a finite environment, and
@var{imported} will be an import environment
@end deffn

@deffn {Scheme Procedure} eval-environment? object
@deffnx {C Function} scm_eval_environment_p (object)
Return @code{#t} if object is an eval environment, or @code{#f}
otherwise.
@end deffn

@deffn {Scheme Procedure} eval-environment-local env
@deffnx {C Function} scm_eval_environment_local (env)
Return the local environment of eval environment @var{env}.
@end deffn

@deffn {Scheme Procedure} eval-environment-set-local! env local
@deffnx {C Function} scm_eval_environment_set_local_x (env, local)
Change @var{env}'s local environment to @var{local}.
@end deffn

@deffn {Scheme Procedure} eval-environment-imported env
@deffnx {C Function} scm_eval_environment_imported (env)
Return the imported environment of eval environment @var{env}.
@end deffn

@deffn {Scheme Procedure} eval-environment-set-imported! env imported
@deffnx {C Function} scm_eval_environment_set_imported_x (env, imported)
Change @var{env}'s imported environment to @var{imported}.
@end deffn

@deffn {Scheme Procedure} make-import-environment imports conflict_proc
@deffnx {C Function} scm_make_import_environment (imports, conflict_proc)
Return a new environment @var{imp} whose bindings are the union
of the bindings from the environments in @var{imports};
@var{imports} must be a list of environments. That is,
@var{imp} binds a symbol to a location when some element of
@var{imports} does.
If two different elements of @var{imports} have a binding for
the same symbol, the @var{conflict-proc} is called with the
following parameters:  the import environment, the symbol and
the list of the imported environments that bind the symbol.
If the @var{conflict-proc} returns an environment @var{env},
the conflict is considered as resolved and the binding from
@var{env} is used.  If the @var{conflict-proc} returns some
non-environment object, the conflict is considered unresolved
and the symbol is treated as unspecified in the import
environment.
The checking for conflicts may be performed lazily, i. e. at
the moment when a value or binding for a certain symbol is
requested instead of the moment when the environment is
created or the bindings of the imports change.
All bindings in @var{imp} are immutable. If you apply
@code{environment-define} or @code{environment-undefine} to
@var{imp}, Guile will signal an
 @code{environment:immutable-binding} error. However,
notice that the set of bindings in @var{imp} may still change,
if one of its imported environments changes.
@end deffn

@deffn {Scheme Procedure} import-environment? object
@deffnx {C Function} scm_import_environment_p (object)
Return @code{#t} if object is an import environment, or
@code{#f} otherwise.
@end deffn

@deffn {Scheme Procedure} import-environment-imports env
@deffnx {C Function} scm_import_environment_imports (env)
Return the list of environments imported by the import
environment @var{env}.
@end deffn

@deffn {Scheme Procedure} import-environment-set-imports! env imports
@deffnx {C Function} scm_import_environment_set_imports_x (env, imports)
Change @var{env}'s list of imported environments to
@var{imports}, and check for conflicts.
@end deffn

@deffn {Scheme Procedure} make-export-environment private signature
@deffnx {C Function} scm_make_export_environment (private, signature)
Return a new environment @var{exp} containing only those
bindings in private whose symbols are present in
@var{signature}. The @var{private} argument must be an
environment.

The environment @var{exp} binds symbol to location when
@var{env} does, and symbol is exported by @var{signature}.

@var{signature} is a list specifying which of the bindings in
@var{private} should be visible in @var{exp}. Each element of
@var{signature} should be a list of the form:
  (symbol attribute ...)
where each attribute is one of the following:
@table @asis
@item the symbol @code{mutable-location}
  @var{exp} should treat the
  location bound to symbol as mutable. That is, @var{exp}
  will pass calls to @code{environment-set!} or
  @code{environment-cell} directly through to private.
@item the symbol @code{immutable-location}
  @var{exp} should treat
  the location bound to symbol as immutable. If the program
  applies @code{environment-set!} to @var{exp} and symbol, or
  calls @code{environment-cell} to obtain a writable value
  cell, @code{environment-set!} will signal an
  @code{environment:immutable-location} error. Note that, even
  if an export environment treats a location as immutable, the
  underlying environment may treat it as mutable, so its
  value may change.
@end table
It is an error for an element of signature to specify both
@code{mutable-location} and @code{immutable-location}. If
neither is specified, @code{immutable-location} is assumed.

As a special case, if an element of signature is a lone
symbol @var{sym}, it is equivalent to an element of the form
@code{(sym)}.

All bindings in @var{exp} are immutable. If you apply
@code{environment-define} or @code{environment-undefine} to
@var{exp}, Guile will signal an
@code{environment:immutable-binding} error. However,
notice that the set of bindings in @var{exp} may still change,
if the bindings in private change.
@end deffn

@deffn {Scheme Procedure} export-environment? object
@deffnx {C Function} scm_export_environment_p (object)
Return @code{#t} if object is an export environment, or
@code{#f} otherwise.
@end deffn

@deffn {Scheme Procedure} export-environment-private env
@deffnx {C Function} scm_export_environment_private (env)
Return the private environment of export environment @var{env}.
@end deffn

@deffn {Scheme Procedure} export-environment-set-private! env private
@deffnx {C Function} scm_export_environment_set_private_x (env, private)
Change the private environment of export environment @var{env}.
@end deffn

@deffn {Scheme Procedure} export-environment-signature env
@deffnx {C Function} scm_export_environment_signature (env)
Return the signature of export environment @var{env}.
@end deffn

@deffn {Scheme Procedure} export-environment-set-signature! env signature
@deffnx {C Function} scm_export_environment_set_signature_x (env, signature)
Change the signature of export environment @var{env}.
@end deffn

@deffn {Scheme Procedure} %compute-slots class
@deffnx {C Function} scm_sys_compute_slots (class)
Return a list consisting of the names of all slots belonging to
class @var{class}, i. e. the slots of @var{class} and of all of
its superclasses.
@end deffn

@deffn {Scheme Procedure} get-keyword key l default_value
@deffnx {C Function} scm_get_keyword (key, l, default_value)
Determine an associated value for the keyword @var{key} from
the list @var{l}.  The list @var{l} has to consist of an even
number of elements, where, starting with the first, every
second element is a keyword, followed by its associated value.
If @var{l} does not hold a value for @var{key}, the value
@var{default_value} is returned.
@end deffn

@deffn {Scheme Procedure} slot-ref-using-class class obj slot_name
@deffnx {C Function} scm_slot_ref_using_class (class, obj, slot_name)

@end deffn

@deffn {Scheme Procedure} slot-set-using-class! class obj slot_name value
@deffnx {C Function} scm_slot_set_using_class_x (class, obj, slot_name, value)

@end deffn

@deffn {Scheme Procedure} class-of x
@deffnx {C Function} scm_class_of (x)
Return the class of @var{x}.
@end deffn

@deffn {Scheme Procedure} %goops-loaded
@deffnx {C Function} scm_sys_goops_loaded ()
Announce that GOOPS is loaded and perform initialization
on the C level which depends on the loaded GOOPS modules.
@end deffn

@deffn {Scheme Procedure} %method-more-specific? m1 m2 targs
@deffnx {C Function} scm_sys_method_more_specific_p (m1, m2, targs)

@end deffn

@deffn {Scheme Procedure} find-method . l
@deffnx {C Function} scm_find_method (l)

@end deffn

@deffn {Scheme Procedure} primitive-generic-generic subr
@deffnx {C Function} scm_primitive_generic_generic (subr)

@end deffn

@deffn {Scheme Procedure} enable-primitive-generic! . subrs
@deffnx {C Function} scm_enable_primitive_generic_x (subrs)

@end deffn

@deffn {Scheme Procedure} generic-capability? proc
@deffnx {C Function} scm_generic_capability_p (proc)

@end deffn

@deffn {Scheme Procedure} %invalidate-method-cache! gf
@deffnx {C Function} scm_sys_invalidate_method_cache_x (gf)

@end deffn

@deffn {Scheme Procedure} %invalidate-class class
@deffnx {C Function} scm_sys_invalidate_class (class)

@end deffn

@deffn {Scheme Procedure} %modify-class old new
@deffnx {C Function} scm_sys_modify_class (old, new)

@end deffn

@deffn {Scheme Procedure} %modify-instance old new
@deffnx {C Function} scm_sys_modify_instance (old, new)

@end deffn

@deffn {Scheme Procedure} %set-object-setter! obj setter
@deffnx {C Function} scm_sys_set_object_setter_x (obj, setter)

@end deffn

@deffn {Scheme Procedure} %allocate-instance class initargs
@deffnx {C Function} scm_sys_allocate_instance (class, initargs)
Create a new instance of class @var{class} and initialize it
from the arguments @var{initargs}.
@end deffn

@deffn {Scheme Procedure} slot-exists? obj slot_name
@deffnx {C Function} scm_slot_exists_p (obj, slot_name)
Return @code{#t} if @var{obj} has a slot named @var{slot_name}.
@end deffn

@deffn {Scheme Procedure} slot-bound? obj slot_name
@deffnx {C Function} scm_slot_bound_p (obj, slot_name)
Return @code{#t} if the slot named @var{slot_name} of @var{obj}
is bound.
@end deffn

@deffn {Scheme Procedure} slot-set! obj slot_name value
@deffnx {C Function} scm_slot_set_x (obj, slot_name, value)
Set the slot named @var{slot_name} of @var{obj} to @var{value}.
@end deffn

@deffn {Scheme Procedure} slot-exists-using-class? class obj slot_name
@deffnx {C Function} scm_slot_exists_using_class_p (class, obj, slot_name)

@end deffn

@deffn {Scheme Procedure} slot-bound-using-class? class obj slot_name
@deffnx {C Function} scm_slot_bound_using_class_p (class, obj, slot_name)

@end deffn

@deffn {Scheme Procedure} %fast-slot-set! obj index value
@deffnx {C Function} scm_sys_fast_slot_set_x (obj, index, value)
Set the slot with index @var{index} in @var{obj} to
@var{value}.
@end deffn

@deffn {Scheme Procedure} %fast-slot-ref obj index
@deffnx {C Function} scm_sys_fast_slot_ref (obj, index)
Return the slot value with index @var{index} from @var{obj}.
@end deffn

@deffn {Scheme Procedure} @@assert-bound-ref obj index
@deffnx {C Function} scm_at_assert_bound_ref (obj, index)
Like @code{assert-bound}, but use @var{index} for accessing
the value from @var{obj}.
@end deffn

@deffn {Scheme Procedure} assert-bound value obj
@deffnx {C Function} scm_assert_bound (value, obj)
Return @var{value} if it is bound, and invoke the
@var{slot-unbound} method of @var{obj} if it is not.
@end deffn

@deffn {Scheme Procedure} unbound? obj
@deffnx {C Function} scm_unbound_p (obj)
Return @code{#t} if @var{obj} is unbound.
@end deffn

@deffn {Scheme Procedure} make-unbound
@deffnx {C Function} scm_make_unbound ()
Return the unbound value.
@end deffn

@deffn {Scheme Procedure} accessor-method-slot-definition obj
@deffnx {C Function} scm_accessor_method_slot_definition (obj)
Return the slot definition of the accessor @var{obj}.
@end deffn

@deffn {Scheme Procedure} method-procedure obj
@deffnx {C Function} scm_method_procedure (obj)
Return the procedure of the method @var{obj}.
@end deffn

@deffn {Scheme Procedure} method-specializers obj
@deffnx {C Function} scm_method_specializers (obj)
Return specializers of the method @var{obj}.
@end deffn

@deffn {Scheme Procedure} method-generic-function obj
@deffnx {C Function} scm_method_generic_function (obj)
Return the generic function for the method @var{obj}.
@end deffn

@deffn {Scheme Procedure} generic-function-methods obj
@deffnx {C Function} scm_generic_function_methods (obj)
Return the methods of the generic function @var{obj}.
@end deffn

@deffn {Scheme Procedure} generic-function-name obj
@deffnx {C Function} scm_generic_function_name (obj)
Return the name of the generic function @var{obj}.
@end deffn

@deffn {Scheme Procedure} class-environment obj
@deffnx {C Function} scm_class_environment (obj)
Return the environment of the class @var{obj}.
@end deffn

@deffn {Scheme Procedure} class-slots obj
@deffnx {C Function} scm_class_slots (obj)
Return the slot list of the class @var{obj}.
@end deffn

@deffn {Scheme Procedure} class-precedence-list obj
@deffnx {C Function} scm_class_precedence_list (obj)
Return the class precedence list of the class @var{obj}.
@end deffn

@deffn {Scheme Procedure} class-direct-methods obj
@deffnx {C Function} scm_class_direct_methods (obj)
Return the direct methods of the class @var{obj}
@end deffn

@deffn {Scheme Procedure} class-direct-subclasses obj
@deffnx {C Function} scm_class_direct_subclasses (obj)
Return the direct subclasses of the class @var{obj}.
@end deffn

@deffn {Scheme Procedure} class-direct-slots obj
@deffnx {C Function} scm_class_direct_slots (obj)
Return the direct slots of the class @var{obj}.
@end deffn

@deffn {Scheme Procedure} class-direct-supers obj
@deffnx {C Function} scm_class_direct_supers (obj)
Return the direct superclasses of the class @var{obj}.
@end deffn

@deffn {Scheme Procedure} class-name obj
@deffnx {C Function} scm_class_name (obj)
Return the class name of @var{obj}.
@end deffn

@deffn {Scheme Procedure} instance? obj
@deffnx {C Function} scm_instance_p (obj)
Return @code{#t} if @var{obj} is an instance.
@end deffn

@deffn {Scheme Procedure} %inherit-magic! class dsupers
@deffnx {C Function} scm_sys_inherit_magic_x (class, dsupers)

@end deffn

@deffn {Scheme Procedure} %prep-layout! class
@deffnx {C Function} scm_sys_prep_layout_x (class)

@end deffn

@deffn {Scheme Procedure} %initialize-object obj initargs
@deffnx {C Function} scm_sys_initialize_object (obj, initargs)
Initialize the object @var{obj} with the given arguments
@var{initargs}.
@end deffn

@deffn {Scheme Procedure} make . args
@deffnx {C Function} scm_make (args)
Make a new object.  @var{args} must contain the class and
all necessary initialization information.
@end deffn

@deffn {Scheme Procedure} slot-ref obj slot_name
@deffnx {C Function} scm_slot_ref (obj, slot_name)
Return the value from @var{obj}'s slot with the name
@var{slot_name}.
@end deffn

@deffn {Scheme Procedure} %tag-body body
@deffnx {C Function} scm_sys_tag_body (body)
Internal GOOPS magic---don't use this function!
@end deffn

@deffn {Scheme Procedure} make-keyword-from-dash-symbol symbol
@deffnx {C Function} scm_make_keyword_from_dash_symbol (symbol)
Make a keyword object from a @var{symbol} that starts with a dash.
@end deffn

@deffn {Scheme Procedure} keyword-dash-symbol keyword
@deffnx {C Function} scm_keyword_dash_symbol (keyword)
Return the dash symbol for @var{keyword}.
This is the inverse of @code{make-keyword-from-dash-symbol}.
@end deffn

@deffn {Scheme Procedure} dimensions->uniform-array dims prot [fill]
@deffnx {Scheme Procedure} make-uniform-vector length prototype [fill]
@deffnx {C Function} scm_dimensions_to_uniform_array (dims, prot, fill)
Create and return a uniform array or vector of type
corresponding to @var{prototype} with dimensions @var{dims} or
length @var{length}.  If @var{fill} is supplied, it's used to
fill the array, otherwise @var{prototype} is used.
@end deffn

@deffn {Scheme Procedure} list->uniform-array ndim prot lst
@deffnx {C Function} scm_list_to_uniform_array (ndim, prot, lst)
Return a uniform array of the type indicated by prototype
@var{prot} with elements the same as those of @var{lst}.
Elements must be of the appropriate type, no coercions are
done.

The argument @var{ndim} determines the number of dimensions
of the array.  It is either an exact integer, giving the
number directly, or a list of exact integers, whose length
specifies the number of dimensions and each element is the
lower index bound of its dimension.
@end deffn

@deffn {Scheme Procedure} array-prototype ra
@deffnx {C Function} scm_array_prototype (ra)
Return an object that would produce an array of the same type
as @var{array}, if used as the @var{prototype} for
@code{make-uniform-array}.
@end deffn

@deffn {Scheme Procedure} call-with-dynamic-root thunk handler
@deffnx {C Function} scm_call_with_dynamic_root (thunk, handler)
Call @var{thunk} with a new dynamic state and withina continuation barrier.  The @var{handler} catches allotherwise uncaught throws and executes within the samedynamic context as @var{thunk}.
@end deffn

@deffn {Scheme Procedure} dynamic-root
@deffnx {C Function} scm_dynamic_root ()
Return an object representing the current dynamic root.

These objects are only useful for comparison using @code{eq?}.

@end deffn

@deffn {Scheme Procedure} uniform-vector? obj
@deffnx {C Function} scm_uniform_vector_p (obj)
Return @code{#t} if @var{obj} is a uniform vector.
@end deffn

@deffn {Scheme Procedure} uniform-vector-ref v idx
@deffnx {C Function} scm_uniform_vector_ref (v, idx)
Return the element at index @var{idx} of the
homogenous numeric vector @var{v}.
@end deffn

@deffn {Scheme Procedure} uniform-vector-set! v idx val
@deffnx {C Function} scm_uniform_vector_set_x (v, idx, val)
Set the element at index @var{idx} of the
homogenous numeric vector @var{v} to @var{val}.
@end deffn

@deffn {Scheme Procedure} uniform-vector->list uvec
@deffnx {C Function} scm_uniform_vector_to_list (uvec)
Convert the uniform numeric vector @var{uvec} to a list.
@end deffn

@deffn {Scheme Procedure} uniform-vector-length v
@deffnx {C Function} scm_uniform_vector_length (v)
Return the number of elements in the uniform vector @var{v}.
@end deffn

@deffn {Scheme Procedure} make-u8vector len [fill]
@deffnx {C Function} scm_make_u8vector (len, fill)
Return a newly allocated uniform numeric vector which can
hold @var{len} elements.  If @var{fill} is given, it is used to
initialize the elements, otherwise the contents of the vector
is unspecified.
@end deffn

@deffn {Scheme Procedure} u8vector . l
@deffnx {C Function} scm_u8vector (l)
Return a newly allocated uniform numeric vector containing
all argument values.
@end deffn

@deffn {Scheme Procedure} list->u8vector l
@deffnx {C Function} scm_list_to_u8vector (l)
Convert the list @var{l} to a numeric uniform vector.
@end deffn

@deffn {Scheme Procedure} any->u8vector obj
@deffnx {C Function} scm_any_to_u8vector (obj)
Convert @var{obj}, which can be a list, vector, or
uniform vector, to a numeric uniform vector of
type u8.
@end deffn

@deffn {Scheme Procedure} string-any-c-code char_pred s [start [end]]
@deffnx {C Function} scm_string_any (char_pred, s, start, end)
Check if the predicate @var{pred} is true for any character in
the string @var{s}.

Calls to @var{pred} are made from left to right across @var{s}.
When it returns true (ie.@: non-@code{#f}), that return value
is the return from @code{string-any}.

The SRFI-13 specification requires that the call to @var{pred}
on the last character of @var{s} (assuming that point is
reached) be a tail call, but currently in Guile this is not the
case.
@end deffn

@deffn {Scheme Procedure} string-every-c-code char_pred s [start [end]]
@deffnx {C Function} scm_string_every (char_pred, s, start, end)
Check if the predicate @var{pred} is true for every character
in the string @var{s}.

Calls to @var{pred} are made from left to right across @var{s}.
If the predicate is true for every character then the return
value from the last @var{pred} call is the return from
@code{string-every}.

If there are no characters in @var{s} (ie.@: @var{start} equals
@var{end}) then the return is @code{#t}.

The SRFI-13 specification requires that the call to @var{pred}
on the last character of @var{s} (assuming that point is
reached) be a tail call, but currently in Guile this is not the
case.
@end deffn

@deffn {Scheme Procedure} inf? x
@deffnx {C Function} scm_inf_p (x)
Return @code{#t} if @var{x} is either @samp{+inf.0}
or @samp{-inf.0}, @code{#f} otherwise.
@end deffn


