
acons
@deffn {Scheme Procedure} acons key value alist
@deffnx {C Function} scm_acons (key, value, alist)
Add a new key-value pair to @var{alist}.  A new pair is
created whose car is @var{key} and whose cdr is @var{value}, and the
pair is consed onto @var{alist}, and the new list is returned.  This
function is @emph{not} destructive; @var{alist} is not modified.
@end deffn

sloppy-assq
@deffn {Scheme Procedure} sloppy-assq key alist
@deffnx {C Function} scm_sloppy_assq (key, alist)
Behaves like @code{assq} but does not do any error checking.
Recommended only for use in Guile internals.
@end deffn

sloppy-assv
@deffn {Scheme Procedure} sloppy-assv key alist
@deffnx {C Function} scm_sloppy_assv (key, alist)
Behaves like @code{assv} but does not do any error checking.
Recommended only for use in Guile internals.
@end deffn

sloppy-assoc
@deffn {Scheme Procedure} sloppy-assoc key alist
@deffnx {C Function} scm_sloppy_assoc (key, alist)
Behaves like @code{assoc} but does not do any error checking.
Recommended only for use in Guile internals.
@end deffn

assq
@deffn {Scheme Procedure} assq key alist
@deffnx {Scheme Procedure} assv key alist
@deffnx {Scheme Procedure} assoc key alist
@deffnx {C Function} scm_assq (key, alist)
Fetch the entry in @var{alist} that is associated with @var{key}.  To
decide whether the argument @var{key} matches a particular entry in
@var{alist}, @code{assq} compares keys with @code{eq?}, @code{assv}
uses @code{eqv?} and @code{assoc} uses @code{equal?}.  If @var{key}
cannot be found in @var{alist} (according to whichever equality
predicate is in use), then return @code{#f}.  These functions
return the entire alist entry found (i.e. both the key and the value).
@end deffn

assv
@deffn {Scheme Procedure} assv key alist
@deffnx {C Function} scm_assv (key, alist)
Behaves like @code{assq} but uses @code{eqv?} for key comparison.
@end deffn

assoc
@deffn {Scheme Procedure} assoc key alist
@deffnx {C Function} scm_assoc (key, alist)
Behaves like @code{assq} but uses @code{equal?} for key comparison.
@end deffn

assq-ref
@deffn {Scheme Procedure} assq-ref alist key
@deffnx {Scheme Procedure} assv-ref alist key
@deffnx {Scheme Procedure} assoc-ref alist key
@deffnx {C Function} scm_assq_ref (alist, key)
Like @code{assq}, @code{assv} and @code{assoc}, except that only the
value associated with @var{key} in @var{alist} is returned.  These
functions are equivalent to

@lisp
(let ((ent (@var{associator} @var{key} @var{alist})))
  (and ent (cdr ent)))
@end lisp

where @var{associator} is one of @code{assq}, @code{assv} or @code{assoc}.
@end deffn

assv-ref
@deffn {Scheme Procedure} assv-ref alist key
@deffnx {C Function} scm_assv_ref (alist, key)
Behaves like @code{assq-ref} but uses @code{eqv?} for key comparison.
@end deffn

assoc-ref
@deffn {Scheme Procedure} assoc-ref alist key
@deffnx {C Function} scm_assoc_ref (alist, key)
Behaves like @code{assq-ref} but uses @code{equal?} for key comparison.
@end deffn

assq-set!
@deffn {Scheme Procedure} assq-set! alist key val
@deffnx {Scheme Procedure} assv-set! alist key value
@deffnx {Scheme Procedure} assoc-set! alist key value
@deffnx {C Function} scm_assq_set_x (alist, key, val)
Reassociate @var{key} in @var{alist} with @var{value}: find any existing
@var{alist} entry for @var{key} and associate it with the new
@var{value}.  If @var{alist} does not contain an entry for @var{key},
add a new one.  Return the (possibly new) alist.

These functions do not attempt to verify the structure of @var{alist},
and so may cause unusual results if passed an object that is not an
association list.
@end deffn

assv-set!
@deffn {Scheme Procedure} assv-set! alist key val
@deffnx {C Function} scm_assv_set_x (alist, key, val)
Behaves like @code{assq-set!} but uses @code{eqv?} for key comparison.
@end deffn

assoc-set!
@deffn {Scheme Procedure} assoc-set! alist key val
@deffnx {C Function} scm_assoc_set_x (alist, key, val)
Behaves like @code{assq-set!} but uses @code{equal?} for key comparison.
@end deffn

assq-remove!
@deffn {Scheme Procedure} assq-remove! alist key
@deffnx {Scheme Procedure} assv-remove! alist key
@deffnx {Scheme Procedure} assoc-remove! alist key
@deffnx {C Function} scm_assq_remove_x (alist, key)
Delete the first entry in @var{alist} associated with @var{key}, and return
the resulting alist.
@end deffn

assv-remove!
@deffn {Scheme Procedure} assv-remove! alist key
@deffnx {C Function} scm_assv_remove_x (alist, key)
Behaves like @code{assq-remove!} but uses @code{eqv?} for key comparison.
@end deffn

assoc-remove!
@deffn {Scheme Procedure} assoc-remove! alist key
@deffnx {C Function} scm_assoc_remove_x (alist, key)
Behaves like @code{assq-remove!} but uses @code{equal?} for key comparison.
@end deffn

make-arbiter
@deffn {Scheme Procedure} make-arbiter name
@deffnx {C Function} scm_make_arbiter (name)
Return an object of type arbiter and name @var{name}. Its
state is initially unlocked.  Arbiters are a way to achieve
process synchronization.
@end deffn

try-arbiter
@deffn {Scheme Procedure} try-arbiter arb
@deffnx {C Function} scm_try_arbiter (arb)
Return @code{#t} and lock the arbiter @var{arb} if the arbiter
was unlocked. Otherwise, return @code{#f}.
@end deffn

release-arbiter
@deffn {Scheme Procedure} release-arbiter arb
@deffnx {C Function} scm_release_arbiter (arb)
Return @code{#t} and unlock the arbiter @var{arb} if the
arbiter was locked. Otherwise, return @code{#f}.
@end deffn

async
@deffn {Scheme Procedure} async thunk
@deffnx {C Function} scm_async (thunk)
Create a new async for the procedure @var{thunk}.
@end deffn

async-mark
@deffn {Scheme Procedure} async-mark a
@deffnx {C Function} scm_async_mark (a)
Mark the async @var{a} for future execution.
@end deffn

run-asyncs
@deffn {Scheme Procedure} run-asyncs list_of_a
@deffnx {C Function} scm_run_asyncs (list_of_a)
Execute all thunks from the asyncs of the list @var{list_of_a}.
@end deffn

system-async
@deffn {Scheme Procedure} system-async thunk
@deffnx {C Function} scm_system_async (thunk)
This function is deprecated.  You can use @var{thunk} directly
instead of explicitely creating an async object.

@end deffn

system-async-mark
@deffn {Scheme Procedure} system-async-mark proc [thread]
@deffnx {C Function} scm_system_async_mark_for_thread (proc, thread)
Register the procedure @var{proc} for future execution
in @var{thread}.  When @var{thread} is not specified,
use the current thread.
@end deffn

noop
@deffn {Scheme Procedure} noop . args
@deffnx {C Function} scm_noop (args)
Do nothing.  When called without arguments, return @code{#f},
otherwise return the first argument.
@end deffn

unmask-signals
@deffn {Scheme Procedure} unmask-signals
@deffnx {C Function} scm_unmask_signals ()
Unmask signals. The returned value is not specified.
@end deffn

mask-signals
@deffn {Scheme Procedure} mask-signals
@deffnx {C Function} scm_mask_signals ()
Mask signals. The returned value is not specified.
@end deffn

call-with-blocked-asyncs
@deffn {Scheme Procedure} call-with-blocked-asyncs proc
@deffnx {C Function} scm_call_with_blocked_asyncs (proc)
Call @var{proc} with no arguments and block the execution
of system asyncs by one level for the current thread while
it is running.  Return the value returned by @var{proc}.

@end deffn

call-with-unblocked-asyncs
@deffn {Scheme Procedure} call-with-unblocked-asyncs proc
@deffnx {C Function} scm_call_with_unblocked_asyncs (proc)
Call @var{proc} with no arguments and unblock the execution
of system asyncs by one level for the current thread while
it is running.  Return the value returned by @var{proc}.

@end deffn

display-error
@deffn {Scheme Procedure} display-error stack port subr message args rest
@deffnx {C Function} scm_display_error (stack, port, subr, message, args, rest)
Display an error message to the output port @var{port}.
@var{stack} is the saved stack for the error, @var{subr} is
the name of the procedure in which the error occurred and
@var{message} is the actual error message, which may contain
formatting instructions. These will format the arguments in
the list @var{args} accordingly.  @var{rest} is currently
ignored.
@end deffn

display-application
@deffn {Scheme Procedure} display-application frame [port [indent]]
@deffnx {C Function} scm_display_application (frame, port, indent)
Display a procedure application @var{frame} to the output port
@var{port}. @var{indent} specifies the indentation of the
output.
@end deffn

display-backtrace
@deffn {Scheme Procedure} display-backtrace stack port [first [depth]]
@deffnx {C Function} scm_display_backtrace (stack, port, first, depth)
Display a backtrace to the output port @var{port}. @var{stack}
is the stack to take the backtrace from, @var{first} specifies
where in the stack to start and @var{depth} how much frames
to display. Both @var{first} and @var{depth} can be @code{#f},
which means that default values will be used.
@end deffn

backtrace
@deffn {Scheme Procedure} backtrace
@deffnx {C Function} scm_backtrace ()
Display a backtrace of the stack saved by the last error
to the current output port.
@end deffn

not
@deffn {Scheme Procedure} not x
@deffnx {C Function} scm_not (x)
Return @code{#t} iff @var{x} is @code{#f}, else return @code{#f}.
@end deffn

boolean?
@deffn {Scheme Procedure} boolean? obj
@deffnx {C Function} scm_boolean_p (obj)
Return @code{#t} iff @var{obj} is either @code{#t} or @code{#f}.
@end deffn

char?
@deffn {Scheme Procedure} char? x
@deffnx {C Function} scm_char_p (x)
Return @code{#t} iff @var{x} is a character, else @code{#f}.
@end deffn

char=?
@deffn {Scheme Procedure} char=? x y
Return @code{#t} iff @var{x} is the same character as @var{y}, else @code{#f}.
@end deffn

char<?
@deffn {Scheme Procedure} char<? x y
Return @code{#t} iff @var{x} is less than @var{y} in the ASCII sequence,
else @code{#f}.
@end deffn

char<=?
@deffn {Scheme Procedure} char<=? x y
Return @code{#t} iff @var{x} is less than or equal to @var{y} in the
ASCII sequence, else @code{#f}.
@end deffn

char>?
@deffn {Scheme Procedure} char>? x y
Return @code{#t} iff @var{x} is greater than @var{y} in the ASCII
sequence, else @code{#f}.
@end deffn

char>=?
@deffn {Scheme Procedure} char>=? x y
Return @code{#t} iff @var{x} is greater than or equal to @var{y} in the
ASCII sequence, else @code{#f}.
@end deffn

char-ci=?
@deffn {Scheme Procedure} char-ci=? x y
Return @code{#t} iff @var{x} is the same character as @var{y} ignoring
case, else @code{#f}.
@end deffn

char-ci<?
@deffn {Scheme Procedure} char-ci<? x y
Return @code{#t} iff @var{x} is less than @var{y} in the ASCII sequence
ignoring case, else @code{#f}.
@end deffn

char-ci<=?
@deffn {Scheme Procedure} char-ci<=? x y
Return @code{#t} iff @var{x} is less than or equal to @var{y} in the
ASCII sequence ignoring case, else @code{#f}.
@end deffn

char-ci>?
@deffn {Scheme Procedure} char-ci>? x y
Return @code{#t} iff @var{x} is greater than @var{y} in the ASCII
sequence ignoring case, else @code{#f}.
@end deffn

char-ci>=?
@deffn {Scheme Procedure} char-ci>=? x y
Return @code{#t} iff @var{x} is greater than or equal to @var{y} in the
ASCII sequence ignoring case, else @code{#f}.
@end deffn

char-alphabetic?
@deffn {Scheme Procedure} char-alphabetic? chr
@deffnx {C Function} scm_char_alphabetic_p (chr)
Return @code{#t} iff @var{chr} is alphabetic, else @code{#f}.
Alphabetic means the same thing as the isalpha C library function.
@end deffn

char-numeric?
@deffn {Scheme Procedure} char-numeric? chr
@deffnx {C Function} scm_char_numeric_p (chr)
Return @code{#t} iff @var{chr} is numeric, else @code{#f}.
Numeric means the same thing as the isdigit C library function.
@end deffn

char-whitespace?
@deffn {Scheme Procedure} char-whitespace? chr
@deffnx {C Function} scm_char_whitespace_p (chr)
Return @code{#t} iff @var{chr} is whitespace, else @code{#f}.
Whitespace means the same thing as the isspace C library function.
@end deffn

char-upper-case?
@deffn {Scheme Procedure} char-upper-case? chr
@deffnx {C Function} scm_char_upper_case_p (chr)
Return @code{#t} iff @var{chr} is uppercase, else @code{#f}.
Uppercase means the same thing as the isupper C library function.
@end deffn

char-lower-case?
@deffn {Scheme Procedure} char-lower-case? chr
@deffnx {C Function} scm_char_lower_case_p (chr)
Return @code{#t} iff @var{chr} is lowercase, else @code{#f}.
Lowercase means the same thing as the islower C library function.
@end deffn

char-is-both?
@deffn {Scheme Procedure} char-is-both? chr
@deffnx {C Function} scm_char_is_both_p (chr)
Return @code{#t} iff @var{chr} is either uppercase or lowercase, else @code{#f}.
Uppercase and lowercase are as defined by the isupper and islower
C library functions.
@end deffn

char->integer
@deffn {Scheme Procedure} char->integer chr
@deffnx {C Function} scm_char_to_integer (chr)
Return the number corresponding to ordinal position of @var{chr} in the
ASCII sequence.
@end deffn

integer->char
@deffn {Scheme Procedure} integer->char n
@deffnx {C Function} scm_integer_to_char (n)
Return the character at position @var{n} in the ASCII sequence.
@end deffn

char-upcase
@deffn {Scheme Procedure} char-upcase chr
@deffnx {C Function} scm_char_upcase (chr)
Return the uppercase character version of @var{chr}.
@end deffn

char-downcase
@deffn {Scheme Procedure} char-downcase chr
@deffnx {C Function} scm_char_downcase (chr)
Return the lowercase character version of @var{chr}.
@end deffn

debug-options-interface
@deffn {Scheme Procedure} debug-options-interface [setting]
@deffnx {C Function} scm_debug_options (setting)
Option interface for the debug options. Instead of using
this procedure directly, use the procedures @code{debug-enable},
@code{debug-disable}, @code{debug-set!} and @code{debug-options}.
@end deffn

with-traps
@deffn {Scheme Procedure} with-traps thunk
@deffnx {C Function} scm_with_traps (thunk)
Call @var{thunk} with traps enabled.
@end deffn

memoized?
@deffn {Scheme Procedure} memoized? obj
@deffnx {C Function} scm_memoized_p (obj)
Return @code{#t} if @var{obj} is memoized.
@end deffn

unmemoize
@deffn {Scheme Procedure} unmemoize m
@deffnx {C Function} scm_unmemoize (m)
Unmemoize the memoized expression @var{m},
@end deffn

memoized-environment
@deffn {Scheme Procedure} memoized-environment m
@deffnx {C Function} scm_memoized_environment (m)
Return the environment of the memoized expression @var{m}.
@end deffn

procedure-name
@deffn {Scheme Procedure} procedure-name proc
@deffnx {C Function} scm_procedure_name (proc)
Return the name of the procedure @var{proc}
@end deffn

procedure-source
@deffn {Scheme Procedure} procedure-source proc
@deffnx {C Function} scm_procedure_source (proc)
Return the source of the procedure @var{proc}.
@end deffn

procedure-environment
@deffn {Scheme Procedure} procedure-environment proc
@deffnx {C Function} scm_procedure_environment (proc)
Return the environment of the procedure @var{proc}.
@end deffn

local-eval
@deffn {Scheme Procedure} local-eval exp [env]
@deffnx {C Function} scm_local_eval (exp, env)
Evaluate @var{exp} in its environment.  If @var{env} is supplied,
it is the environment in which to evaluate @var{exp}.  Otherwise,
@var{exp} must be a memoized code object (in which case, its environment
is implicit).
@end deffn

debug-object?
@deffn {Scheme Procedure} debug-object? obj
@deffnx {C Function} scm_debug_object_p (obj)
Return @code{#t} if @var{obj} is a debug object.
@end deffn

dynamic-link
@deffn {Scheme Procedure} dynamic-link filename
@deffnx {C Function} scm_dynamic_link (filename)
Find the shared object (shared library) denoted by
@var{filename} and link it into the running Guile
application.  The returned
scheme object is a ``handle'' for the library which can
be passed to @code{dynamic-func}, @code{dynamic-call} etc.

Searching for object files is system dependent.  Normally,
if @var{filename} does have an explicit directory it will
be searched for in locations
such as @file{/usr/lib} and @file{/usr/local/lib}.
@end deffn

dynamic-object?
@deffn {Scheme Procedure} dynamic-object? obj
@deffnx {C Function} scm_dynamic_object_p (obj)
Return @code{#t} if @var{obj} is a dynamic object handle,
or @code{#f} otherwise.
@end deffn

dynamic-unlink
@deffn {Scheme Procedure} dynamic-unlink dobj
@deffnx {C Function} scm_dynamic_unlink (dobj)
Unlink a dynamic object from the application, if possible.  The
object must have been linked by @code{dynamic-link}, with 
@var{dobj} the corresponding handle.  After this procedure
is called, the handle can no longer be used to access the
object.
@end deffn

dynamic-func
@deffn {Scheme Procedure} dynamic-func name dobj
@deffnx {C Function} scm_dynamic_func (name, dobj)
Return a ``handle'' for the function @var{name} in the
shared object referred to by @var{dobj}.  The handle
can be passed to @code{dynamic-call} to actually
call the function.

Regardless whether your C compiler prepends an underscore
@samp{_} to the global names in a program, you should
@strong{not} include this underscore in @var{name}
since it will be added automatically when necessary.
@end deffn

dynamic-call
@deffn {Scheme Procedure} dynamic-call func dobj
@deffnx {C Function} scm_dynamic_call (func, dobj)
Call a C function in a dynamic object.  Two styles of
invocation are supported:

@itemize @bullet
@item @var{func} can be a function handle returned by
@code{dynamic-func}.  In this case @var{dobj} is
ignored
@item @var{func} can be a string with the name of the
function to call, with @var{dobj} the handle of the
dynamic object in which to find the function.
This is equivalent to
@smallexample

(dynamic-call (dynamic-func @var{func} @var{dobj}) #f)
@end smallexample
@end itemize

In either case, the function is passed no arguments
and its return value is ignored.
@end deffn

dynamic-args-call
@deffn {Scheme Procedure} dynamic-args-call func dobj args
@deffnx {C Function} scm_dynamic_args_call (func, dobj, args)
Call the C function indicated by @var{func} and @var{dobj},
just like @code{dynamic-call}, but pass it some arguments and
return its return value.  The C function is expected to take
two arguments and return an @code{int}, just like @code{main}:
@smallexample
int c_func (int argc, char **argv);
@end smallexample

The parameter @var{args} must be a list of strings and is
converted into an array of @code{char *}.  The array is passed
in @var{argv} and its size in @var{argc}.  The return value is
converted to a Scheme number and returned from the call to
@code{dynamic-args-call}.
@end deffn

dynamic-wind
@deffn {Scheme Procedure} dynamic-wind in_guard thunk out_guard
@deffnx {C Function} scm_dynamic_wind (in_guard, thunk, out_guard)
All three arguments must be 0-argument procedures.
@var{in_guard} is called, then @var{thunk}, then
@var{out_guard}.

If, any time during the execution of @var{thunk}, the
continuation of the @code{dynamic_wind} expression is escaped
non-locally, @var{out_guard} is called.  If the continuation of
the dynamic-wind is re-entered, @var{in_guard} is called.  Thus
@var{in_guard} and @var{out_guard} may be called any number of
times.
@lisp
(define x 'normal-binding)
@result{} x
(define a-cont  (call-with-current-continuation
		  (lambda (escape)
		     (let ((old-x x))
		       (dynamic-wind
			  ;; in-guard:
			  ;;
			  (lambda () (set! x 'special-binding))

			  ;; thunk
			  ;;
		 	  (lambda () (display x) (newline)
				     (call-with-current-continuation escape)
				     (display x) (newline)
				     x)

			  ;; out-guard:
			  ;;
			  (lambda () (set! x old-x)))))))

;; Prints:
special-binding
;; Evaluates to:
@result{} a-cont
x
@result{} normal-binding
(a-cont #f)
;; Prints:
special-binding
;; Evaluates to:
@result{} a-cont  ;; the value of the (define a-cont...)
x
@result{} normal-binding
a-cont
@result{} special-binding
@end lisp
@end deffn

environment?
@deffn {Scheme Procedure} environment? obj
@deffnx {C Function} scm_environment_p (obj)
Return @code{#t} if @var{obj} is an environment, or @code{#f}
otherwise.
@end deffn

environment-bound?
@deffn {Scheme Procedure} environment-bound? env sym
@deffnx {C Function} scm_environment_bound_p (env, sym)
Return @code{#t} if @var{sym} is bound in @var{env}, or
@code{#f} otherwise.
@end deffn

environment-ref
@deffn {Scheme Procedure} environment-ref env sym
@deffnx {C Function} scm_environment_ref (env, sym)
Return the value of the location bound to @var{sym} in
@var{env}. If @var{sym} is unbound in @var{env}, signal an
@code{environment:unbound} error.
@end deffn

environment-fold
@deffn {Scheme Procedure} environment-fold env proc init
@deffnx {C Function} scm_environment_fold (env, proc, init)
Iterate over all the bindings in @var{env}, accumulating some
value.
For each binding in @var{env}, apply @var{proc} to the symbol
bound, its value, and the result from the previous application
of @var{proc}.
Use @var{init} as @var{proc}'s third argument the first time
@var{proc} is applied.
If @var{env} contains no bindings, this function simply returns
@var{init}.
If @var{env} binds the symbol sym1 to the value val1, sym2 to
val2, and so on, then this procedure computes:
@lisp
  (proc sym1 val1
        (proc sym2 val2
              ...
              (proc symn valn
                    init)))
@end lisp
Each binding in @var{env} will be processed exactly once.
@code{environment-fold} makes no guarantees about the order in
which the bindings are processed.
Here is a function which, given an environment, constructs an
association list representing that environment's bindings,
using environment-fold:
@lisp
  (define (environment->alist env)
    (environment-fold env
                      (lambda (sym val tail)
                        (cons (cons sym val) tail))
                      '()))
@end lisp
@end deffn

environment-define
@deffn {Scheme Procedure} environment-define env sym val
@deffnx {C Function} scm_environment_define (env, sym, val)
Bind @var{sym} to a new location containing @var{val} in
@var{env}. If @var{sym} is already bound to another location
in @var{env} and the binding is mutable, that binding is
replaced.  The new binding and location are both mutable. The
return value is unspecified.
If @var{sym} is already bound in @var{env}, and the binding is
immutable, signal an @code{environment:immutable-binding} error.
@end deffn

environment-undefine
@deffn {Scheme Procedure} environment-undefine env sym
@deffnx {C Function} scm_environment_undefine (env, sym)
Remove any binding for @var{sym} from @var{env}. If @var{sym}
is unbound in @var{env}, do nothing.  The return value is
unspecified.
If @var{sym} is already bound in @var{env}, and the binding is
immutable, signal an @code{environment:immutable-binding} error.
@end deffn

environment-set!
@deffn {Scheme Procedure} environment-set! env sym val
@deffnx {C Function} scm_environment_set_x (env, sym, val)
If @var{env} binds @var{sym} to some location, change that
location's value to @var{val}.  The return value is
unspecified.
If @var{sym} is not bound in @var{env}, signal an
@code{environment:unbound} error.  If @var{env} binds @var{sym}
to an immutable location, signal an
@code{environment:immutable-location} error.
@end deffn

environment-cell
@deffn {Scheme Procedure} environment-cell env sym for_write
@deffnx {C Function} scm_environment_cell (env, sym, for_write)
Return the value cell which @var{env} binds to @var{sym}, or
@code{#f} if the binding does not live in a value cell.
The argument @var{for-write} indicates whether the caller
intends to modify the variable's value by mutating the value
cell.  If the variable is immutable, then
@code{environment-cell} signals an
@code{environment:immutable-location} error.
If @var{sym} is unbound in @var{env}, signal an
@code{environment:unbound} error.
If you use this function, you should consider using
@code{environment-observe}, to be notified when @var{sym} gets
re-bound to a new value cell, or becomes undefined.
@end deffn

environment-observe
@deffn {Scheme Procedure} environment-observe env proc
@deffnx {C Function} scm_environment_observe (env, proc)
Whenever @var{env}'s bindings change, apply @var{proc} to
@var{env}.
This function returns an object, token, which you can pass to
@code{environment-unobserve} to remove @var{proc} from the set
of procedures observing @var{env}.  The type and value of
token is unspecified.
@end deffn

environment-observe-weak
@deffn {Scheme Procedure} environment-observe-weak env proc
@deffnx {C Function} scm_environment_observe_weak (env, proc)
This function is the same as environment-observe, except that
the reference @var{env} retains to @var{proc} is a weak
reference. This means that, if there are no other live,
non-weak references to @var{proc}, it will be
garbage-collected, and dropped from @var{env}'s
list of observing procedures.
@end deffn

environment-unobserve
@deffn {Scheme Procedure} environment-unobserve token
@deffnx {C Function} scm_environment_unobserve (token)
Cancel the observation request which returned the value
@var{token}.  The return value is unspecified.
If a call @code{(environment-observe env proc)} returns
@var{token}, then the call @code{(environment-unobserve token)}
will cause @var{proc} to no longer be called when @var{env}'s
bindings change.
@end deffn

make-leaf-environment
@deffn {Scheme Procedure} make-leaf-environment
@deffnx {C Function} scm_make_leaf_environment ()
Create a new leaf environment, containing no bindings.
All bindings and locations created in the new environment
will be mutable.
@end deffn

leaf-environment?
@deffn {Scheme Procedure} leaf-environment? object
@deffnx {C Function} scm_leaf_environment_p (object)
Return @code{#t} if object is a leaf environment, or @code{#f}
otherwise.
@end deffn

make-eval-environment
@deffn {Scheme Procedure} make-eval-environment local imported
@deffnx {C Function} scm_make_eval_environment (local, imported)
Return a new environment object eval whose bindings are the
union of the bindings in the environments @var{local} and
@var{imported}, with bindings from @var{local} taking
precedence. Definitions made in eval are placed in @var{local}.
Applying @code{environment-define} or
@code{environment-undefine} to eval has the same effect as
applying the procedure to @var{local}.
Note that eval incorporates @var{local} and @var{imported} by
reference:
If, after creating eval, the program changes the bindings of
@var{local} or @var{imported}, those changes will be visible
in eval.
Since most Scheme evaluation takes place in eval environments,
they transparently cache the bindings received from @var{local}
and @var{imported}. Thus, the first time the program looks up
a symbol in eval, eval may make calls to @var{local} or
@var{imported} to find their bindings, but subsequent
references to that symbol will be as fast as references to
bindings in finite environments.
In typical use, @var{local} will be a finite environment, and
@var{imported} will be an import environment
@end deffn

eval-environment?
@deffn {Scheme Procedure} eval-environment? object
@deffnx {C Function} scm_eval_environment_p (object)
Return @code{#t} if object is an eval environment, or @code{#f}
otherwise.
@end deffn

eval-environment-local
@deffn {Scheme Procedure} eval-environment-local env
@deffnx {C Function} scm_eval_environment_local (env)
Return the local environment of eval environment @var{env}.
@end deffn

eval-environment-set-local!
@deffn {Scheme Procedure} eval-environment-set-local! env local
@deffnx {C Function} scm_eval_environment_set_local_x (env, local)
Change @var{env}'s local environment to @var{local}.
@end deffn

eval-environment-imported
@deffn {Scheme Procedure} eval-environment-imported env
@deffnx {C Function} scm_eval_environment_imported (env)
Return the imported environment of eval environment @var{env}.
@end deffn

eval-environment-set-imported!
@deffn {Scheme Procedure} eval-environment-set-imported! env imported
@deffnx {C Function} scm_eval_environment_set_imported_x (env, imported)
Change @var{env}'s imported environment to @var{imported}.
@end deffn

make-import-environment
@deffn {Scheme Procedure} make-import-environment imports conflict_proc
@deffnx {C Function} scm_make_import_environment (imports, conflict_proc)
Return a new environment @var{imp} whose bindings are the union
of the bindings from the environments in @var{imports};
@var{imports} must be a list of environments. That is,
@var{imp} binds a symbol to a location when some element of
@var{imports} does.
If two different elements of @var{imports} have a binding for
the same symbol, the @var{conflict-proc} is called with the
following parameters:  the import environment, the symbol and
the list of the imported environments that bind the symbol.
If the @var{conflict-proc} returns an environment @var{env},
the conflict is considered as resolved and the binding from
@var{env} is used.  If the @var{conflict-proc} returns some
non-environment object, the conflict is considered unresolved
and the symbol is treated as unspecified in the import
environment.
The checking for conflicts may be performed lazily, i. e. at
the moment when a value or binding for a certain symbol is
requested instead of the moment when the environment is
created or the bindings of the imports change.
All bindings in @var{imp} are immutable. If you apply
@code{environment-define} or @code{environment-undefine} to
@var{imp}, Guile will signal an
 @code{environment:immutable-binding} error. However,
notice that the set of bindings in @var{imp} may still change,
if one of its imported environments changes.
@end deffn

import-environment?
@deffn {Scheme Procedure} import-environment? object
@deffnx {C Function} scm_import_environment_p (object)
Return @code{#t} if object is an import environment, or
@code{#f} otherwise.
@end deffn

import-environment-imports
@deffn {Scheme Procedure} import-environment-imports env
@deffnx {C Function} scm_import_environment_imports (env)
Return the list of environments imported by the import
environment @var{env}.
@end deffn

import-environment-set-imports!
@deffn {Scheme Procedure} import-environment-set-imports! env imports
@deffnx {C Function} scm_import_environment_set_imports_x (env, imports)
Change @var{env}'s list of imported environments to
@var{imports}, and check for conflicts.
@end deffn

make-export-environment
@deffn {Scheme Procedure} make-export-environment private signature
@deffnx {C Function} scm_make_export_environment (private, signature)
Return a new environment @var{exp} containing only those
bindings in private whose symbols are present in
@var{signature}. The @var{private} argument must be an
environment.

The environment @var{exp} binds symbol to location when
@var{env} does, and symbol is exported by @var{signature}.

@var{signature} is a list specifying which of the bindings in
@var{private} should be visible in @var{exp}. Each element of
@var{signature} should be a list of the form:
  (symbol attribute ...)
where each attribute is one of the following:
@table @asis
@item the symbol @code{mutable-location}
  @var{exp} should treat the
  location bound to symbol as mutable. That is, @var{exp}
  will pass calls to @code{environment-set!} or
  @code{environment-cell} directly through to private.
@item the symbol @code{immutable-location}
  @var{exp} should treat
  the location bound to symbol as immutable. If the program
  applies @code{environment-set!} to @var{exp} and symbol, or
  calls @code{environment-cell} to obtain a writable value
  cell, @code{environment-set!} will signal an
  @code{environment:immutable-location} error. Note that, even
  if an export environment treats a location as immutable, the
  underlying environment may treat it as mutable, so its
  value may change.
@end table
It is an error for an element of signature to specify both
@code{mutable-location} and @code{immutable-location}. If
neither is specified, @code{immutable-location} is assumed.

As a special case, if an element of signature is a lone
symbol @var{sym}, it is equivalent to an element of the form
@code{(sym)}.

All bindings in @var{exp} are immutable. If you apply
@code{environment-define} or @code{environment-undefine} to
@var{exp}, Guile will signal an
@code{environment:immutable-binding} error. However,
notice that the set of bindings in @var{exp} may still change,
if the bindings in private change.
@end deffn

export-environment?
@deffn {Scheme Procedure} export-environment? object
@deffnx {C Function} scm_export_environment_p (object)
Return @code{#t} if object is an export environment, or
@code{#f} otherwise.
@end deffn

export-environment-private
@deffn {Scheme Procedure} export-environment-private env
@deffnx {C Function} scm_export_environment_private (env)
Return the private environment of export environment @var{env}.
@end deffn

export-environment-set-private!
@deffn {Scheme Procedure} export-environment-set-private! env private
@deffnx {C Function} scm_export_environment_set_private_x (env, private)
Change the private environment of export environment @var{env}.
@end deffn

export-environment-signature
@deffn {Scheme Procedure} export-environment-signature env
@deffnx {C Function} scm_export_environment_signature (env)
Return the signature of export environment @var{env}.
@end deffn

export-environment-set-signature!
@deffn {Scheme Procedure} export-environment-set-signature! env signature
@deffnx {C Function} scm_export_environment_set_signature_x (env, signature)
Change the signature of export environment @var{env}.
@end deffn

eq?
@deffn {Scheme Procedure} eq? x y
Return @code{#t} iff @var{x} references the same object as @var{y}.
@code{eq?} is similar to @code{eqv?} except that in some cases it is
capable of discerning distinctions finer than those detectable by
@code{eqv?}.
@end deffn

eqv?
@deffn {Scheme Procedure} eqv? x y
The @code{eqv?} procedure defines a useful equivalence relation on objects.
Briefly, it returns @code{#t} if @var{x} and @var{y} should normally be
regarded as the same object.  This relation is left slightly open to
interpretation, but works for comparing immediate integers, characters,
and inexact numbers.
@end deffn

equal?
@deffn {Scheme Procedure} equal? x y
Return @code{#t} iff @var{x} and @var{y} are recursively @code{eqv?} equivalent.
@code{equal?} recursively compares the contents of pairs,
vectors, and strings, applying @code{eqv?} on other objects such as
numbers and symbols.  A rule of thumb is that objects are generally
@code{equal?}  if they print the same.  @code{equal?} may fail to
terminate if its arguments are circular data structures.
@end deffn

scm-error
@deffn {Scheme Procedure} scm-error key subr message args data
@deffnx {C Function} scm_error_scm (key, subr, message, args, data)
Raise an error with key @var{key}.  @var{subr} can be a string
naming the procedure associated with the error, or @code{#f}.
@var{message} is the error message string, possibly containing
@code{~S} and @code{~A} escapes.  When an error is reported,
these are replaced by formatting the corresponding members of
@var{args}: @code{~A} (was @code{%s} in older versions of
Guile) formats using @code{display} and @code{~S} (was
@code{%S}) formats using @code{write}.  @var{data} is a list or
@code{#f} depending on @var{key}: if @var{key} is
@code{system-error} then it should be a list containing the
Unix @code{errno} value; If @var{key} is @code{signal} then it
should be a list containing the Unix signal number; otherwise
it will usually be @code{#f}.
@end deffn

strerror
@deffn {Scheme Procedure} strerror err
@deffnx {C Function} scm_strerror (err)
Return the Unix error message corresponding to @var{err}, which
must be an integer value.
@end deffn

apply:nconc2last
@deffn {Scheme Procedure} apply:nconc2last lst
@deffnx {C Function} scm_nconc2last (lst)
Given a list (@var{arg1} @dots{} @var{args}), this function
conses the @var{arg1} @dots{} arguments onto the front of
@var{args}, and returns the resulting list. Note that
@var{args} is a list; thus, the argument to this function is
a list whose last element is a list.
Note: Rather than do new consing, @code{apply:nconc2last}
destroys its argument, so use with care.
@end deffn

force
@deffn {Scheme Procedure} force x
@deffnx {C Function} scm_force (x)
If the promise @var{x} has not been computed yet, compute and
return @var{x}, otherwise just return the previously computed
value.
@end deffn

promise?
@deffn {Scheme Procedure} promise? obj
@deffnx {C Function} scm_promise_p (obj)
Return true if @var{obj} is a promise, i.e. a delayed computation
(@pxref{Delayed evaluation,,,r5rs.info,The Revised^5 Report on Scheme}).
@end deffn

cons-source
@deffn {Scheme Procedure} cons-source xorig x y
@deffnx {C Function} scm_cons_source (xorig, x, y)
Create and return a new pair whose car and cdr are @var{x} and @var{y}.
Any source properties associated with @var{xorig} are also associated
with the new pair.
@end deffn

copy-tree
@deffn {Scheme Procedure} copy-tree obj
@deffnx {C Function} scm_copy_tree (obj)
Recursively copy the data tree that is bound to @var{obj}, and return a
pointer to the new data structure.  @code{copy-tree} recurses down the
contents of both pairs and vectors (since both cons cells and vector
cells may point to arbitrary objects), and stops recursing when it hits
any other object.
@end deffn

primitive-eval
@deffn {Scheme Procedure} primitive-eval exp
@deffnx {C Function} scm_primitive_eval (exp)
Evaluate @var{exp} in the top-level environment specified by
the current module.
@end deffn

eval
@deffn {Scheme Procedure} eval exp module
@deffnx {C Function} scm_eval (exp, module)
Evaluate @var{exp}, a list representing a Scheme expression,
in the top-level environment specified by @var{module}.
While @var{exp} is evaluated (using @code{primitive-eval}),
@var{module} is made the current module.  The current module
is reset to its previous value when @var{eval} returns.
@end deffn

eval-options-interface
@deffn {Scheme Procedure} eval-options-interface [setting]
@deffnx {C Function} scm_eval_options_interface (setting)
Option interface for the evaluation options. Instead of using
this procedure directly, use the procedures @code{eval-enable},
@code{eval-disable}, @code{eval-set!} and @code{eval-options}.
@end deffn

evaluator-traps-interface
@deffn {Scheme Procedure} evaluator-traps-interface [setting]
@deffnx {C Function} scm_evaluator_traps (setting)
Option interface for the evaluator trap options.
@end deffn

defined?
@deffn {Scheme Procedure} defined? sym [env]
@deffnx {C Function} scm_defined_p (sym, env)
Return @code{#t} if @var{sym} is defined in the lexical environment @var{env}.  When @var{env} is not specified, look in the top-level environment as defined by the current module.
@end deffn

map-in-order
@deffn {Scheme Procedure} map-in-order
implemented by the C function "scm_map"
@end deffn

load-extension
@deffn {Scheme Procedure} load-extension lib init
@deffnx {C Function} scm_load_extension (lib, init)
Load and initialize the extension designated by LIB and INIT.
When there is no pre-registered function for LIB/INIT, this is
equivalent to

@lisp
(dynamic-call INIT (dynamic-link LIB))
@end lisp

When there is a pre-registered function, that function is called
instead.

Normally, there is no pre-registered function.  This option exists
only for situations where dynamic linking is unavailable or unwanted.
In that case, you would statically link your program with the desired
library, and register its init function right after Guile has been
initialized.

LIB should be a string denoting a shared library without any file type
suffix such as ".so".  The suffix is provided automatically.  It
should also not contain any directory components.  Libraries that
implement Guile Extensions should be put into the normal locations for
shared libraries.  We recommend to use the naming convention
libguile-bla-blum for a extension related to a module `(bla blum)'.

The normal way for a extension to be used is to write a small Scheme
file that defines a module, and to load the extension into this
module.  When the module is auto-loaded, the extension is loaded as
well.  For example,

@lisp
(define-module (bla blum))

(load-extension "libguile-bla-blum" "bla_init_blum")
@end lisp
@end deffn

program-arguments
@deffn {Scheme Procedure} program-arguments
@deffnx {Scheme Procedure} command-line
@deffnx {C Function} scm_program_arguments ()
Return the list of command line arguments passed to Guile, as a list of
strings.  The list includes the invoked program name, which is usually
@code{"guile"}, but excludes switches and parameters for command line
options like @code{-e} and @code{-l}.
@end deffn

make-fluid
@deffn {Scheme Procedure} make-fluid
@deffnx {C Function} scm_make_fluid ()
Return a newly created fluid.
Fluids are objects of a certain type (a smob) that can hold one SCM
value per dynamic root.  That is, modifications to this value are
only visible to code that executes within the same dynamic root as
the modifying code.  When a new dynamic root is constructed, it
inherits the values from its parent.  Because each thread executes
in its own dynamic root, you can use fluids for thread local storage.
@end deffn

fluid?
@deffn {Scheme Procedure} fluid? obj
@deffnx {C Function} scm_fluid_p (obj)
Return @code{#t} iff @var{obj} is a fluid; otherwise, return
@code{#f}.
@end deffn

fluid-ref
@deffn {Scheme Procedure} fluid-ref fluid
@deffnx {C Function} scm_fluid_ref (fluid)
Return the value associated with @var{fluid} in the current
dynamic root.  If @var{fluid} has not been set, then return
@code{#f}.
@end deffn

fluid-set!
@deffn {Scheme Procedure} fluid-set! fluid value
@deffnx {C Function} scm_fluid_set_x (fluid, value)
Set the value associated with @var{fluid} in the current dynamic root.
@end deffn

with-fluids*
@deffn {Scheme Procedure} with-fluids* fluids values thunk
@deffnx {C Function} scm_with_fluids (fluids, values, thunk)
Set @var{fluids} to @var{values} temporary, and call @var{thunk}.
@var{fluids} must be a list of fluids and @var{values} must be the same
number of their values to be applied.  Each substitution is done
one after another.  @var{thunk} must be a procedure with no argument.
@end deffn

setvbuf
@deffn {Scheme Procedure} setvbuf port mode [size]
@deffnx {C Function} scm_setvbuf (port, mode, size)
Set the buffering mode for @var{port}.  @var{mode} can be:
@table @code
@item _IONBF
non-buffered
@item _IOLBF
line buffered
@item _IOFBF
block buffered, using a newly allocated buffer of @var{size} bytes.
If @var{size} is omitted, a default size will be used.
@end table
@end deffn

file-port?
@deffn {Scheme Procedure} file-port? obj
@deffnx {C Function} scm_file_port_p (obj)
Determine whether @var{obj} is a port that is related to a file.
@end deffn

open-file
@deffn {Scheme Procedure} open-file filename mode
@deffnx {C Function} scm_open_file (filename, mode)
Open the file whose name is @var{filename}, and return a port
representing that file.  The attributes of the port are
determined by the @var{mode} string.  The way in which this is
interpreted is similar to C stdio.  The first character must be
one of the following:
@table @samp
@item r
Open an existing file for input.
@item w
Open a file for output, creating it if it doesn't already exist
or removing its contents if it does.
@item a
Open a file for output, creating it if it doesn't already
exist.  All writes to the port will go to the end of the file.
The "append mode" can be turned off while the port is in use
@pxref{Ports and File Descriptors, fcntl}
@end table
The following additional characters can be appended:
@table @samp
@item +
Open the port for both input and output.  E.g., @code{r+}: open
an existing file for both input and output.
@item 0
Create an "unbuffered" port.  In this case input and output
operations are passed directly to the underlying port
implementation without additional buffering.  This is likely to
slow down I/O operations.  The buffering mode can be changed
while a port is in use @pxref{Ports and File Descriptors,
setvbuf}
@item l
Add line-buffering to the port.  The port output buffer will be
automatically flushed whenever a newline character is written.
@end table
In theory we could create read/write ports which were buffered
in one direction only.  However this isn't included in the
current interfaces.  If a file cannot be opened with the access
requested, @code{open-file} throws an exception.
@end deffn

set-debug-cell-accesses!
@deffn {Scheme Procedure} set-debug-cell-accesses! flag
@deffnx {C Function} scm_set_debug_cell_accesses_x (flag)
This function is used to turn on checking for a debug version of GUILE. This version does not support this functionality

@end deffn

gc-stats
@deffn {Scheme Procedure} gc-stats
@deffnx {C Function} scm_gc_stats ()
Return an association list of statistics about Guile's current
use of storage.

@end deffn

object-address
@deffn {Scheme Procedure} object-address obj
@deffnx {C Function} scm_object_address (obj)
Return an integer that for the lifetime of @var{obj} is uniquely
returned by this function for @var{obj}
@end deffn

gc
@deffn {Scheme Procedure} gc
@deffnx {C Function} scm_gc ()
Scans all of SCM objects and reclaims for further use those that are
no longer accessible.
@end deffn

%compute-slots
@deffn {Scheme Procedure} %compute-slots class
@deffnx {C Function} scm_sys_compute_slots (class)
Return a list consisting of the names of all slots belonging to
class @var{class}, i. e. the slots of @var{class} and of all of
its superclasses.
@end deffn

get-keyword
@deffn {Scheme Procedure} get-keyword key l default_value
@deffnx {C Function} scm_get_keyword (key, l, default_value)
Determine an associated value for the keyword @var{key} from
the list @var{l}.  The list @var{l} has to consist of an even
number of elements, where, starting with the first, every
second element is a keyword, followed by its associated value.
If @var{l} does not hold a value for @var{key}, the value
@var{default_value} is returned.
@end deffn

%initialize-object
@deffn {Scheme Procedure} %initialize-object obj initargs
@deffnx {C Function} scm_sys_initialize_object (obj, initargs)
Initialize the object @var{obj} with the given arguments
@var{initargs}.
@end deffn

%prep-layout!
@deffn {Scheme Procedure} %prep-layout! class
@deffnx {C Function} scm_sys_prep_layout_x (class)

@end deffn

%inherit-magic!
@deffn {Scheme Procedure} %inherit-magic! class dsupers
@deffnx {C Function} scm_sys_inherit_magic_x (class, dsupers)

@end deffn

instance?
@deffn {Scheme Procedure} instance? obj
@deffnx {C Function} scm_instance_p (obj)
Return @code{#t} if @var{obj} is an instance.
@end deffn

class-name
@deffn {Scheme Procedure} class-name obj
@deffnx {C Function} scm_class_name (obj)
Return the class name of @var{obj}.
@end deffn

class-direct-supers
@deffn {Scheme Procedure} class-direct-supers obj
@deffnx {C Function} scm_class_direct_supers (obj)
Return the direct superclasses of the class @var{obj}.
@end deffn

class-direct-slots
@deffn {Scheme Procedure} class-direct-slots obj
@deffnx {C Function} scm_class_direct_slots (obj)
Return the direct slots of the class @var{obj}.
@end deffn

class-direct-subclasses
@deffn {Scheme Procedure} class-direct-subclasses obj
@deffnx {C Function} scm_class_direct_subclasses (obj)
Return the direct subclasses of the class @var{obj}.
@end deffn

class-direct-methods
@deffn {Scheme Procedure} class-direct-methods obj
@deffnx {C Function} scm_class_direct_methods (obj)
Return the direct methods of the class @var{obj}
@end deffn

class-precedence-list
@deffn {Scheme Procedure} class-precedence-list obj
@deffnx {C Function} scm_class_precedence_list (obj)
Return the class precedence list of the class @var{obj}.
@end deffn

class-slots
@deffn {Scheme Procedure} class-slots obj
@deffnx {C Function} scm_class_slots (obj)
Return the slot list of the class @var{obj}.
@end deffn

class-environment
@deffn {Scheme Procedure} class-environment obj
@deffnx {C Function} scm_class_environment (obj)
Return the environment of the class @var{obj}.
@end deffn

generic-function-name
@deffn {Scheme Procedure} generic-function-name obj
@deffnx {C Function} scm_generic_function_name (obj)
Return the name of the generic function @var{obj}.
@end deffn

generic-function-methods
@deffn {Scheme Procedure} generic-function-methods obj
@deffnx {C Function} scm_generic_function_methods (obj)
Return the methods of the generic function @var{obj}.
@end deffn

method-generic-function
@deffn {Scheme Procedure} method-generic-function obj
@deffnx {C Function} scm_method_generic_function (obj)
Return the generic function for the method @var{obj}.
@end deffn

method-specializers
@deffn {Scheme Procedure} method-specializers obj
@deffnx {C Function} scm_method_specializers (obj)
Return specializers of the method @var{obj}.
@end deffn

method-procedure
@deffn {Scheme Procedure} method-procedure obj
@deffnx {C Function} scm_method_procedure (obj)
Return the procedure of the method @var{obj}.
@end deffn

accessor-method-slot-definition
@deffn {Scheme Procedure} accessor-method-slot-definition obj
@deffnx {C Function} scm_accessor_method_slot_definition (obj)
Return the slot definition of the accessor @var{obj}.
@end deffn

%tag-body
@deffn {Scheme Procedure} %tag-body body
@deffnx {C Function} scm_sys_tag_body (body)
Internal GOOPS magic---don't use this function!
@end deffn

make-unbound
@deffn {Scheme Procedure} make-unbound
@deffnx {C Function} scm_make_unbound ()
Return the unbound value.
@end deffn

unbound?
@deffn {Scheme Procedure} unbound? obj
@deffnx {C Function} scm_unbound_p (obj)
Return @code{#t} if @var{obj} is unbound.
@end deffn

assert-bound
@deffn {Scheme Procedure} assert-bound value obj
@deffnx {C Function} scm_assert_bound (value, obj)
Return @var{value} if it is bound, and invoke the
@var{slot-unbound} method of @var{obj} if it is not.
@end deffn

@@assert-bound-ref
@deffn {Scheme Procedure} @@assert-bound-ref obj index
@deffnx {C Function} scm_at_assert_bound_ref (obj, index)
Like @code{assert-bound}, but use @var{index} for accessing
the value from @var{obj}.
@end deffn

%fast-slot-ref
@deffn {Scheme Procedure} %fast-slot-ref obj index
@deffnx {C Function} scm_sys_fast_slot_ref (obj, index)
Return the slot value with index @var{index} from @var{obj}.
@end deffn

%fast-slot-set!
@deffn {Scheme Procedure} %fast-slot-set! obj index value
@deffnx {C Function} scm_sys_fast_slot_set_x (obj, index, value)
Set the slot with index @var{index} in @var{obj} to
@var{value}.
@end deffn

slot-ref-using-class
@deffn {Scheme Procedure} slot-ref-using-class class obj slot_name
@deffnx {C Function} scm_slot_ref_using_class (class, obj, slot_name)

@end deffn

slot-set-using-class!
@deffn {Scheme Procedure} slot-set-using-class! class obj slot_name value
@deffnx {C Function} scm_slot_set_using_class_x (class, obj, slot_name, value)

@end deffn

slot-bound-using-class?
@deffn {Scheme Procedure} slot-bound-using-class? class obj slot_name
@deffnx {C Function} scm_slot_bound_using_class_p (class, obj, slot_name)

@end deffn

slot-exists-using-class?
@deffn {Scheme Procedure} slot-exists-using-class? class obj slot_name
@deffnx {C Function} scm_slot_exists_using_class_p (class, obj, slot_name)

@end deffn

slot-ref
@deffn {Scheme Procedure} slot-ref obj slot_name
@deffnx {C Function} scm_slot_ref (obj, slot_name)
Return the value from @var{obj}'s slot with the name
@var{slot_name}.
@end deffn

slot-set!
@deffn {Scheme Procedure} slot-set! obj slot_name value
@deffnx {C Function} scm_slot_set_x (obj, slot_name, value)
Set the slot named @var{slot_name} of @var{obj} to @var{value}.
@end deffn

slot-bound?
@deffn {Scheme Procedure} slot-bound? obj slot_name
@deffnx {C Function} scm_slot_bound_p (obj, slot_name)
Return @code{#t} if the slot named @var{slot_name} of @var{obj}
is bound.
@end deffn

slot-exists?
@deffn {Scheme Procedure} slot-exists? obj slot_name
@deffnx {C Function} scm_slot_exists_p (obj, slot_name)
Return @code{#t} if @var{obj} has a slot named @var{slot_name}.
@end deffn

%allocate-instance
@deffn {Scheme Procedure} %allocate-instance class initargs
@deffnx {C Function} scm_sys_allocate_instance (class, initargs)
Create a new instance of class @var{class} and initialize it
from the arguments @var{initargs}.
@end deffn

%set-object-setter!
@deffn {Scheme Procedure} %set-object-setter! obj setter
@deffnx {C Function} scm_sys_set_object_setter_x (obj, setter)

@end deffn

%modify-instance
@deffn {Scheme Procedure} %modify-instance old new
@deffnx {C Function} scm_sys_modify_instance (old, new)

@end deffn

%modify-class
@deffn {Scheme Procedure} %modify-class old new
@deffnx {C Function} scm_sys_modify_class (old, new)

@end deffn

%invalidate-class
@deffn {Scheme Procedure} %invalidate-class class
@deffnx {C Function} scm_sys_invalidate_class (class)

@end deffn

%invalidate-method-cache!
@deffn {Scheme Procedure} %invalidate-method-cache! gf
@deffnx {C Function} scm_sys_invalidate_method_cache_x (gf)

@end deffn

generic-capability?
@deffn {Scheme Procedure} generic-capability? proc
@deffnx {C Function} scm_generic_capability_p (proc)

@end deffn

enable-primitive-generic!
@deffn {Scheme Procedure} enable-primitive-generic! . subrs
@deffnx {C Function} scm_enable_primitive_generic_x (subrs)

@end deffn

primitive-generic-generic
@deffn {Scheme Procedure} primitive-generic-generic subr
@deffnx {C Function} scm_primitive_generic_generic (subr)

@end deffn

make
@deffn {Scheme Procedure} make . args
@deffnx {C Function} scm_make (args)
Make a new object.  @var{args} must contain the class and
all necessary initialization information.
@end deffn

find-method
@deffn {Scheme Procedure} find-method . l
@deffnx {C Function} scm_find_method (l)

@end deffn

%method-more-specific?
@deffn {Scheme Procedure} %method-more-specific? m1 m2 targs
@deffnx {C Function} scm_sys_method_more_specific_p (m1, m2, targs)

@end deffn

%goops-loaded
@deffn {Scheme Procedure} %goops-loaded
@deffnx {C Function} scm_sys_goops_loaded ()
Announce that GOOPS is loaded and perform initialization
on the C level which depends on the loaded GOOPS modules.
@end deffn

make-guardian
@deffn {Scheme Procedure} make-guardian [greedy_p]
@deffnx {C Function} scm_make_guardian (greedy_p)
Create a new guardian.
A guardian protects a set of objects from garbage collection,
allowing a program to apply cleanup or other actions.

@code{make-guardian} returns a procedure representing the guardian.
Calling the guardian procedure with an argument adds the
argument to the guardian's set of protected objects.
Calling the guardian procedure without an argument returns
one of the protected objects which are ready for garbage
collection, or @code{#f} if no such object is available.
Objects which are returned in this way are removed from
the guardian.

@code{make-guardian} takes one optional argument that says whether the
new guardian should be greedy or sharing.  If there is any chance
that any object protected by the guardian may be resurrected,
then you should make the guardian greedy (this is the default).

See R. Kent Dybvig, Carl Bruggeman, and David Eby (1993)
"Guardians in a Generation-Based Garbage Collector".
ACM SIGPLAN Conference on Programming Language Design
and Implementation, June 1993.

(the semantics are slightly different at this point, but the
paper still (mostly) accurately describes the interface).
@end deffn

guardian-destroyed?
@deffn {Scheme Procedure} guardian-destroyed? guardian
@deffnx {C Function} scm_guardian_destroyed_p (guardian)
Return @code{#t} if @var{guardian} has been destroyed, otherwise @code{#f}.
@end deffn

guardian-greedy?
@deffn {Scheme Procedure} guardian-greedy? guardian
@deffnx {C Function} scm_guardian_greedy_p (guardian)
Return @code{#t} if @var{guardian} is a greedy guardian, otherwise @code{#f}.
@end deffn

destroy-guardian!
@deffn {Scheme Procedure} destroy-guardian! guardian
@deffnx {C Function} scm_destroy_guardian_x (guardian)
Destroys @var{guardian}, by making it impossible to put any more
objects in it or get any objects from it.  It also unguards any
objects guarded by @var{guardian}.
@end deffn

hashq
@deffn {Scheme Procedure} hashq key size
@deffnx {C Function} scm_hashq (key, size)
Determine a hash value for @var{key} that is suitable for
lookups in a hashtable of size @var{size}, where @code{eq?} is
used as the equality predicate.  The function returns an
integer in the range 0 to @var{size} - 1.  Note that
@code{hashq} may use internal addresses.  Thus two calls to
hashq where the keys are @code{eq?} are not guaranteed to
deliver the same value if the key object gets garbage collected
in between.  This can happen, for example with symbols:
@code{(hashq 'foo n) (gc) (hashq 'foo n)} may produce two
different values, since @code{foo} will be garbage collected.
@end deffn

hashv
@deffn {Scheme Procedure} hashv key size
@deffnx {C Function} scm_hashv (key, size)
Determine a hash value for @var{key} that is suitable for
lookups in a hashtable of size @var{size}, where @code{eqv?} is
used as the equality predicate.  The function returns an
integer in the range 0 to @var{size} - 1.  Note that
@code{(hashv key)} may use internal addresses.  Thus two calls
to hashv where the keys are @code{eqv?} are not guaranteed to
deliver the same value if the key object gets garbage collected
in between.  This can happen, for example with symbols:
@code{(hashv 'foo n) (gc) (hashv 'foo n)} may produce two
different values, since @code{foo} will be garbage collected.
@end deffn

hash
@deffn {Scheme Procedure} hash key size
@deffnx {C Function} scm_hash (key, size)
Determine a hash value for @var{key} that is suitable for
lookups in a hashtable of size @var{size}, where @code{equal?}
is used as the equality predicate.  The function returns an
integer in the range 0 to @var{size} - 1.
@end deffn

hashq-get-handle
@deffn {Scheme Procedure} hashq-get-handle table key
@deffnx {C Function} scm_hashq_get_handle (table, key)
This procedure returns the @code{(key . value)} pair from the
hash table @var{table}.  If @var{table} does not hold an
associated value for @var{key}, @code{#f} is returned.
Uses @code{eq?} for equality testing.
@end deffn

hashq-create-handle!
@deffn {Scheme Procedure} hashq-create-handle! table key init
@deffnx {C Function} scm_hashq_create_handle_x (table, key, init)
This function looks up @var{key} in @var{table} and returns its handle.
If @var{key} is not already present, a new handle is created which
associates @var{key} with @var{init}.
@end deffn

hashq-ref
@deffn {Scheme Procedure} hashq-ref table key [dflt]
@deffnx {C Function} scm_hashq_ref (table, key, dflt)
Look up @var{key} in the hash table @var{table}, and return the
value (if any) associated with it.  If @var{key} is not found,
return @var{default} (or @code{#f} if no @var{default} argument
is supplied).  Uses @code{eq?} for equality testing.
@end deffn

hashq-set!
@deffn {Scheme Procedure} hashq-set! table key val
@deffnx {C Function} scm_hashq_set_x (table, key, val)
Find the entry in @var{table} associated with @var{key}, and
store @var{value} there. Uses @code{eq?} for equality testing.
@end deffn

hashq-remove!
@deffn {Scheme Procedure} hashq-remove! table key
@deffnx {C Function} scm_hashq_remove_x (table, key)
Remove @var{key} (and any value associated with it) from
@var{table}.  Uses @code{eq?} for equality tests.
@end deffn

hashv-get-handle
@deffn {Scheme Procedure} hashv-get-handle table key
@deffnx {C Function} scm_hashv_get_handle (table, key)
This procedure returns the @code{(key . value)} pair from the
hash table @var{table}.  If @var{table} does not hold an
associated value for @var{key}, @code{#f} is returned.
Uses @code{eqv?} for equality testing.
@end deffn

hashv-create-handle!
@deffn {Scheme Procedure} hashv-create-handle! table key init
@deffnx {C Function} scm_hashv_create_handle_x (table, key, init)
This function looks up @var{key} in @var{table} and returns its handle.
If @var{key} is not already present, a new handle is created which
associates @var{key} with @var{init}.
@end deffn

hashv-ref
@deffn {Scheme Procedure} hashv-ref table key [dflt]
@deffnx {C Function} scm_hashv_ref (table, key, dflt)
Look up @var{key} in the hash table @var{table}, and return the
value (if any) associated with it.  If @var{key} is not found,
return @var{default} (or @code{#f} if no @var{default} argument
is supplied).  Uses @code{eqv?} for equality testing.
@end deffn

hashv-set!
@deffn {Scheme Procedure} hashv-set! table key val
@deffnx {C Function} scm_hashv_set_x (table, key, val)
Find the entry in @var{table} associated with @var{key}, and
store @var{value} there. Uses @code{eqv?} for equality testing.
@end deffn

hashv-remove!
@deffn {Scheme Procedure} hashv-remove! table key
@deffnx {C Function} scm_hashv_remove_x (table, key)
Remove @var{key} (and any value associated with it) from
@var{table}.  Uses @code{eqv?} for equality tests.
@end deffn

hash-get-handle
@deffn {Scheme Procedure} hash-get-handle table key
@deffnx {C Function} scm_hash_get_handle (table, key)
This procedure returns the @code{(key . value)} pair from the
hash table @var{table}.  If @var{table} does not hold an
associated value for @var{key}, @code{#f} is returned.
Uses @code{equal?} for equality testing.
@end deffn

hash-create-handle!
@deffn {Scheme Procedure} hash-create-handle! table key init
@deffnx {C Function} scm_hash_create_handle_x (table, key, init)
This function looks up @var{key} in @var{table} and returns its handle.
If @var{key} is not already present, a new handle is created which
associates @var{key} with @var{init}.
@end deffn

hash-ref
@deffn {Scheme Procedure} hash-ref table key [dflt]
@deffnx {C Function} scm_hash_ref (table, key, dflt)
Look up @var{key} in the hash table @var{table}, and return the
value (if any) associated with it.  If @var{key} is not found,
return @var{default} (or @code{#f} if no @var{default} argument
is supplied).  Uses @code{equal?} for equality testing.
@end deffn

hash-set!
@deffn {Scheme Procedure} hash-set! table key val
@deffnx {C Function} scm_hash_set_x (table, key, val)
Find the entry in @var{table} associated with @var{key}, and
store @var{value} there. Uses @code{equal?} for equality
testing.
@end deffn

hash-remove!
@deffn {Scheme Procedure} hash-remove! table key
@deffnx {C Function} scm_hash_remove_x (table, key)
Remove @var{key} (and any value associated with it) from
@var{table}.  Uses @code{equal?} for equality tests.
@end deffn

hashx-get-handle
@deffn {Scheme Procedure} hashx-get-handle hash assoc table key
@deffnx {C Function} scm_hashx_get_handle (hash, assoc, table, key)
This behaves the same way as the corresponding
@code{-get-handle} function, but uses @var{hash} as a hash
function and @var{assoc} to compare keys.  @code{hash} must be
a function that takes two arguments, a key to be hashed and a
table size.  @code{assoc} must be an associator function, like
@code{assoc}, @code{assq} or @code{assv}.
@end deffn

hashx-create-handle!
@deffn {Scheme Procedure} hashx-create-handle! hash assoc table key init
@deffnx {C Function} scm_hashx_create_handle_x (hash, assoc, table, key, init)
This behaves the same way as the corresponding
@code{-create-handle} function, but uses @var{hash} as a hash
function and @var{assoc} to compare keys.  @code{hash} must be
a function that takes two arguments, a key to be hashed and a
table size.  @code{assoc} must be an associator function, like
@code{assoc}, @code{assq} or @code{assv}.
@end deffn

hashx-ref
@deffn {Scheme Procedure} hashx-ref hash assoc table key [dflt]
@deffnx {C Function} scm_hashx_ref (hash, assoc, table, key, dflt)
This behaves the same way as the corresponding @code{ref}
function, but uses @var{hash} as a hash function and
@var{assoc} to compare keys.  @code{hash} must be a function
that takes two arguments, a key to be hashed and a table size.
@code{assoc} must be an associator function, like @code{assoc},
@code{assq} or @code{assv}.

By way of illustration, @code{hashq-ref table key} is
equivalent to @code{hashx-ref hashq assq table key}.
@end deffn

hashx-set!
@deffn {Scheme Procedure} hashx-set! hash assoc table key val
@deffnx {C Function} scm_hashx_set_x (hash, assoc, table, key, val)
This behaves the same way as the corresponding @code{set!}
function, but uses @var{hash} as a hash function and
@var{assoc} to compare keys.  @code{hash} must be a function
that takes two arguments, a key to be hashed and a table size.
@code{assoc} must be an associator function, like @code{assoc},
@code{assq} or @code{assv}.

 By way of illustration, @code{hashq-set! table key} is
equivalent to @code{hashx-set!  hashq assq table key}.
@end deffn

hash-fold
@deffn {Scheme Procedure} hash-fold proc init table
@deffnx {C Function} scm_hash_fold (proc, init, table)
An iterator over hash-table elements.
Accumulates and returns a result by applying PROC successively.
The arguments to PROC are "(key value prior-result)" where key
and value are successive pairs from the hash table TABLE, and
prior-result is either INIT (for the first application of PROC)
or the return value of the previous application of PROC.
For example, @code{(hash-fold acons '() tab)} will convert a hash
table into an a-list of key-value pairs.
@end deffn

make-hook
@deffn {Scheme Procedure} make-hook [n_args]
@deffnx {C Function} scm_make_hook (n_args)
Create a hook for storing procedure of arity @var{n_args}.
@var{n_args} defaults to zero.  The returned value is a hook
object to be used with the other hook procedures.
@end deffn

hook?
@deffn {Scheme Procedure} hook? x
@deffnx {C Function} scm_hook_p (x)
Return @code{#t} if @var{x} is a hook, @code{#f} otherwise.
@end deffn

hook-empty?
@deffn {Scheme Procedure} hook-empty? hook
@deffnx {C Function} scm_hook_empty_p (hook)
Return @code{#t} if @var{hook} is an empty hook, @code{#f}
otherwise.
@end deffn

add-hook!
@deffn {Scheme Procedure} add-hook! hook proc [append_p]
@deffnx {C Function} scm_add_hook_x (hook, proc, append_p)
Add the procedure @var{proc} to the hook @var{hook}. The
procedure is added to the end if @var{append_p} is true,
otherwise it is added to the front.  The return value of this
procedure is not specified.
@end deffn

remove-hook!
@deffn {Scheme Procedure} remove-hook! hook proc
@deffnx {C Function} scm_remove_hook_x (hook, proc)
Remove the procedure @var{proc} from the hook @var{hook}.  The
return value of this procedure is not specified.
@end deffn

reset-hook!
@deffn {Scheme Procedure} reset-hook! hook
@deffnx {C Function} scm_reset_hook_x (hook)
Remove all procedures from the hook @var{hook}.  The return
value of this procedure is not specified.
@end deffn

run-hook
@deffn {Scheme Procedure} run-hook hook . args
@deffnx {C Function} scm_run_hook (hook, args)
Apply all procedures from the hook @var{hook} to the arguments
@var{args}.  The order of the procedure application is first to
last.  The return value of this procedure is not specified.
@end deffn

hook->list
@deffn {Scheme Procedure} hook->list hook
@deffnx {C Function} scm_hook_to_list (hook)
Convert the procedure list of @var{hook} to a list.
@end deffn

ftell
@deffn {Scheme Procedure} ftell fd_port
@deffnx {C Function} scm_ftell (fd_port)
Return an integer representing the current position of
@var{fd/port}, measured from the beginning.  Equivalent to:

@lisp
(seek port 0 SEEK_CUR)
@end lisp
@end deffn

redirect-port
@deffn {Scheme Procedure} redirect-port old new
@deffnx {C Function} scm_redirect_port (old, new)
This procedure takes two ports and duplicates the underlying file
descriptor from @var{old-port} into @var{new-port}.  The
current file descriptor in @var{new-port} will be closed.
After the redirection the two ports will share a file position
and file status flags.

The return value is unspecified.

Unexpected behaviour can result if both ports are subsequently used
and the original and/or duplicate ports are buffered.

This procedure does not have any side effects on other ports or
revealed counts.
@end deffn

dup->fdes
@deffn {Scheme Procedure} dup->fdes fd_or_port [fd]
@deffnx {C Function} scm_dup_to_fdes (fd_or_port, fd)
Return a new integer file descriptor referring to the open file
designated by @var{fd_or_port}, which must be either an open
file port or a file descriptor.
@end deffn

dup2
@deffn {Scheme Procedure} dup2 oldfd newfd
@deffnx {C Function} scm_dup2 (oldfd, newfd)
A simple wrapper for the @code{dup2} system call.
Copies the file descriptor @var{oldfd} to descriptor
number @var{newfd}, replacing the previous meaning
of @var{newfd}.  Both @var{oldfd} and @var{newfd} must
be integers.
Unlike for dup->fdes or primitive-move->fdes, no attempt
is made to move away ports which are using @var{newfd}.
The return value is unspecified.
@end deffn

fileno
@deffn {Scheme Procedure} fileno port
@deffnx {C Function} scm_fileno (port)
Return the integer file descriptor underlying @var{port}.  Does
not change its revealed count.
@end deffn

isatty?
@deffn {Scheme Procedure} isatty? port
@deffnx {C Function} scm_isatty_p (port)
Return @code{#t} if @var{port} is using a serial non--file
device, otherwise @code{#f}.
@end deffn

fdopen
@deffn {Scheme Procedure} fdopen fdes modes
@deffnx {C Function} scm_fdopen (fdes, modes)
Return a new port based on the file descriptor @var{fdes}.
Modes are given by the string @var{modes}.  The revealed count
of the port is initialized to zero.  The modes string is the
same as that accepted by @ref{File Ports, open-file}.
@end deffn

primitive-move->fdes
@deffn {Scheme Procedure} primitive-move->fdes port fd
@deffnx {C Function} scm_primitive_move_to_fdes (port, fd)
Moves the underlying file descriptor for @var{port} to the integer
value @var{fdes} without changing the revealed count of @var{port}.
Any other ports already using this descriptor will be automatically
shifted to new descriptors and their revealed counts reset to zero.
The return value is @code{#f} if the file descriptor already had the
required value or @code{#t} if it was moved.
@end deffn

fdes->ports
@deffn {Scheme Procedure} fdes->ports fd
@deffnx {C Function} scm_fdes_to_ports (fd)
Return a list of existing ports which have @var{fdes} as an
underlying file descriptor, without changing their revealed
counts.
@end deffn

make-keyword-from-dash-symbol
@deffn {Scheme Procedure} make-keyword-from-dash-symbol symbol
@deffnx {C Function} scm_make_keyword_from_dash_symbol (symbol)
Make a keyword object from a @var{symbol} that starts with a dash.
@end deffn

keyword?
@deffn {Scheme Procedure} keyword? obj
@deffnx {C Function} scm_keyword_p (obj)
Return @code{#t} if the argument @var{obj} is a keyword, else
@code{#f}.
@end deffn

keyword-dash-symbol
@deffn {Scheme Procedure} keyword-dash-symbol keyword
@deffnx {C Function} scm_keyword_dash_symbol (keyword)
Return the dash symbol for @var{keyword}.
This is the inverse of @code{make-keyword-from-dash-symbol}.
@end deffn

list
@deffn {Scheme Procedure} list . objs
@deffnx {C Function} scm_list (objs)
Return a list containing @var{objs}, the arguments to
@code{list}.
@end deffn

cons*
@deffn {Scheme Procedure} cons* arg . rest
@deffnx {C Function} scm_cons_star (arg, rest)
Like @code{list}, but the last arg provides the tail of the
constructed list, returning @code{(cons @var{arg1} (cons
@var{arg2} (cons @dots{} @var{argn})))}.  Requires at least one
argument.  If given one argument, that argument is returned as
result.  This function is called @code{list*} in some other
Schemes and in Common LISP.
@end deffn

null?
@deffn {Scheme Procedure} null? x
@deffnx {C Function} scm_null_p (x)
Return @code{#t} iff @var{x} is the empty list, else @code{#f}.
@end deffn

list?
@deffn {Scheme Procedure} list? x
@deffnx {C Function} scm_list_p (x)
Return @code{#t} iff @var{x} is a proper list, else @code{#f}.
@end deffn

length
@deffn {Scheme Procedure} length lst
@deffnx {C Function} scm_length (lst)
Return the number of elements in list @var{lst}.
@end deffn

append
@deffn {Scheme Procedure} append . args
@deffnx {C Function} scm_append (args)
Return a list consisting of the elements the lists passed as
arguments.
@lisp
(append '(x) '(y))          @result{}  (x y)
(append '(a) '(b c d))      @result{}  (a b c d)
(append '(a (b)) '((c)))    @result{}  (a (b) (c))
@end lisp
The resulting list is always newly allocated, except that it
shares structure with the last list argument.  The last
argument may actually be any object; an improper list results
if the last argument is not a proper list.
@lisp
(append '(a b) '(c . d))    @result{}  (a b c . d)
(append '() 'a)             @result{}  a
@end lisp
@end deffn

append!
@deffn {Scheme Procedure} append! . lists
@deffnx {C Function} scm_append_x (lists)
A destructive version of @code{append} (@pxref{Pairs and
Lists,,,r5rs, The Revised^5 Report on Scheme}).  The cdr field
of each list's final pair is changed to point to the head of
the next list, so no consing is performed.  Return a pointer to
the mutated list.
@end deffn

last-pair
@deffn {Scheme Procedure} last-pair lst
@deffnx {C Function} scm_last_pair (lst)
Return a pointer to the last pair in @var{lst}, signalling an error if
@var{lst} is circular.
@end deffn

reverse
@deffn {Scheme Procedure} reverse lst
@deffnx {C Function} scm_reverse (lst)
Return a new list that contains the elements of @var{lst} but
in reverse order.
@end deffn

reverse!
@deffn {Scheme Procedure} reverse! lst [new_tail]
@deffnx {C Function} scm_reverse_x (lst, new_tail)
A destructive version of @code{reverse} (@pxref{Pairs and Lists,,,r5rs,
The Revised^5 Report on Scheme}).  The cdr of each cell in @var{lst} is
modified to point to the previous list element.  Return a pointer to the
head of the reversed list.

Caveat: because the list is modified in place, the tail of the original
list now becomes its head, and the head of the original list now becomes
the tail.  Therefore, the @var{lst} symbol to which the head of the
original list was bound now points to the tail.  To ensure that the head
of the modified list is not lost, it is wise to save the return value of
@code{reverse!}
@end deffn

list-ref
@deffn {Scheme Procedure} list-ref list k
@deffnx {C Function} scm_list_ref (list, k)
Return the @var{k}th element from @var{list}.
@end deffn

list-set!
@deffn {Scheme Procedure} list-set! list k val
@deffnx {C Function} scm_list_set_x (list, k, val)
Set the @var{k}th element of @var{list} to @var{val}.
@end deffn

list-cdr-ref
@deffn {Scheme Procedure} list-cdr-ref
implemented by the C function "scm_list_tail"
@end deffn

list-tail
@deffn {Scheme Procedure} list-tail lst k
@deffnx {Scheme Procedure} list-cdr-ref lst k
@deffnx {C Function} scm_list_tail (lst, k)
Return the "tail" of @var{lst} beginning with its @var{k}th element.
The first element of the list is considered to be element 0.

@code{list-tail} and @code{list-cdr-ref} are identical.  It may help to
think of @code{list-cdr-ref} as accessing the @var{k}th cdr of the list,
or returning the results of cdring @var{k} times down @var{lst}.
@end deffn

list-cdr-set!
@deffn {Scheme Procedure} list-cdr-set! list k val
@deffnx {C Function} scm_list_cdr_set_x (list, k, val)
Set the @var{k}th cdr of @var{list} to @var{val}.
@end deffn

list-head
@deffn {Scheme Procedure} list-head lst k
@deffnx {C Function} scm_list_head (lst, k)
Copy the first @var{k} elements from @var{lst} into a new list, and
return it.
@end deffn

list-copy
@deffn {Scheme Procedure} list-copy lst
@deffnx {C Function} scm_list_copy (lst)
Return a (newly-created) copy of @var{lst}.
@end deffn

memq
@deffn {Scheme Procedure} memq x lst
@deffnx {C Function} scm_memq (x, lst)
Return the first sublist of @var{lst} whose car is @code{eq?}
to @var{x} where the sublists of @var{lst} are the non-empty
lists returned by @code{(list-tail @var{lst} @var{k})} for
@var{k} less than the length of @var{lst}.  If @var{x} does not
occur in @var{lst}, then @code{#f} (not the empty list) is
returned.
@end deffn

memv
@deffn {Scheme Procedure} memv x lst
@deffnx {C Function} scm_memv (x, lst)
Return the first sublist of @var{lst} whose car is @code{eqv?}
to @var{x} where the sublists of @var{lst} are the non-empty
lists returned by @code{(list-tail @var{lst} @var{k})} for
@var{k} less than the length of @var{lst}.  If @var{x} does not
occur in @var{lst}, then @code{#f} (not the empty list) is
returned.
@end deffn

member
@deffn {Scheme Procedure} member x lst
@deffnx {C Function} scm_member (x, lst)
Return the first sublist of @var{lst} whose car is
@code{equal?} to @var{x} where the sublists of @var{lst} are
the non-empty lists returned by @code{(list-tail @var{lst}
@var{k})} for @var{k} less than the length of @var{lst}.  If
@var{x} does not occur in @var{lst}, then @code{#f} (not the
empty list) is returned.
@end deffn

delq!
@deffn {Scheme Procedure} delq! item lst
@deffnx {Scheme Procedure} delv! item lst
@deffnx {Scheme Procedure} delete! item lst
@deffnx {C Function} scm_delq_x (item, lst)
These procedures are destructive versions of @code{delq}, @code{delv}
and @code{delete}: they modify the pointers in the existing @var{lst}
rather than creating a new list.  Caveat evaluator: Like other
destructive list functions, these functions cannot modify the binding of
@var{lst}, and so cannot be used to delete the first element of
@var{lst} destructively.
@end deffn

delv!
@deffn {Scheme Procedure} delv! item lst
@deffnx {C Function} scm_delv_x (item, lst)
Destructively remove all elements from @var{lst} that are
@code{eqv?} to @var{item}.
@end deffn

delete!
@deffn {Scheme Procedure} delete! item lst
@deffnx {C Function} scm_delete_x (item, lst)
Destructively remove all elements from @var{lst} that are
@code{equal?} to @var{item}.
@end deffn

delq
@deffn {Scheme Procedure} delq item lst
@deffnx {C Function} scm_delq (item, lst)
Return a newly-created copy of @var{lst} with elements
@code{eq?} to @var{item} removed.  This procedure mirrors
@code{memq}: @code{delq} compares elements of @var{lst} against
@var{item} with @code{eq?}.
@end deffn

delv
@deffn {Scheme Procedure} delv item lst
@deffnx {C Function} scm_delv (item, lst)
Return a newly-created copy of @var{lst} with elements
@code{eqv?}  to @var{item} removed.  This procedure mirrors
@code{memv}: @code{delv} compares elements of @var{lst} against
@var{item} with @code{eqv?}.
@end deffn

delete
@deffn {Scheme Procedure} delete item lst
@deffnx {C Function} scm_delete (item, lst)
Return a newly-created copy of @var{lst} with elements
@code{equal?}  to @var{item} removed.  This procedure mirrors
@code{member}: @code{delete} compares elements of @var{lst}
against @var{item} with @code{equal?}.
@end deffn

delq1!
@deffn {Scheme Procedure} delq1! item lst
@deffnx {C Function} scm_delq1_x (item, lst)
Like @code{delq!}, but only deletes the first occurrence of
@var{item} from @var{lst}.  Tests for equality using
@code{eq?}.  See also @code{delv1!} and @code{delete1!}.
@end deffn

delv1!
@deffn {Scheme Procedure} delv1! item lst
@deffnx {C Function} scm_delv1_x (item, lst)
Like @code{delv!}, but only deletes the first occurrence of
@var{item} from @var{lst}.  Tests for equality using
@code{eqv?}.  See also @code{delq1!} and @code{delete1!}.
@end deffn

delete1!
@deffn {Scheme Procedure} delete1! item lst
@deffnx {C Function} scm_delete1_x (item, lst)
Like @code{delete!}, but only deletes the first occurrence of
@var{item} from @var{lst}.  Tests for equality using
@code{equal?}.  See also @code{delq1!} and @code{delv1!}.
@end deffn

primitive-load
@deffn {Scheme Procedure} primitive-load filename
@deffnx {C Function} scm_primitive_load (filename)
Load the file named @var{filename} and evaluate its contents in
the top-level environment. The load paths are not searched;
@var{filename} must either be a full pathname or be a pathname
relative to the current directory.  If the  variable
@code{%load-hook} is defined, it should be bound to a procedure
that will be called before any code is loaded.  See the
documentation for @code{%load-hook} later in this section.
@end deffn

%package-data-dir
@deffn {Scheme Procedure} %package-data-dir
@deffnx {C Function} scm_sys_package_data_dir ()
Return the name of the directory where Scheme packages, modules and
libraries are kept.  On most Unix systems, this will be
@samp{/usr/local/share/guile}.
@end deffn

%library-dir
@deffn {Scheme Procedure} %library-dir
@deffnx {C Function} scm_sys_library_dir ()
Return the directory where the Guile Scheme library files are installed.
E.g., may return "/usr/share/guile/1.3.5".
@end deffn

%site-dir
@deffn {Scheme Procedure} %site-dir
@deffnx {C Function} scm_sys_site_dir ()
Return the directory where the Guile site files are installed.
E.g., may return "/usr/share/guile/site".
@end deffn

parse-path
@deffn {Scheme Procedure} parse-path path [tail]
@deffnx {C Function} scm_parse_path (path, tail)
Parse @var{path}, which is expected to be a colon-separated
string, into a list and return the resulting list with
@var{tail} appended. If @var{path} is @code{#f}, @var{tail}
is returned.
@end deffn

search-path
@deffn {Scheme Procedure} search-path path filename [extensions]
@deffnx {C Function} scm_search_path (path, filename, extensions)
Search @var{path} for a directory containing a file named
@var{filename}. The file must be readable, and not a directory.
If we find one, return its full filename; otherwise, return
@code{#f}.  If @var{filename} is absolute, return it unchanged.
If given, @var{extensions} is a list of strings; for each
directory in @var{path}, we search for @var{filename}
concatenated with each @var{extension}.
@end deffn

%search-load-path
@deffn {Scheme Procedure} %search-load-path filename
@deffnx {C Function} scm_sys_search_load_path (filename)
Search @var{%load-path} for the file named @var{filename},
which must be readable by the current user.  If @var{filename}
is found in the list of paths to search or is an absolute
pathname, return its full pathname.  Otherwise, return
@code{#f}.  Filenames may have any of the optional extensions
in the @code{%load-extensions} list; @code{%search-load-path}
will try each extension automatically.
@end deffn

primitive-load-path
@deffn {Scheme Procedure} primitive-load-path filename
@deffnx {C Function} scm_primitive_load_path (filename)
Search @var{%load-path} for the file named @var{filename} and
load it into the top-level environment.  If @var{filename} is a
relative pathname and is not found in the list of search paths,
an error is signalled.
@end deffn

procedure->syntax
@deffn {Scheme Procedure} procedure->syntax code
@deffnx {C Function} scm_makacro (code)
Return a @dfn{macro} which, when a symbol defined to this value
appears as the first symbol in an expression, returns the
result of applying @var{code} to the expression and the
environment.
@end deffn

procedure->macro
@deffn {Scheme Procedure} procedure->macro code
@deffnx {C Function} scm_makmacro (code)
Return a @dfn{macro} which, when a symbol defined to this value
appears as the first symbol in an expression, evaluates the
result of applying @var{code} to the expression and the
environment.  For example:

@lisp
(define trace
  (procedure->macro
   (lambda (x env) `(set! ,(cadr x) (tracef ,(cadr x) ',(cadr x))))))

(trace @i{foo}) @equiv{} (set! @i{foo} (tracef @i{foo} '@i{foo})).
@end lisp
@end deffn

procedure->memoizing-macro
@deffn {Scheme Procedure} procedure->memoizing-macro code
@deffnx {C Function} scm_makmmacro (code)
Return a @dfn{macro} which, when a symbol defined to this value
appears as the first symbol in an expression, evaluates the
result of applying @var{code} to the expression and the
environment.

@code{procedure->memoizing-macro} is the same as
@code{procedure->macro}, except that the expression returned by
@var{code} replaces the original macro expression in the memoized
form of the containing code.
@end deffn

macro?
@deffn {Scheme Procedure} macro? obj
@deffnx {C Function} scm_macro_p (obj)
Return @code{#t} if @var{obj} is a regular macro, a memoizing macro or a
syntax transformer.
@end deffn

macro-type
@deffn {Scheme Procedure} macro-type m
@deffnx {C Function} scm_macro_type (m)
Return one of the symbols @code{syntax}, @code{macro} or
@code{macro!}, depending on whether @var{m} is a syntax
transformer, a regular macro, or a memoizing macro,
respectively.  If @var{m} is not a macro, @code{#f} is
returned.
@end deffn

macro-name
@deffn {Scheme Procedure} macro-name m
@deffnx {C Function} scm_macro_name (m)
Return the name of the macro @var{m}.
@end deffn

macro-transformer
@deffn {Scheme Procedure} macro-transformer m
@deffnx {C Function} scm_macro_transformer (m)
Return the transformer of the macro @var{m}.
@end deffn

current-module
@deffn {Scheme Procedure} current-module
@deffnx {C Function} scm_current_module ()
Return the current module.
@end deffn

set-current-module
@deffn {Scheme Procedure} set-current-module module
@deffnx {C Function} scm_set_current_module (module)
Set the current module to @var{module} and return
the previous current module.
@end deffn

interaction-environment
@deffn {Scheme Procedure} interaction-environment
@deffnx {C Function} scm_interaction_environment ()
Return a specifier for the environment that contains
implementation--defined bindings, typically a superset of those
listed in the report.  The intent is that this procedure will
return the environment in which the implementation would
evaluate expressions dynamically typed by the user.
@end deffn

env-module
@deffn {Scheme Procedure} env-module env
@deffnx {C Function} scm_env_module (env)
Return the module of @var{ENV}, a lexical environment.
@end deffn

standard-eval-closure
@deffn {Scheme Procedure} standard-eval-closure module
@deffnx {C Function} scm_standard_eval_closure (module)
Return an eval closure for the module @var{module}.
@end deffn

standard-interface-eval-closure
@deffn {Scheme Procedure} standard-interface-eval-closure module
@deffnx {C Function} scm_standard_interface_eval_closure (module)
Return a interface eval closure for the module @var{module}. Such a closure does not allow new bindings to be added.
@end deffn

%get-pre-modules-obarray
@deffn {Scheme Procedure} %get-pre-modules-obarray
@deffnx {C Function} scm_get_pre_modules_obarray ()
Return the obarray that is used for all new bindings before the module system is booted.  The first call to @code{set-current-module} will boot the module system.
@end deffn

exact?
@deffn {Scheme Procedure} exact? x
@deffnx {C Function} scm_exact_p (x)
Return @code{#t} if @var{x} is an exact number, @code{#f}
otherwise.
@end deffn

odd?
@deffn {Scheme Procedure} odd? n
@deffnx {C Function} scm_odd_p (n)
Return @code{#t} if @var{n} is an odd number, @code{#f}
otherwise.
@end deffn

even?
@deffn {Scheme Procedure} even? n
@deffnx {C Function} scm_even_p (n)
Return @code{#t} if @var{n} is an even number, @code{#f}
otherwise.
@end deffn

inf?
@deffn {Scheme Procedure} inf? n
@deffnx {C Function} scm_inf_p (n)
Return @code{#t} if @var{n} is infinite, @code{#f}
otherwise.
@end deffn

nan?
@deffn {Scheme Procedure} nan? n
@deffnx {C Function} scm_nan_p (n)
Return @code{#t} if @var{n} is a NaN, @code{#f}
otherwise.
@end deffn

inf
@deffn {Scheme Procedure} inf
@deffnx {C Function} scm_inf ()
Return Inf.
@end deffn

nan
@deffn {Scheme Procedure} nan
@deffnx {C Function} scm_nan ()
Return NaN.
@end deffn

logand
@deffn {Scheme Procedure} logand n1 n2
Return the bitwise AND of the integer arguments.

@lisp
(logand) @result{} -1
(logand 7) @result{} 7
(logand #b111 #b011 #b001) @result{} 1
@end lisp
@end deffn

logior
@deffn {Scheme Procedure} logior n1 n2
Return the bitwise OR of the integer arguments.

@lisp
(logior) @result{} 0
(logior 7) @result{} 7
(logior #b000 #b001 #b011) @result{} 3
@end lisp
@end deffn

logxor
@deffn {Scheme Procedure} logxor n1 n2
Return the bitwise XOR of the integer arguments.  A bit is
set in the result if it is set in an odd number of arguments.
@lisp
(logxor) @result{} 0
(logxor 7) @result{} 7
(logxor #b000 #b001 #b011) @result{} 2
(logxor #b000 #b001 #b011 #b011) @result{} 1
@end lisp
@end deffn

logtest
@deffn {Scheme Procedure} logtest j k
@deffnx {C Function} scm_logtest (j, k)
@lisp
(logtest j k) @equiv{} (not (zero? (logand j k)))

(logtest #b0100 #b1011) @result{} #f
(logtest #b0100 #b0111) @result{} #t
@end lisp
@end deffn

logbit?
@deffn {Scheme Procedure} logbit? index j
@deffnx {C Function} scm_logbit_p (index, j)
@lisp
(logbit? index j) @equiv{} (logtest (integer-expt 2 index) j)

(logbit? 0 #b1101) @result{} #t
(logbit? 1 #b1101) @result{} #f
(logbit? 2 #b1101) @result{} #t
(logbit? 3 #b1101) @result{} #t
(logbit? 4 #b1101) @result{} #f
@end lisp
@end deffn

lognot
@deffn {Scheme Procedure} lognot n
@deffnx {C Function} scm_lognot (n)
Return the integer which is the 2s-complement of the integer
argument.

@lisp
(number->string (lognot #b10000000) 2)
   @result{} "-10000001"
(number->string (lognot #b0) 2)
   @result{} "-1"
@end lisp
@end deffn

integer-expt
@deffn {Scheme Procedure} integer-expt n k
@deffnx {C Function} scm_integer_expt (n, k)
Return @var{n} raised to the non-negative integer exponent
@var{k}.

@lisp
(integer-expt 2 5)
   @result{} 32
(integer-expt -3 3)
   @result{} -27
@end lisp
@end deffn

ash
@deffn {Scheme Procedure} ash n cnt
@deffnx {C Function} scm_ash (n, cnt)
The function ash performs an arithmetic shift left by @var{cnt}
bits (or shift right, if @var{cnt} is negative).  'Arithmetic'
means, that the function does not guarantee to keep the bit
structure of @var{n}, but rather guarantees that the result
will always be rounded towards minus infinity.  Therefore, the
results of ash and a corresponding bitwise shift will differ if
@var{n} is negative.

Formally, the function returns an integer equivalent to
@code{(inexact->exact (floor (* @var{n} (expt 2 @var{cnt}))))}.

@lisp
(number->string (ash #b1 3) 2)     @result{} "1000"
(number->string (ash #b1010 -1) 2) @result{} "101"
@end lisp
@end deffn

bit-extract
@deffn {Scheme Procedure} bit-extract n start end
@deffnx {C Function} scm_bit_extract (n, start, end)
Return the integer composed of the @var{start} (inclusive)
through @var{end} (exclusive) bits of @var{n}.  The
@var{start}th bit becomes the 0-th bit in the result.

@lisp
(number->string (bit-extract #b1101101010 0 4) 2)
   @result{} "1010"
(number->string (bit-extract #b1101101010 4 9) 2)
   @result{} "10110"
@end lisp
@end deffn

logcount
@deffn {Scheme Procedure} logcount n
@deffnx {C Function} scm_logcount (n)
Return the number of bits in integer @var{n}.  If integer is
positive, the 1-bits in its binary representation are counted.
If negative, the 0-bits in its two's-complement binary
representation are counted.  If 0, 0 is returned.

@lisp
(logcount #b10101010)
   @result{} 4
(logcount 0)
   @result{} 0
(logcount -2)
   @result{} 1
@end lisp
@end deffn

integer-length
@deffn {Scheme Procedure} integer-length n
@deffnx {C Function} scm_integer_length (n)
Return the number of bits necessary to represent @var{n}.

@lisp
(integer-length #b10101010)
   @result{} 8
(integer-length 0)
   @result{} 0
(integer-length #b1111)
   @result{} 4
@end lisp
@end deffn

number->string
@deffn {Scheme Procedure} number->string n [radix]
@deffnx {C Function} scm_number_to_string (n, radix)
Return a string holding the external representation of the
number @var{n} in the given @var{radix}.  If @var{n} is
inexact, a radix of 10 will be used.
@end deffn

string->number
@deffn {Scheme Procedure} string->number string [radix]
@deffnx {C Function} scm_string_to_number (string, radix)
Return a number of the maximally precise representation
expressed by the given @var{string}. @var{radix} must be an
exact integer, either 2, 8, 10, or 16. If supplied, @var{radix}
is a default radix that may be overridden by an explicit radix
prefix in @var{string} (e.g. "#o177"). If @var{radix} is not
supplied, then the default radix is 10. If string is not a
syntactically valid notation for a number, then
@code{string->number} returns @code{#f}.
@end deffn

number?
@deffn {Scheme Procedure} number?
implemented by the C function "scm_number_p"
@end deffn

complex?
@deffn {Scheme Procedure} complex? x
@deffnx {C Function} scm_number_p (x)
Return @code{#t} if @var{x} is a complex number, @code{#f}
otherwise.  Note that the sets of real, rational and integer
values form subsets of the set of complex numbers, i. e. the
predicate will also be fulfilled if @var{x} is a real,
rational or integer number.
@end deffn

real?
@deffn {Scheme Procedure} real?
implemented by the C function "scm_real_p"
@end deffn

rational?
@deffn {Scheme Procedure} rational? x
@deffnx {C Function} scm_real_p (x)
Return @code{#t} if @var{x} is a rational number, @code{#f}
otherwise.  Note that the set of integer values forms a subset of
the set of rational numbers, i. e. the predicate will also be
fulfilled if @var{x} is an integer number.  Real numbers
will also satisfy this predicate, because of their limited
precision.
@end deffn

integer?
@deffn {Scheme Procedure} integer? x
@deffnx {C Function} scm_integer_p (x)
Return @code{#t} if @var{x} is an integer number, @code{#f}
else.
@end deffn

inexact?
@deffn {Scheme Procedure} inexact? x
@deffnx {C Function} scm_inexact_p (x)
Return @code{#t} if @var{x} is an inexact number, @code{#f}
else.
@end deffn

$expt
@deffn {Scheme Procedure} $expt x y
@deffnx {C Function} scm_sys_expt (x, y)
Return @var{x} raised to the power of @var{y}. This
procedure does not accept complex arguments.
@end deffn

$atan2
@deffn {Scheme Procedure} $atan2 x y
@deffnx {C Function} scm_sys_atan2 (x, y)
Return the arc tangent of the two arguments @var{x} and
@var{y}. This is similar to calculating the arc tangent of
@var{x} / @var{y}, except that the signs of both arguments
are used to determine the quadrant of the result. This
procedure does not accept complex arguments.
@end deffn

make-rectangular
@deffn {Scheme Procedure} make-rectangular real imaginary
@deffnx {C Function} scm_make_rectangular (real, imaginary)
Return a complex number constructed of the given @var{real} and
@var{imaginary} parts.
@end deffn

make-polar
@deffn {Scheme Procedure} make-polar x y
@deffnx {C Function} scm_make_polar (x, y)
Return the complex number @var{x} * e^(i * @var{y}).
@end deffn

inexact->exact
@deffn {Scheme Procedure} inexact->exact z
@deffnx {C Function} scm_inexact_to_exact (z)
Return an exact number that is numerically closest to @var{z}.
@end deffn

class-of
@deffn {Scheme Procedure} class-of x
@deffnx {C Function} scm_class_of (x)
Return the class of @var{x}.
@end deffn

entity?
@deffn {Scheme Procedure} entity? obj
@deffnx {C Function} scm_entity_p (obj)
Return @code{#t} if @var{obj} is an entity.
@end deffn

operator?
@deffn {Scheme Procedure} operator? obj
@deffnx {C Function} scm_operator_p (obj)
Return @code{#t} if @var{obj} is an operator.
@end deffn

valid-object-procedure?
@deffn {Scheme Procedure} valid-object-procedure? proc
@deffnx {C Function} scm_valid_object_procedure_p (proc)
Return @code{#t} iff @var{proc} is a procedure that can be used with @code{set-object-procedure}.  It is always valid to use a closure constructed by @code{lambda}.
@end deffn

set-object-procedure!
@deffn {Scheme Procedure} set-object-procedure! obj proc
@deffnx {C Function} scm_set_object_procedure_x (obj, proc)
Set the object procedure of @var{obj} to @var{proc}.
@var{obj} must be either an entity or an operator.
@end deffn

make-class-object
@deffn {Scheme Procedure} make-class-object metaclass layout
@deffnx {C Function} scm_make_class_object (metaclass, layout)
Create a new class object of class @var{metaclass}, with the
slot layout specified by @var{layout}.
@end deffn

make-subclass-object
@deffn {Scheme Procedure} make-subclass-object class layout
@deffnx {C Function} scm_make_subclass_object (class, layout)
Create a subclass object of @var{class}, with the slot layout
specified by @var{layout}.
@end deffn

object-properties
@deffn {Scheme Procedure} object-properties obj
@deffnx {C Function} scm_object_properties (obj)
Return @var{obj}'s property list.
@end deffn

set-object-properties!
@deffn {Scheme Procedure} set-object-properties! obj alist
@deffnx {C Function} scm_set_object_properties_x (obj, alist)
Set @var{obj}'s property list to @var{alist}.
@end deffn

object-property
@deffn {Scheme Procedure} object-property obj key
@deffnx {C Function} scm_object_property (obj, key)
Return the property of @var{obj} with name @var{key}.
@end deffn

set-object-property!
@deffn {Scheme Procedure} set-object-property! obj key value
@deffnx {C Function} scm_set_object_property_x (obj, key, value)
In @var{obj}'s property list, set the property named @var{key}
to @var{value}.
@end deffn

cons
@deffn {Scheme Procedure} cons x y
@deffnx {C Function} scm_cons (x, y)
Return a newly allocated pair whose car is @var{x} and whose
cdr is @var{y}.  The pair is guaranteed to be different (in the
sense of @code{eq?}) from every previously existing object.
@end deffn

pair?
@deffn {Scheme Procedure} pair? x
@deffnx {C Function} scm_pair_p (x)
Return @code{#t} if @var{x} is a pair; otherwise return
@code{#f}.
@end deffn

set-car!
@deffn {Scheme Procedure} set-car! pair value
@deffnx {C Function} scm_set_car_x (pair, value)
Stores @var{value} in the car field of @var{pair}.  The value returned
by @code{set-car!} is unspecified.
@end deffn

set-cdr!
@deffn {Scheme Procedure} set-cdr! pair value
@deffnx {C Function} scm_set_cdr_x (pair, value)
Stores @var{value} in the cdr field of @var{pair}.  The value returned
by @code{set-cdr!} is unspecified.
@end deffn

char-ready?
@deffn {Scheme Procedure} char-ready? [port]
@deffnx {C Function} scm_char_ready_p (port)
Return @code{#t} if a character is ready on input @var{port}
and return @code{#f} otherwise.  If @code{char-ready?} returns
@code{#t} then the next @code{read-char} operation on
@var{port} is guaranteed not to hang.  If @var{port} is a file
port at end of file then @code{char-ready?} returns @code{#t}.
@footnote{@code{char-ready?} exists to make it possible for a
program to accept characters from interactive ports without
getting stuck waiting for input.  Any input editors associated
with such ports must make sure that characters whose existence
has been asserted by @code{char-ready?} cannot be rubbed out.
If @code{char-ready?} were to return @code{#f} at end of file,
a port at end of file would be indistinguishable from an
interactive port that has no ready characters.}
@end deffn

drain-input
@deffn {Scheme Procedure} drain-input port
@deffnx {C Function} scm_drain_input (port)
This procedure clears a port's input buffers, similar
to the way that force-output clears the output buffer.  The
contents of the buffers are returned as a single string, e.g.,

@lisp
(define p (open-input-file ...))
(drain-input p) => empty string, nothing buffered yet.
(unread-char (read-char p) p)
(drain-input p) => initial chars from p, up to the buffer size.
@end lisp

Draining the buffers may be useful for cleanly finishing
buffered I/O so that the file descriptor can be used directly
for further input.
@end deffn

current-input-port
@deffn {Scheme Procedure} current-input-port
@deffnx {C Function} scm_current_input_port ()
Return the current input port.  This is the default port used
by many input procedures.  Initially, @code{current-input-port}
returns the @dfn{standard input} in Unix and C terminology.
@end deffn

current-output-port
@deffn {Scheme Procedure} current-output-port
@deffnx {C Function} scm_current_output_port ()
Return the current output port.  This is the default port used
by many output procedures.  Initially,
@code{current-output-port} returns the @dfn{standard output} in
Unix and C terminology.
@end deffn

current-error-port
@deffn {Scheme Procedure} current-error-port
@deffnx {C Function} scm_current_error_port ()
Return the port to which errors and warnings should be sent (the
@dfn{standard error} in Unix and C terminology).
@end deffn

current-load-port
@deffn {Scheme Procedure} current-load-port
@deffnx {C Function} scm_current_load_port ()
Return the current-load-port.
The load port is used internally by @code{primitive-load}.
@end deffn

set-current-input-port
@deffn {Scheme Procedure} set-current-input-port port
@deffnx {Scheme Procedure} set-current-output-port port
@deffnx {Scheme Procedure} set-current-error-port port
@deffnx {C Function} scm_set_current_input_port (port)
Change the ports returned by @code{current-input-port},
@code{current-output-port} and @code{current-error-port}, respectively,
so that they use the supplied @var{port} for input or output.
@end deffn

set-current-output-port
@deffn {Scheme Procedure} set-current-output-port port
@deffnx {C Function} scm_set_current_output_port (port)
Set the current default output port to @var{port}.
@end deffn

set-current-error-port
@deffn {Scheme Procedure} set-current-error-port port
@deffnx {C Function} scm_set_current_error_port (port)
Set the current default error port to @var{port}.
@end deffn

port-revealed
@deffn {Scheme Procedure} port-revealed port
@deffnx {C Function} scm_port_revealed (port)
Return the revealed count for @var{port}.
@end deffn

set-port-revealed!
@deffn {Scheme Procedure} set-port-revealed! port rcount
@deffnx {C Function} scm_set_port_revealed_x (port, rcount)
Sets the revealed count for a port to a given value.
The return value is unspecified.
@end deffn

port-mode
@deffn {Scheme Procedure} port-mode port
@deffnx {C Function} scm_port_mode (port)
Return the port modes associated with the open port @var{port}.
These will not necessarily be identical to the modes used when
the port was opened, since modes such as "append" which are
used only during port creation are not retained.
@end deffn

close-port
@deffn {Scheme Procedure} close-port port
@deffnx {C Function} scm_close_port (port)
Close the specified port object.  Return @code{#t} if it
successfully closes a port or @code{#f} if it was already
closed.  An exception may be raised if an error occurs, for
example when flushing buffered output.  See also @ref{Ports and
File Descriptors, close}, for a procedure which can close file
descriptors.
@end deffn

close-input-port
@deffn {Scheme Procedure} close-input-port port
@deffnx {C Function} scm_close_input_port (port)
Close the specified input port object.  The routine has no effect if
the file has already been closed.  An exception may be raised if an
error occurs.  The value returned is unspecified.

See also @ref{Ports and File Descriptors, close}, for a procedure
which can close file descriptors.
@end deffn

close-output-port
@deffn {Scheme Procedure} close-output-port port
@deffnx {C Function} scm_close_output_port (port)
Close the specified output port object.  The routine has no effect if
the file has already been closed.  An exception may be raised if an
error occurs.  The value returned is unspecified.

See also @ref{Ports and File Descriptors, close}, for a procedure
which can close file descriptors.
@end deffn

port-for-each
@deffn {Scheme Procedure} port-for-each proc
@deffnx {C Function} scm_port_for_each (proc)
Apply @var{proc} to each port in the Guile port table
in turn.  The return value is unspecified.  More specifically,
@var{proc} is applied exactly once to every port that exists
in the system at the time @var{port-for-each} is invoked.
Changes to the port table while @var{port-for-each} is running
have no effect as far as @var{port-for-each} is concerned.
@end deffn

input-port?
@deffn {Scheme Procedure} input-port? x
@deffnx {C Function} scm_input_port_p (x)
Return @code{#t} if @var{x} is an input port, otherwise return
@code{#f}.  Any object satisfying this predicate also satisfies
@code{port?}.
@end deffn

output-port?
@deffn {Scheme Procedure} output-port? x
@deffnx {C Function} scm_output_port_p (x)
Return @code{#t} if @var{x} is an output port, otherwise return
@code{#f}.  Any object satisfying this predicate also satisfies
@code{port?}.
@end deffn

port?
@deffn {Scheme Procedure} port? x
@deffnx {C Function} scm_port_p (x)
Return a boolean indicating whether @var{x} is a port.
Equivalent to @code{(or (input-port? @var{x}) (output-port?
@var{x}))}.
@end deffn

port-closed?
@deffn {Scheme Procedure} port-closed? port
@deffnx {C Function} scm_port_closed_p (port)
Return @code{#t} if @var{port} is closed or @code{#f} if it is
open.
@end deffn

eof-object?
@deffn {Scheme Procedure} eof-object? x
@deffnx {C Function} scm_eof_object_p (x)
Return @code{#t} if @var{x} is an end-of-file object; otherwise
return @code{#f}.
@end deffn

force-output
@deffn {Scheme Procedure} force-output [port]
@deffnx {C Function} scm_force_output (port)
Flush the specified output port, or the current output port if @var{port}
is omitted.  The current output buffer contents are passed to the
underlying port implementation (e.g., in the case of fports, the
data will be written to the file and the output buffer will be cleared.)
It has no effect on an unbuffered port.

The return value is unspecified.
@end deffn

flush-all-ports
@deffn {Scheme Procedure} flush-all-ports
@deffnx {C Function} scm_flush_all_ports ()
Equivalent to calling @code{force-output} on
all open output ports.  The return value is unspecified.
@end deffn

read-char
@deffn {Scheme Procedure} read-char [port]
@deffnx {C Function} scm_read_char (port)
Return the next character available from @var{port}, updating
@var{port} to point to the following character.  If no more
characters are available, the end-of-file object is returned.
@end deffn

peek-char
@deffn {Scheme Procedure} peek-char [port]
@deffnx {C Function} scm_peek_char (port)
Return the next character available from @var{port},
@emph{without} updating @var{port} to point to the following
character.  If no more characters are available, the
end-of-file object is returned.@footnote{The value returned by
a call to @code{peek-char} is the same as the value that would
have been returned by a call to @code{read-char} on the same
port.  The only difference is that the very next call to
@code{read-char} or @code{peek-char} on that @var{port} will
return the value returned by the preceding call to
@code{peek-char}.  In particular, a call to @code{peek-char} on
an interactive port will hang waiting for input whenever a call
to @code{read-char} would have hung.}
@end deffn

unread-char
@deffn {Scheme Procedure} unread-char cobj [port]
@deffnx {C Function} scm_unread_char (cobj, port)
Place @var{char} in @var{port} so that it will be read by the
next read operation.  If called multiple times, the unread characters
will be read again in last-in first-out order.  If @var{port} is
not supplied, the current input port is used.
@end deffn

unread-string
@deffn {Scheme Procedure} unread-string str port
@deffnx {C Function} scm_unread_string (str, port)
Place the string @var{str} in @var{port} so that its characters will be
read in subsequent read operations.  If called multiple times, the
unread characters will be read again in last-in first-out order.  If
@var{port} is not supplied, the current-input-port is used.
@end deffn

seek
@deffn {Scheme Procedure} seek fd_port offset whence
@deffnx {C Function} scm_seek (fd_port, offset, whence)
Sets the current position of @var{fd/port} to the integer
@var{offset}, which is interpreted according to the value of
@var{whence}.

One of the following variables should be supplied for
@var{whence}:
@defvar SEEK_SET
Seek from the beginning of the file.
@end defvar
@defvar SEEK_CUR
Seek from the current position.
@end defvar
@defvar SEEK_END
Seek from the end of the file.
@end defvar
If @var{fd/port} is a file descriptor, the underlying system
call is @code{lseek}.  @var{port} may be a string port.

The value returned is the new position in the file.  This means
that the current position of a port can be obtained using:
@lisp
(seek port 0 SEEK_CUR)
@end lisp
@end deffn

truncate-file
@deffn {Scheme Procedure} truncate-file object [length]
@deffnx {C Function} scm_truncate_file (object, length)
Truncates the object referred to by @var{object} to at most
@var{length} bytes.  @var{object} can be a string containing a
file name or an integer file descriptor or a port.
@var{length} may be omitted if @var{object} is not a file name,
in which case the truncation occurs at the current port.
position.  The return value is unspecified.
@end deffn

port-line
@deffn {Scheme Procedure} port-line port
@deffnx {C Function} scm_port_line (port)
Return the current line number for @var{port}.
@end deffn

set-port-line!
@deffn {Scheme Procedure} set-port-line! port line
@deffnx {C Function} scm_set_port_line_x (port, line)
Set the current line number for @var{port} to @var{line}.
@end deffn

port-column
@deffn {Scheme Procedure} port-column port
@deffnx {Scheme Procedure} port-line port
@deffnx {C Function} scm_port_column (port)
Return the current column number or line number of @var{port},
using the current input port if none is specified.  If the number is
unknown, the result is #f.  Otherwise, the result is a 0-origin integer
- i.e. the first character of the first line is line 0, column 0.
(However, when you display a file position, for example in an error
message, we recommend you add 1 to get 1-origin integers.  This is
because lines and column numbers traditionally start with 1, and that is
what non-programmers will find most natural.)
@end deffn

set-port-column!
@deffn {Scheme Procedure} set-port-column! port column
@deffnx {Scheme Procedure} set-port-line! port line
@deffnx {C Function} scm_set_port_column_x (port, column)
Set the current column or line number of @var{port}, using the
current input port if none is specified.
@end deffn

port-filename
@deffn {Scheme Procedure} port-filename port
@deffnx {C Function} scm_port_filename (port)
Return the filename associated with @var{port}.  This function returns
the strings "standard input", "standard output" and "standard error"
when called on the current input, output and error ports respectively.
@end deffn

set-port-filename!
@deffn {Scheme Procedure} set-port-filename! port filename
@deffnx {C Function} scm_set_port_filename_x (port, filename)
Change the filename associated with @var{port}, using the current input
port if none is specified.  Note that this does not change the port's
source of data, but only the value that is returned by
@code{port-filename} and reported in diagnostic output.
@end deffn

%make-void-port
@deffn {Scheme Procedure} %make-void-port mode
@deffnx {C Function} scm_sys_make_void_port (mode)
Create and return a new void port.  A void port acts like
@file{/dev/null}.  The @var{mode} argument
specifies the input/output modes for this port: see the
documentation for @code{open-file} in @ref{File Ports}.
@end deffn

print-options-interface
@deffn {Scheme Procedure} print-options-interface [setting]
@deffnx {C Function} scm_print_options (setting)
Option interface for the print options. Instead of using
this procedure directly, use the procedures
@code{print-enable}, @code{print-disable}, @code{print-set!}
and @code{print-options}.
@end deffn

simple-format
@deffn {Scheme Procedure} simple-format destination message . args
@deffnx {C Function} scm_simple_format (destination, message, args)
Write @var{message} to @var{destination}, defaulting to
the current output port.
@var{message} can contain @code{~A} (was @code{%s}) and
@code{~S} (was @code{%S}) escapes.  When printed,
the escapes are replaced with corresponding members of
@var{ARGS}:
@code{~A} formats using @code{display} and @code{~S} formats
using @code{write}.
If @var{destination} is @code{#t}, then use the current output
port, if @var{destination} is @code{#f}, then return a string
containing the formatted text. Does not add a trailing newline.
@end deffn

newline
@deffn {Scheme Procedure} newline [port]
@deffnx {C Function} scm_newline (port)
Send a newline to @var{port}.
If @var{port} is omitted, send to the current output port.
@end deffn

write-char
@deffn {Scheme Procedure} write-char chr [port]
@deffnx {C Function} scm_write_char (chr, port)
Send character @var{chr} to @var{port}.
@end deffn

port-with-print-state
@deffn {Scheme Procedure} port-with-print-state port pstate
@deffnx {C Function} scm_port_with_print_state (port, pstate)
Create a new port which behaves like @var{port}, but with an
included print state @var{pstate}.
@end deffn

get-print-state
@deffn {Scheme Procedure} get-print-state port
@deffnx {C Function} scm_get_print_state (port)
Return the print state of the port @var{port}. If @var{port}
has no associated print state, @code{#f} is returned.
@end deffn

procedure-properties
@deffn {Scheme Procedure} procedure-properties proc
@deffnx {C Function} scm_procedure_properties (proc)
Return @var{obj}'s property list.
@end deffn

set-procedure-properties!
@deffn {Scheme Procedure} set-procedure-properties! proc new_val
@deffnx {C Function} scm_set_procedure_properties_x (proc, new_val)
Set @var{obj}'s property list to @var{alist}.
@end deffn

procedure-property
@deffn {Scheme Procedure} procedure-property p k
@deffnx {C Function} scm_procedure_property (p, k)
Return the property of @var{obj} with name @var{key}.
@end deffn

set-procedure-property!
@deffn {Scheme Procedure} set-procedure-property! p k v
@deffnx {C Function} scm_set_procedure_property_x (p, k, v)
In @var{obj}'s property list, set the property named @var{key} to
@var{value}.
@end deffn

procedure?
@deffn {Scheme Procedure} procedure? obj
@deffnx {C Function} scm_procedure_p (obj)
Return @code{#t} if @var{obj} is a procedure.
@end deffn

closure?
@deffn {Scheme Procedure} closure? obj
@deffnx {C Function} scm_closure_p (obj)
Return @code{#t} if @var{obj} is a closure.
@end deffn

thunk?
@deffn {Scheme Procedure} thunk? obj
@deffnx {C Function} scm_thunk_p (obj)
Return @code{#t} if @var{obj} is a thunk.
@end deffn

procedure-documentation
@deffn {Scheme Procedure} procedure-documentation proc
@deffnx {C Function} scm_procedure_documentation (proc)
Return the documentation string associated with @code{proc}.  By
convention, if a procedure contains more than one expression and the
first expression is a string constant, that string is assumed to contain
documentation for that procedure.
@end deffn

procedure-with-setter?
@deffn {Scheme Procedure} procedure-with-setter? obj
@deffnx {C Function} scm_procedure_with_setter_p (obj)
Return @code{#t} if @var{obj} is a procedure with an
associated setter procedure.
@end deffn

make-procedure-with-setter
@deffn {Scheme Procedure} make-procedure-with-setter procedure setter
@deffnx {C Function} scm_make_procedure_with_setter (procedure, setter)
Create a new procedure which behaves like @var{procedure}, but
with the associated setter @var{setter}.
@end deffn

procedure
@deffn {Scheme Procedure} procedure proc
@deffnx {C Function} scm_procedure (proc)
Return the procedure of @var{proc}, which must be either a
procedure with setter, or an operator struct.
@end deffn

primitive-make-property
@deffn {Scheme Procedure} primitive-make-property not_found_proc
@deffnx {C Function} scm_primitive_make_property (not_found_proc)
Create a @dfn{property token} that can be used with
@code{primitive-property-ref} and @code{primitive-property-set!}.
See @code{primitive-property-ref} for the significance of
@var{not_found_proc}.
@end deffn

primitive-property-ref
@deffn {Scheme Procedure} primitive-property-ref prop obj
@deffnx {C Function} scm_primitive_property_ref (prop, obj)
Return the property @var{prop} of @var{obj}.  When no value
has yet been associated with @var{prop} and @var{obj}, call
@var{not-found-proc} instead (see @code{primitive-make-property})
and use its return value.  That value is also associated with
@var{obj} via @code{primitive-property-set!}.  When
@var{not-found-proc} is @code{#f}, use @code{#f} as the
default value of @var{prop}.
@end deffn

primitive-property-set!
@deffn {Scheme Procedure} primitive-property-set! prop obj val
@deffnx {C Function} scm_primitive_property_set_x (prop, obj, val)
Associate @var{code} with @var{prop} and @var{obj}.
@end deffn

primitive-property-del!
@deffn {Scheme Procedure} primitive-property-del! prop obj
@deffnx {C Function} scm_primitive_property_del_x (prop, obj)
Remove any value associated with @var{prop} and @var{obj}.
@end deffn

random
@deffn {Scheme Procedure} random n [state]
@deffnx {C Function} scm_random (n, state)
Return a number in [0, N).

Accepts a positive integer or real n and returns a
number of the same type between zero (inclusive) and
N (exclusive). The values returned have a uniform
distribution.

The optional argument @var{state} must be of the type produced
by @code{seed->random-state}. It defaults to the value of the
variable @var{*random-state*}. This object is used to maintain
the state of the pseudo-random-number generator and is altered
as a side effect of the random operation.
@end deffn

copy-random-state
@deffn {Scheme Procedure} copy-random-state [state]
@deffnx {C Function} scm_copy_random_state (state)
Return a copy of the random state @var{state}.
@end deffn

seed->random-state
@deffn {Scheme Procedure} seed->random-state seed
@deffnx {C Function} scm_seed_to_random_state (seed)
Return a new random state using @var{seed}.
@end deffn

random:uniform
@deffn {Scheme Procedure} random:uniform [state]
@deffnx {C Function} scm_random_uniform (state)
Return a uniformly distributed inexact real random number in
[0,1).
@end deffn

random:normal
@deffn {Scheme Procedure} random:normal [state]
@deffnx {C Function} scm_random_normal (state)
Return an inexact real in a normal distribution.  The
distribution used has mean 0 and standard deviation 1.  For a
normal distribution with mean m and standard deviation d use
@code{(+ m (* d (random:normal)))}.
@end deffn

random:solid-sphere!
@deffn {Scheme Procedure} random:solid-sphere! v [state]
@deffnx {C Function} scm_random_solid_sphere_x (v, state)
Fills vect with inexact real random numbers
the sum of whose squares is less than 1.0.
Thinking of vect as coordinates in space of
dimension n = (vector-length vect), the coordinates
are uniformly distributed within the unit n-sphere.
The sum of the squares of the numbers is returned.
@end deffn

random:hollow-sphere!
@deffn {Scheme Procedure} random:hollow-sphere! v [state]
@deffnx {C Function} scm_random_hollow_sphere_x (v, state)
Fills vect with inexact real random numbers
the sum of whose squares is equal to 1.0.
Thinking of vect as coordinates in space of
dimension n = (vector-length vect), the coordinates
are uniformly distributed over the surface of the
unit n-sphere.
@end deffn

random:normal-vector!
@deffn {Scheme Procedure} random:normal-vector! v [state]
@deffnx {C Function} scm_random_normal_vector_x (v, state)
Fills vect with inexact real random numbers that are
independent and standard normally distributed
(i.e., with mean 0 and variance 1).
@end deffn

random:exp
@deffn {Scheme Procedure} random:exp [state]
@deffnx {C Function} scm_random_exp (state)
Return an inexact real in an exponential distribution with mean
1.  For an exponential distribution with mean u use (* u
(random:exp)).
@end deffn

%read-delimited!
@deffn {Scheme Procedure} %read-delimited! delims str gobble [port [start [end]]]
@deffnx {C Function} scm_read_delimited_x (delims, str, gobble, port, start, end)
Read characters from @var{port} into @var{str} until one of the
characters in the @var{delims} string is encountered.  If
@var{gobble} is true, discard the delimiter character;
otherwise, leave it in the input stream for the next read.  If
@var{port} is not specified, use the value of
@code{(current-input-port)}.  If @var{start} or @var{end} are
specified, store data only into the substring of @var{str}
bounded by @var{start} and @var{end} (which default to the
beginning and end of the string, respectively).

 Return a pair consisting of the delimiter that terminated the
string and the number of characters read.  If reading stopped
at the end of file, the delimiter returned is the
@var{eof-object}; if the string was filled without encountering
a delimiter, this value is @code{#f}.
@end deffn

%read-line
@deffn {Scheme Procedure} %read-line [port]
@deffnx {C Function} scm_read_line (port)
Read a newline-terminated line from @var{port}, allocating storage as
necessary.  The newline terminator (if any) is removed from the string,
and a pair consisting of the line and its delimiter is returned.  The
delimiter may be either a newline or the @var{eof-object}; if
@code{%read-line} is called at the end of file, it returns the pair
@code{(#<eof> . #<eof>)}.
@end deffn

write-line
@deffn {Scheme Procedure} write-line obj [port]
@deffnx {C Function} scm_write_line (obj, port)
Display @var{obj} and a newline character to @var{port}.  If
@var{port} is not specified, @code{(current-output-port)} is
used.  This function is equivalent to:
@lisp
(display obj [port])
(newline [port])
@end lisp
@end deffn

read-options-interface
@deffn {Scheme Procedure} read-options-interface [setting]
@deffnx {C Function} scm_read_options (setting)
Option interface for the read options. Instead of using
this procedure directly, use the procedures @code{read-enable},
@code{read-disable}, @code{read-set!} and @code{read-options}.
@end deffn

read
@deffn {Scheme Procedure} read [port]
@deffnx {C Function} scm_read (port)
Read an s-expression from the input port @var{port}, or from
the current input port if @var{port} is not specified.
Any whitespace before the next token is discarded.
@end deffn

read-hash-extend
@deffn {Scheme Procedure} read-hash-extend chr proc
@deffnx {C Function} scm_read_hash_extend (chr, proc)
Install the procedure @var{proc} for reading expressions
starting with the character sequence @code{#} and @var{chr}.
@var{proc} will be called with two arguments:  the character
@var{chr} and the port to read further data from. The object
returned will be the return value of @code{read}.
@end deffn

call-with-dynamic-root
@deffn {Scheme Procedure} call-with-dynamic-root thunk handler
@deffnx {C Function} scm_call_with_dynamic_root (thunk, handler)
Evaluate @code{(thunk)} in a new dynamic context, returning its value.

If an error occurs during evaluation, apply @var{handler} to the
arguments to the throw, just as @code{throw} would.  If this happens,
@var{handler} is called outside the scope of the new root -- it is
called in the same dynamic context in which
@code{call-with-dynamic-root} was evaluated.

If @var{thunk} captures a continuation, the continuation is rooted at
the call to @var{thunk}.  In particular, the call to
@code{call-with-dynamic-root} is not captured.  Therefore,
@code{call-with-dynamic-root} always returns at most one time.

Before calling @var{thunk}, the dynamic-wind chain is un-wound back to
the root and a new chain started for @var{thunk}.  Therefore, this call
may not do what you expect:

@lisp
;; Almost certainly a bug:
(with-output-to-port
 some-port

 (lambda ()
   (call-with-dynamic-root
    (lambda ()
      (display 'fnord)
      (newline))
    (lambda (errcode) errcode))))
@end lisp

The problem is, on what port will @samp{fnord} be displayed?  You
might expect that because of the @code{with-output-to-port} that
it will be displayed on the port bound to @code{some-port}.  But it
probably won't -- before evaluating the thunk, dynamic winds are
unwound, including those created by @code{with-output-to-port}.
So, the standard output port will have been re-set to its default value
before @code{display} is evaluated.

(This function was added to Guile mostly to help calls to functions in C
libraries that can not tolerate non-local exits or calls that return
multiple times.  If such functions call back to the interpreter, it should
be under a new dynamic root.)
@end deffn

dynamic-root
@deffn {Scheme Procedure} dynamic-root
@deffnx {C Function} scm_dynamic_root ()
Return an object representing the current dynamic root.

These objects are only useful for comparison using @code{eq?}.
They are currently represented as numbers, but your code should
in no way depend on this.
@end deffn

read-string!/partial
@deffn {Scheme Procedure} read-string!/partial str [port_or_fdes [start [end]]]
@deffnx {C Function} scm_read_string_x_partial (str, port_or_fdes, start, end)
Read characters from a port or file descriptor into a
string @var{str}.  A port must have an underlying file
descriptor --- a so-called fport.  This procedure is
scsh-compatible and can efficiently read large strings.
It will:

@itemize
@item
attempt to fill the entire string, unless the @var{start}
and/or @var{end} arguments are supplied.  i.e., @var{start}
defaults to 0 and @var{end} defaults to
@code{(string-length str)}
@item
use the current input port if @var{port_or_fdes} is not
supplied.
@item
return fewer than the requested number of characters in some
cases, e.g., on end of file, if interrupted by a signal, or if
not all the characters are immediately available.
@item
wait indefinitely for some input if no characters are
currently available,
unless the port is in non-blocking mode.
@item
read characters from the port's input buffers if available,
instead from the underlying file descriptor.
@item
return @code{#f} if end-of-file is encountered before reading
any characters, otherwise return the number of characters
read.
@item
return 0 if the port is in non-blocking mode and no characters
are immediately available.
@item
return 0 if the request is for 0 bytes, with no
end-of-file check.
@end itemize
@end deffn

write-string/partial
@deffn {Scheme Procedure} write-string/partial str [port_or_fdes [start [end]]]
@deffnx {C Function} scm_write_string_partial (str, port_or_fdes, start, end)
Write characters from a string @var{str} to a port or file
descriptor.  A port must have an underlying file descriptor
--- a so-called fport.  This procedure is
scsh-compatible and can efficiently write large strings.
It will:

@itemize
@item
attempt to write the entire string, unless the @var{start}
and/or @var{end} arguments are supplied.  i.e., @var{start}
defaults to 0 and @var{end} defaults to
@code{(string-length str)}
@item
use the current output port if @var{port_of_fdes} is not
supplied.
@item
in the case of a buffered port, store the characters in the
port's output buffer, if all will fit.  If they will not fit
then any existing buffered characters will be flushed
before attempting
to write the new characters directly to the underlying file
descriptor.  If the port is in non-blocking mode and
buffered characters can not be flushed immediately, then an
@code{EAGAIN} system-error exception will be raised (Note:
scsh does not support the use of non-blocking buffered ports.)
@item
write fewer than the requested number of
characters in some cases, e.g., if interrupted by a signal or
if not all of the output can be accepted immediately.
@item
wait indefinitely for at least one character
from @var{str} to be accepted by the port, unless the port is
in non-blocking mode.
@item
return the number of characters accepted by the port.
@item
return 0 if the port is in non-blocking mode and can not accept
at least one character from @var{str} immediately
@item
return 0 immediately if the request size is 0 bytes.
@end itemize
@end deffn

sigaction
@deffn {Scheme Procedure} sigaction signum [handler [flags [thread]]]
@deffnx {C Function} scm_sigaction_for_thread (signum, handler, flags, thread)
Install or report the signal handler for a specified signal.

@var{signum} is the signal number, which can be specified using the value
of variables such as @code{SIGINT}.

If @var{handler} is omitted, @code{sigaction} returns a pair: the
CAR is the current
signal hander, which will be either an integer with the value @code{SIG_DFL}
(default action) or @code{SIG_IGN} (ignore), or the Scheme procedure which
handles the signal, or @code{#f} if a non-Scheme procedure handles the
signal.  The CDR contains the current @code{sigaction} flags for the handler.

If @var{handler} is provided, it is installed as the new handler for
@var{signum}.  @var{handler} can be a Scheme procedure taking one
argument, or the value of @code{SIG_DFL} (default action) or
@code{SIG_IGN} (ignore), or @code{#f} to restore whatever signal handler
was installed before @code{sigaction} was first used.  When
a scheme procedure has been specified, that procedure will run
in the given @var{thread}.   When no thread has been given, the
thread that made this call to @code{sigaction} is used.
Flags can optionally be specified for the new handler (@code{SA_RESTART} will
always be added if it's available and the system is using restartable
system calls.)  The return value is a pair with information about the
old handler as described above.

This interface does not provide access to the "signal blocking"
facility.  Maybe this is not needed, since the thread support may
provide solutions to the problem of consistent access to data
structures.
@end deffn

restore-signals
@deffn {Scheme Procedure} restore-signals
@deffnx {C Function} scm_restore_signals ()
Return all signal handlers to the values they had before any call to
@code{sigaction} was made.  The return value is unspecified.
@end deffn

alarm
@deffn {Scheme Procedure} alarm i
@deffnx {C Function} scm_alarm (i)
Set a timer to raise a @code{SIGALRM} signal after the specified
number of seconds (an integer).  It's advisable to install a signal
handler for
@code{SIGALRM} beforehand, since the default action is to terminate
the process.

The return value indicates the time remaining for the previous alarm,
if any.  The new value replaces the previous alarm.  If there was
no previous alarm, the return value is zero.
@end deffn

setitimer
@deffn {Scheme Procedure} setitimer which_timer interval_seconds interval_microseconds value_seconds value_microseconds
@deffnx {C Function} scm_setitimer (which_timer, interval_seconds, interval_microseconds, value_seconds, value_microseconds)
Set the timer specified by @var{which_timer} according to the given
@var{interval_seconds}, @var{interval_microseconds},
@var{value_seconds}, and @var{value_microseconds} values.

Return information about the timer's previous setting.
Errors are handled as described in the guile info pages under ``POSIX
Interface Conventions''.

The timers available are: @code{ITIMER_REAL}, @code{ITIMER_VIRTUAL},
and @code{ITIMER_PROF}.

The return value will be a list of two cons pairs representing the
current state of the given timer.  The first pair is the seconds and
microseconds of the timer @code{it_interval}, and the second pair is
the seconds and microseconds of the timer @code{it_value}.
@end deffn

getitimer
@deffn {Scheme Procedure} getitimer which_timer
@deffnx {C Function} scm_getitimer (which_timer)
Return information about the timer specified by @var{which_timer}
Errors are handled as described in the guile info pages under ``POSIX
Interface Conventions''.

The timers available are: @code{ITIMER_REAL}, @code{ITIMER_VIRTUAL},
and @code{ITIMER_PROF}.

The return value will be a list of two cons pairs representing the
current state of the given timer.  The first pair is the seconds and
microseconds of the timer @code{it_interval}, and the second pair is
the seconds and microseconds of the timer @code{it_value}.
@end deffn

pause
@deffn {Scheme Procedure} pause
@deffnx {C Function} scm_pause ()
Pause the current process (thread?) until a signal arrives whose
action is to either terminate the current process or invoke a
handler procedure.  The return value is unspecified.
@end deffn

sleep
@deffn {Scheme Procedure} sleep i
@deffnx {C Function} scm_sleep (i)
Wait for the given number of seconds (an integer) or until a signal
arrives.  The return value is zero if the time elapses or the number
of seconds remaining otherwise.
@end deffn

usleep
@deffn {Scheme Procedure} usleep i
@deffnx {C Function} scm_usleep (i)
Sleep for I microseconds.  @code{usleep} is not available on
all platforms.
@end deffn

raise
@deffn {Scheme Procedure} raise sig
@deffnx {C Function} scm_raise (sig)
Sends a specified signal @var{sig} to the current process, where
@var{sig} is as described for the kill procedure.
@end deffn

system
@deffn {Scheme Procedure} system [cmd]
@deffnx {C Function} scm_system (cmd)
Execute @var{cmd} using the operating system's "command
processor".  Under Unix this is usually the default shell
@code{sh}.  The value returned is @var{cmd}'s exit status as
returned by @code{waitpid}, which can be interpreted using the
functions above.

If @code{system} is called without arguments, return a boolean
indicating whether the command processor is available.
@end deffn

getenv
@deffn {Scheme Procedure} getenv nam
@deffnx {C Function} scm_getenv (nam)
Looks up the string @var{name} in the current environment.  The return
value is @code{#f} unless a string of the form @code{NAME=VALUE} is
found, in which case the string @code{VALUE} is returned.
@end deffn

primitive-exit
@deffn {Scheme Procedure} primitive-exit [status]
@deffnx {C Function} scm_primitive_exit (status)
Terminate the current process without unwinding the Scheme stack.
This is would typically be useful after a fork.  The exit status
is @var{status} if supplied, otherwise zero.
@end deffn

restricted-vector-sort!
@deffn {Scheme Procedure} restricted-vector-sort! vec less startpos endpos
@deffnx {C Function} scm_restricted_vector_sort_x (vec, less, startpos, endpos)
Sort the vector @var{vec}, using @var{less} for comparing
the vector elements.  @var{startpos} and @var{endpos} delimit
the range of the vector which gets sorted.  The return value
is not specified.
@end deffn

sorted?
@deffn {Scheme Procedure} sorted? items less
@deffnx {C Function} scm_sorted_p (items, less)
Return @code{#t} iff @var{items} is a list or a vector such that
for all 1 <= i <= m, the predicate @var{less} returns true when
applied to all elements i - 1 and i
@end deffn

merge
@deffn {Scheme Procedure} merge alist blist less
@deffnx {C Function} scm_merge (alist, blist, less)
Merge two already sorted lists into one.
Given two lists @var{alist} and @var{blist}, such that
@code{(sorted? alist less?)} and @code{(sorted? blist less?)},
return a new list in which the elements of @var{alist} and
@var{blist} have been stably interleaved so that
@code{(sorted? (merge alist blist less?) less?)}.
Note:  this does _not_ accept vectors.
@end deffn

merge!
@deffn {Scheme Procedure} merge! alist blist less
@deffnx {C Function} scm_merge_x (alist, blist, less)
Takes two lists @var{alist} and @var{blist} such that
@code{(sorted? alist less?)} and @code{(sorted? blist less?)} and
returns a new list in which the elements of @var{alist} and
@var{blist} have been stably interleaved so that
 @code{(sorted? (merge alist blist less?) less?)}.
This is the destructive variant of @code{merge}
Note:  this does _not_ accept vectors.
@end deffn

sort!
@deffn {Scheme Procedure} sort! items less
@deffnx {C Function} scm_sort_x (items, less)
Sort the sequence @var{items}, which may be a list or a
vector.  @var{less} is used for comparing the sequence
elements.  The sorting is destructive, that means that the
input sequence is modified to produce the sorted result.
This is not a stable sort.
@end deffn

sort
@deffn {Scheme Procedure} sort items less
@deffnx {C Function} scm_sort (items, less)
Sort the sequence @var{items}, which may be a list or a
vector.  @var{less} is used for comparing the sequence
elements.  This is not a stable sort.
@end deffn

stable-sort!
@deffn {Scheme Procedure} stable-sort! items less
@deffnx {C Function} scm_stable_sort_x (items, less)
Sort the sequence @var{items}, which may be a list or a
vector. @var{less} is used for comparing the sequence elements.
The sorting is destructive, that means that the input sequence
is modified to produce the sorted result.
This is a stable sort.
@end deffn

stable-sort
@deffn {Scheme Procedure} stable-sort items less
@deffnx {C Function} scm_stable_sort (items, less)
Sort the sequence @var{items}, which may be a list or a
vector. @var{less} is used for comparing the sequence elements.
This is a stable sort.
@end deffn

sort-list!
@deffn {Scheme Procedure} sort-list! items less
@deffnx {C Function} scm_sort_list_x (items, less)
Sort the list @var{items}, using @var{less} for comparing the
list elements. The sorting is destructive, that means that the
input list is modified to produce the sorted result.
This is a stable sort.
@end deffn

sort-list
@deffn {Scheme Procedure} sort-list items less
@deffnx {C Function} scm_sort_list (items, less)
Sort the list @var{items}, using @var{less} for comparing the
list elements. This is a stable sort.
@end deffn

source-properties
@deffn {Scheme Procedure} source-properties obj
@deffnx {C Function} scm_source_properties (obj)
Return the source property association list of @var{obj}.
@end deffn

set-source-properties!
@deffn {Scheme Procedure} set-source-properties! obj plist
@deffnx {C Function} scm_set_source_properties_x (obj, plist)
Install the association list @var{plist} as the source property
list for @var{obj}.
@end deffn

source-property
@deffn {Scheme Procedure} source-property obj key
@deffnx {C Function} scm_source_property (obj, key)
Return the source property specified by @var{key} from
@var{obj}'s source property list.
@end deffn

set-source-property!
@deffn {Scheme Procedure} set-source-property! obj key datum
@deffnx {C Function} scm_set_source_property_x (obj, key, datum)
Set the source property of object @var{obj}, which is specified by
@var{key} to @var{datum}.  Normally, the key will be a symbol.
@end deffn

stack?
@deffn {Scheme Procedure} stack? obj
@deffnx {C Function} scm_stack_p (obj)
Return @code{#t} if @var{obj} is a calling stack.
@end deffn

make-stack
@deffn {Scheme Procedure} make-stack obj . args
@deffnx {C Function} scm_make_stack (obj, args)
Create a new stack. If @var{obj} is @code{#t}, the current
evaluation stack is used for creating the stack frames,
otherwise the frames are taken from @var{obj} (which must be
either a debug object or a continuation).

@var{args} should be a list containing any combination of
integer, procedure and @code{#t} values.

These values specify various ways of cutting away uninteresting
stack frames from the top and bottom of the stack that
@code{make-stack} returns.  They come in pairs like this:
@code{(@var{inner_cut_1} @var{outer_cut_1} @var{inner_cut_2}
@var{outer_cut_2} @dots{})}.

Each @var{inner_cut_N} can be @code{#t}, an integer, or a
procedure.  @code{#t} means to cut away all frames up to but
excluding the first user module frame.  An integer means to cut
away exactly that number of frames.  A procedure means to cut
away all frames up to but excluding the application frame whose
procedure matches the specified one.

Each @var{outer_cut_N} can be an integer or a procedure.  An
integer means to cut away that number of frames.  A procedure
means to cut away frames down to but excluding the application
frame whose procedure matches the specified one.

If the @var{outer_cut_N} of the last pair is missing, it is
taken as 0.
@end deffn

stack-id
@deffn {Scheme Procedure} stack-id stack
@deffnx {C Function} scm_stack_id (stack)
Return the identifier given to @var{stack} by @code{start-stack}.
@end deffn

stack-ref
@deffn {Scheme Procedure} stack-ref stack index
@deffnx {C Function} scm_stack_ref (stack, index)
Return the @var{index}'th frame from @var{stack}.
@end deffn

stack-length
@deffn {Scheme Procedure} stack-length stack
@deffnx {C Function} scm_stack_length (stack)
Return the length of @var{stack}.
@end deffn

frame?
@deffn {Scheme Procedure} frame? obj
@deffnx {C Function} scm_frame_p (obj)
Return @code{#t} if @var{obj} is a stack frame.
@end deffn

last-stack-frame
@deffn {Scheme Procedure} last-stack-frame obj
@deffnx {C Function} scm_last_stack_frame (obj)
Return a stack which consists of a single frame, which is the
last stack frame for @var{obj}. @var{obj} must be either a
debug object or a continuation.
@end deffn

frame-number
@deffn {Scheme Procedure} frame-number frame
@deffnx {C Function} scm_frame_number (frame)
Return the frame number of @var{frame}.
@end deffn

frame-source
@deffn {Scheme Procedure} frame-source frame
@deffnx {C Function} scm_frame_source (frame)
Return the source of @var{frame}.
@end deffn

frame-procedure
@deffn {Scheme Procedure} frame-procedure frame
@deffnx {C Function} scm_frame_procedure (frame)
Return the procedure for @var{frame}, or @code{#f} if no
procedure is associated with @var{frame}.
@end deffn

frame-arguments
@deffn {Scheme Procedure} frame-arguments frame
@deffnx {C Function} scm_frame_arguments (frame)
Return the arguments of @var{frame}.
@end deffn

frame-previous
@deffn {Scheme Procedure} frame-previous frame
@deffnx {C Function} scm_frame_previous (frame)
Return the previous frame of @var{frame}, or @code{#f} if
@var{frame} is the first frame in its stack.
@end deffn

frame-next
@deffn {Scheme Procedure} frame-next frame
@deffnx {C Function} scm_frame_next (frame)
Return the next frame of @var{frame}, or @code{#f} if
@var{frame} is the last frame in its stack.
@end deffn

frame-real?
@deffn {Scheme Procedure} frame-real? frame
@deffnx {C Function} scm_frame_real_p (frame)
Return @code{#t} if @var{frame} is a real frame.
@end deffn

frame-procedure?
@deffn {Scheme Procedure} frame-procedure? frame
@deffnx {C Function} scm_frame_procedure_p (frame)
Return @code{#t} if a procedure is associated with @var{frame}.
@end deffn

frame-evaluating-args?
@deffn {Scheme Procedure} frame-evaluating-args? frame
@deffnx {C Function} scm_frame_evaluating_args_p (frame)
Return @code{#t} if @var{frame} contains evaluated arguments.
@end deffn

frame-overflow?
@deffn {Scheme Procedure} frame-overflow? frame
@deffnx {C Function} scm_frame_overflow_p (frame)
Return @code{#t} if @var{frame} is an overflow frame.
@end deffn

get-internal-real-time
@deffn {Scheme Procedure} get-internal-real-time
@deffnx {C Function} scm_get_internal_real_time ()
Return the number of time units since the interpreter was
started.
@end deffn

times
@deffn {Scheme Procedure} times
@deffnx {C Function} scm_times ()
Return an object with information about real and processor
time.  The following procedures accept such an object as an
argument and return a selected component:

@table @code
@item tms:clock
The current real time, expressed as time units relative to an
arbitrary base.
@item tms:utime
The CPU time units used by the calling process.
@item tms:stime
The CPU time units used by the system on behalf of the calling
process.
@item tms:cutime
The CPU time units used by terminated child processes of the
calling process, whose status has been collected (e.g., using
@code{waitpid}).
@item tms:cstime
Similarly, the CPU times units used by the system on behalf of
terminated child processes.
@end table
@end deffn

get-internal-run-time
@deffn {Scheme Procedure} get-internal-run-time
@deffnx {C Function} scm_get_internal_run_time ()
Return the number of time units of processor time used by the
interpreter.  Both @emph{system} and @emph{user} time are
included but subprocesses are not.
@end deffn

current-time
@deffn {Scheme Procedure} current-time
@deffnx {C Function} scm_current_time ()
Return the number of seconds since 1970-01-01 00:00:00 UTC,
excluding leap seconds.
@end deffn

gettimeofday
@deffn {Scheme Procedure} gettimeofday
@deffnx {C Function} scm_gettimeofday ()
Return a pair containing the number of seconds and microseconds
since 1970-01-01 00:00:00 UTC, excluding leap seconds.  Note:
whether true microsecond resolution is available depends on the
operating system.
@end deffn

localtime
@deffn {Scheme Procedure} localtime time [zone]
@deffnx {C Function} scm_localtime (time, zone)
Return an object representing the broken down components of
@var{time}, an integer like the one returned by
@code{current-time}.  The time zone for the calculation is
optionally specified by @var{zone} (a string), otherwise the
@code{TZ} environment variable or the system default is used.
@end deffn

gmtime
@deffn {Scheme Procedure} gmtime time
@deffnx {C Function} scm_gmtime (time)
Return an object representing the broken down components of
@var{time}, an integer like the one returned by
@code{current-time}.  The values are calculated for UTC.
@end deffn

mktime
@deffn {Scheme Procedure} mktime sbd_time [zone]
@deffnx {C Function} scm_mktime (sbd_time, zone)
@var{bd-time} is an object representing broken down time and @code{zone}
is an optional time zone specifier (otherwise the TZ environment variable
or the system default is used).

Returns a pair: the car is a corresponding
integer time value like that returned
by @code{current-time}; the cdr is a broken down time object, similar to
as @var{bd-time} but with normalized values.
@end deffn

tzset
@deffn {Scheme Procedure} tzset
@deffnx {C Function} scm_tzset ()
Initialize the timezone from the TZ environment variable
or the system default.  It's not usually necessary to call this procedure
since it's done automatically by other procedures that depend on the
timezone.
@end deffn

strftime
@deffn {Scheme Procedure} strftime format stime
@deffnx {C Function} scm_strftime (format, stime)
Formats a time specification @var{time} using @var{template}.  @var{time}
is an object with time components in the form returned by @code{localtime}
or @code{gmtime}.  @var{template} is a string which can include formatting
specifications introduced by a @code{%} character.  The formatting of
month and day names is dependent on the current locale.  The value returned
is the formatted string.
@xref{Formatting Date and Time, , , libc, The GNU C Library Reference Manual}.)
@end deffn

strptime
@deffn {Scheme Procedure} strptime format string
@deffnx {C Function} scm_strptime (format, string)
Performs the reverse action to @code{strftime}, parsing
@var{string} according to the specification supplied in
@var{template}.  The interpretation of month and day names is
dependent on the current locale.  The value returned is a pair.
The car has an object with time components
in the form returned by @code{localtime} or @code{gmtime},
but the time zone components
are not usefully set.
The cdr reports the number of characters from @var{string}
which were used for the conversion.
@end deffn

string?
@deffn {Scheme Procedure} string? obj
@deffnx {C Function} scm_string_p (obj)
Return @code{#t} if @var{obj} is a string, else @code{#f}.
@end deffn

list->string
@deffn {Scheme Procedure} list->string
implemented by the C function "scm_string"
@end deffn

string
@deffn {Scheme Procedure} string . chrs
@deffnx {Scheme Procedure} list->string chrs
@deffnx {C Function} scm_string (chrs)
Return a newly allocated string composed of the arguments,
@var{chrs}.
@end deffn

make-string
@deffn {Scheme Procedure} make-string k [chr]
@deffnx {C Function} scm_make_string (k, chr)
Return a newly allocated string of
length @var{k}.  If @var{chr} is given, then all elements of
the string are initialized to @var{chr}, otherwise the contents
of the @var{string} are unspecified.
@end deffn

string-length
@deffn {Scheme Procedure} string-length string
@deffnx {C Function} scm_string_length (string)
Return the number of characters in @var{string}.
@end deffn

string-ref
@deffn {Scheme Procedure} string-ref str k
@deffnx {C Function} scm_string_ref (str, k)
Return character @var{k} of @var{str} using zero-origin
indexing. @var{k} must be a valid index of @var{str}.
@end deffn

string-set!
@deffn {Scheme Procedure} string-set! str k chr
@deffnx {C Function} scm_string_set_x (str, k, chr)
Store @var{chr} in element @var{k} of @var{str} and return
an unspecified value. @var{k} must be a valid index of
@var{str}.
@end deffn

substring
@deffn {Scheme Procedure} substring str start [end]
@deffnx {C Function} scm_substring (str, start, end)
Return a newly allocated string formed from the characters
of @var{str} beginning with index @var{start} (inclusive) and
ending with index @var{end} (exclusive).
@var{str} must be a string, @var{start} and @var{end} must be
exact integers satisfying:

0 <= @var{start} <= @var{end} <= (string-length @var{str}).
@end deffn

string-append
@deffn {Scheme Procedure} string-append . args
@deffnx {C Function} scm_string_append (args)
Return a newly allocated string whose characters form the
concatenation of the given strings, @var{args}.
@end deffn

string-index
@deffn {Scheme Procedure} string-index str chr [frm [to]]
@deffnx {C Function} scm_string_index (str, chr, frm, to)
Return the index of the first occurrence of @var{chr} in
@var{str}.  The optional integer arguments @var{frm} and
@var{to} limit the search to a portion of the string.  This
procedure essentially implements the @code{index} or
@code{strchr} functions from the C library.

@lisp
(string-index "weiner" #\e)
@result{} 1

(string-index "weiner" #\e 2)
@result{} 4

(string-index "weiner" #\e 2 4)
@result{} #f
@end lisp
@end deffn

string-rindex
@deffn {Scheme Procedure} string-rindex str chr [frm [to]]
@deffnx {C Function} scm_string_rindex (str, chr, frm, to)
Like @code{string-index}, but search from the right of the
string rather than from the left.  This procedure essentially
implements the @code{rindex} or @code{strrchr} functions from
the C library.

@lisp
(string-rindex "weiner" #\e)
@result{} 4

(string-rindex "weiner" #\e 2 4)
@result{} #f

(string-rindex "weiner" #\e 2 5)
@result{} 4
@end lisp
@end deffn

substring-move!
@deffn {Scheme Procedure} substring-move! str1 start1 end1 str2 start2
@deffnx {C Function} scm_substring_move_x (str1, start1, end1, str2, start2)
Copy the substring of @var{str1} bounded by @var{start1} and @var{end1}
into @var{str2} beginning at position @var{start2}.
@var{str1} and @var{str2} can be the same string.
@end deffn

substring-fill!
@deffn {Scheme Procedure} substring-fill! str start end fill
@deffnx {C Function} scm_substring_fill_x (str, start, end, fill)
Change every character in @var{str} between @var{start} and
@var{end} to @var{fill}.

@lisp
(define y "abcdefg")
(substring-fill! y 1 3 #\r)
y
@result{} "arrdefg"
@end lisp
@end deffn

string-null?
@deffn {Scheme Procedure} string-null? str
@deffnx {C Function} scm_string_null_p (str)
Return @code{#t} if @var{str}'s length is zero, and
@code{#f} otherwise.
@lisp
(string-null? "")  @result{} #t
y                    @result{} "foo"
(string-null? y)     @result{} #f
@end lisp
@end deffn

string->list
@deffn {Scheme Procedure} string->list str
@deffnx {C Function} scm_string_to_list (str)
Return a newly allocated list of the characters that make up
the given string @var{str}. @code{string->list} and
@code{list->string} are inverses as far as @samp{equal?} is
concerned.
@end deffn

string-copy
@deffn {Scheme Procedure} string-copy str
@deffnx {C Function} scm_string_copy (str)
Return a newly allocated copy of the given @var{string}.
@end deffn

string-fill!
@deffn {Scheme Procedure} string-fill! str chr
@deffnx {C Function} scm_string_fill_x (str, chr)
Store @var{char} in every element of the given @var{string} and
return an unspecified value.
@end deffn

string-upcase!
@deffn {Scheme Procedure} string-upcase! str
@deffnx {C Function} scm_string_upcase_x (str)
Destructively upcase every character in @var{str} and return
@var{str}.
@lisp
y                  @result{} "arrdefg"
(string-upcase! y) @result{} "ARRDEFG"
y                  @result{} "ARRDEFG"
@end lisp
@end deffn

string-upcase
@deffn {Scheme Procedure} string-upcase str
@deffnx {C Function} scm_string_upcase (str)
Return a freshly allocated string containing the characters of
@var{str} in upper case.
@end deffn

string-downcase!
@deffn {Scheme Procedure} string-downcase! str
@deffnx {C Function} scm_string_downcase_x (str)
Destructively downcase every character in @var{str} and return
@var{str}.
@lisp
y                     @result{} "ARRDEFG"
(string-downcase! y)  @result{} "arrdefg"
y                     @result{} "arrdefg"
@end lisp
@end deffn

string-downcase
@deffn {Scheme Procedure} string-downcase str
@deffnx {C Function} scm_string_downcase (str)
Return a freshly allocation string containing the characters in
@var{str} in lower case.
@end deffn

string-capitalize!
@deffn {Scheme Procedure} string-capitalize! str
@deffnx {C Function} scm_string_capitalize_x (str)
Upcase the first character of every word in @var{str}
destructively and return @var{str}.

@lisp
y                      @result{} "hello world"
(string-capitalize! y) @result{} "Hello World"
y                      @result{} "Hello World"
@end lisp
@end deffn

string-capitalize
@deffn {Scheme Procedure} string-capitalize str
@deffnx {C Function} scm_string_capitalize (str)
Return a freshly allocated string with the characters in
@var{str}, where the first character of every word is
capitalized.
@end deffn

string-split
@deffn {Scheme Procedure} string-split str chr
@deffnx {C Function} scm_string_split (str, chr)
Split the string @var{str} into the a list of the substrings delimited
by appearances of the character @var{chr}.  Note that an empty substring
between separator characters will result in an empty string in the
result list.

@lisp
(string-split "root:x:0:0:root:/root:/bin/bash" #\:)
@result{}
("root" "x" "0" "0" "root" "/root" "/bin/bash")

(string-split "::" #\:)
@result{}
("" "" "")

(string-split "" #\:)
@result{}
("")
@end lisp
@end deffn

string-ci->symbol
@deffn {Scheme Procedure} string-ci->symbol str
@deffnx {C Function} scm_string_ci_to_symbol (str)
Return the symbol whose name is @var{str}.  @var{str} is
converted to lowercase before the conversion is done, if Guile
is currently reading symbols case-insensitively.
@end deffn

string=?
@deffn {Scheme Procedure} string=? s1 s2
Lexicographic equality predicate; return @code{#t} if the two
strings are the same length and contain the same characters in
the same positions, otherwise return @code{#f}.

The procedure @code{string-ci=?} treats upper and lower case
letters as though they were the same character, but
@code{string=?} treats upper and lower case as distinct
characters.
@end deffn

string-ci=?
@deffn {Scheme Procedure} string-ci=? s1 s2
Case-insensitive string equality predicate; return @code{#t} if
the two strings are the same length and their component
characters match (ignoring case) at each position; otherwise
return @code{#f}.
@end deffn

string<?
@deffn {Scheme Procedure} string<? s1 s2
Lexicographic ordering predicate; return @code{#t} if @var{s1}
is lexicographically less than @var{s2}.
@end deffn

string<=?
@deffn {Scheme Procedure} string<=? s1 s2
Lexicographic ordering predicate; return @code{#t} if @var{s1}
is lexicographically less than or equal to @var{s2}.
@end deffn

string>?
@deffn {Scheme Procedure} string>? s1 s2
Lexicographic ordering predicate; return @code{#t} if @var{s1}
is lexicographically greater than @var{s2}.
@end deffn

string>=?
@deffn {Scheme Procedure} string>=? s1 s2
Lexicographic ordering predicate; return @code{#t} if @var{s1}
is lexicographically greater than or equal to @var{s2}.
@end deffn

string-ci<?
@deffn {Scheme Procedure} string-ci<? s1 s2
Case insensitive lexicographic ordering predicate; return
@code{#t} if @var{s1} is lexicographically less than @var{s2}
regardless of case.
@end deffn

string-ci<=?
@deffn {Scheme Procedure} string-ci<=? s1 s2
Case insensitive lexicographic ordering predicate; return
@code{#t} if @var{s1} is lexicographically less than or equal
to @var{s2} regardless of case.
@end deffn

string-ci>?
@deffn {Scheme Procedure} string-ci>? s1 s2
Case insensitive lexicographic ordering predicate; return
@code{#t} if @var{s1} is lexicographically greater than
@var{s2} regardless of case.
@end deffn

string-ci>=?
@deffn {Scheme Procedure} string-ci>=? s1 s2
Case insensitive lexicographic ordering predicate; return
@code{#t} if @var{s1} is lexicographically greater than or
equal to @var{s2} regardless of case.
@end deffn

object->string
@deffn {Scheme Procedure} object->string obj [printer]
@deffnx {C Function} scm_object_to_string (obj, printer)
Return a Scheme string obtained by printing @var{obj}.
Printing function can be specified by the optional second
argument @var{printer} (default: @code{write}).
@end deffn

call-with-output-string
@deffn {Scheme Procedure} call-with-output-string proc
@deffnx {C Function} scm_call_with_output_string (proc)
Calls the one-argument procedure @var{proc} with a newly created output
port.  When the function returns, the string composed of the characters
written into the port is returned.
@end deffn

call-with-input-string
@deffn {Scheme Procedure} call-with-input-string string proc
@deffnx {C Function} scm_call_with_input_string (string, proc)
Calls the one-argument procedure @var{proc} with a newly
created input port from which @var{string}'s contents may be
read.  The value yielded by the @var{proc} is returned.
@end deffn

open-input-string
@deffn {Scheme Procedure} open-input-string str
@deffnx {C Function} scm_open_input_string (str)
Take a string and return an input port that delivers characters
from the string. The port can be closed by
@code{close-input-port}, though its storage will be reclaimed
by the garbage collector if it becomes inaccessible.
@end deffn

open-output-string
@deffn {Scheme Procedure} open-output-string
@deffnx {C Function} scm_open_output_string ()
Return an output port that will accumulate characters for
retrieval by @code{get-output-string}. The port can be closed
by the procedure @code{close-output-port}, though its storage
will be reclaimed by the garbage collector if it becomes
inaccessible.
@end deffn

get-output-string
@deffn {Scheme Procedure} get-output-string port
@deffnx {C Function} scm_get_output_string (port)
Given an output port created by @code{open-output-string},
return a string consisting of the characters that have been
output to the port so far.
@end deffn

eval-string
@deffn {Scheme Procedure} eval-string string [module]
@deffnx {C Function} scm_eval_string_in_module (string, module)
Evaluate @var{string} as the text representation of a Scheme
form or forms, and return whatever value they produce.
Evaluation takes place in the given module, or the current
module when no module is given.
While the code is evaluated, the given module is made the
current one.  The current module is restored when this
procedure returns.
@end deffn

make-struct-layout
@deffn {Scheme Procedure} make-struct-layout fields
@deffnx {C Function} scm_make_struct_layout (fields)
Return a new structure layout object.

@var{fields} must be a string made up of pairs of characters
strung together.  The first character of each pair describes a field
type, the second a field protection.  Allowed types are 'p' for
GC-protected Scheme data, 'u' for unprotected binary data, and 's' for
a field that points to the structure itself.    Allowed protections
are 'w' for mutable fields, 'r' for read-only fields, and 'o' for opaque
fields.  The last field protection specification may be capitalized to
indicate that the field is a tail-array.
@end deffn

struct?
@deffn {Scheme Procedure} struct? x
@deffnx {C Function} scm_struct_p (x)
Return @code{#t} iff @var{x} is a structure object, else
@code{#f}.
@end deffn

struct-vtable?
@deffn {Scheme Procedure} struct-vtable? x
@deffnx {C Function} scm_struct_vtable_p (x)
Return @code{#t} iff @var{x} is a vtable structure.
@end deffn

make-struct
@deffn {Scheme Procedure} make-struct vtable tail_array_size . init
@deffnx {C Function} scm_make_struct (vtable, tail_array_size, init)
Create a new structure.

@var{type} must be a vtable structure (@pxref{Vtables}).

@var{tail-elts} must be a non-negative integer.  If the layout
specification indicated by @var{type} includes a tail-array,
this is the number of elements allocated to that array.

The @var{init1}, @dots{} are optional arguments describing how
successive fields of the structure should be initialized.  Only fields
with protection 'r' or 'w' can be initialized, except for fields of
type 's', which are automatically initialized to point to the new
structure itself; fields with protection 'o' can not be initialized by
Scheme programs.

If fewer optional arguments than initializable fields are supplied,
fields of type 'p' get default value #f while fields of type 'u' are
initialized to 0.

Structs are currently the basic representation for record-like data
structures in Guile.  The plan is to eventually replace them with a
new representation which will at the same time be easier to use and
more powerful.

For more information, see the documentation for @code{make-vtable-vtable}.
@end deffn

make-vtable-vtable
@deffn {Scheme Procedure} make-vtable-vtable user_fields tail_array_size . init
@deffnx {C Function} scm_make_vtable_vtable (user_fields, tail_array_size, init)
Return a new, self-describing vtable structure.

@var{user-fields} is a string describing user defined fields of the
vtable beginning at index @code{vtable-offset-user}
(see @code{make-struct-layout}).

@var{tail-size} specifies the size of the tail-array (if any) of
this vtable.

@var{init1}, @dots{} are the optional initializers for the fields of
the vtable.

Vtables have one initializable system field---the struct printer.
This field comes before the user fields in the initializers passed
to @code{make-vtable-vtable} and @code{make-struct}, and thus works as
a third optional argument to @code{make-vtable-vtable} and a fourth to
@code{make-struct} when creating vtables:

If the value is a procedure, it will be called instead of the standard
printer whenever a struct described by this vtable is printed.
The procedure will be called with arguments STRUCT and PORT.

The structure of a struct is described by a vtable, so the vtable is
in essence the type of the struct.  The vtable is itself a struct with
a vtable.  This could go on forever if it weren't for the
vtable-vtables which are self-describing vtables, and thus terminate
the chain.

There are several potential ways of using structs, but the standard
one is to use three kinds of structs, together building up a type
sub-system: one vtable-vtable working as the root and one or several
"types", each with a set of "instances".  (The vtable-vtable should be
compared to the class <class> which is the class of itself.)

@lisp
(define ball-root (make-vtable-vtable "pr" 0))

(define (make-ball-type ball-color)
  (make-struct ball-root 0
	       (make-struct-layout "pw")
               (lambda (ball port)
                 (format port "#<a ~A ball owned by ~A>"
                         (color ball)
                         (owner ball)))
               ball-color))
(define (color ball) (struct-ref (struct-vtable ball) vtable-offset-user))
(define (owner ball) (struct-ref ball 0))

(define red (make-ball-type 'red))
(define green (make-ball-type 'green))

(define (make-ball type owner) (make-struct type 0 owner))

(define ball (make-ball green 'Nisse))
ball @result{} #<a green ball owned by Nisse>
@end lisp
@end deffn

struct-ref
@deffn {Scheme Procedure} struct-ref handle pos
@deffnx {Scheme Procedure} struct-set! struct n value
@deffnx {C Function} scm_struct_ref (handle, pos)
Access (or modify) the @var{n}th field of @var{struct}.

If the field is of type 'p', then it can be set to an arbitrary value.

If the field is of type 'u', then it can only be set to a non-negative
integer value small enough to fit in one machine word.
@end deffn

struct-set!
@deffn {Scheme Procedure} struct-set! handle pos val
@deffnx {C Function} scm_struct_set_x (handle, pos, val)
Set the slot of the structure @var{handle} with index @var{pos}
to @var{val}.  Signal an error if the slot can not be written
to.
@end deffn

struct-vtable
@deffn {Scheme Procedure} struct-vtable handle
@deffnx {C Function} scm_struct_vtable (handle)
Return the vtable structure that describes the type of @var{struct}.
@end deffn

struct-vtable-tag
@deffn {Scheme Procedure} struct-vtable-tag handle
@deffnx {C Function} scm_struct_vtable_tag (handle)
Return the vtable tag of the structure @var{handle}.
@end deffn

struct-vtable-name
@deffn {Scheme Procedure} struct-vtable-name vtable
@deffnx {C Function} scm_struct_vtable_name (vtable)
Return the name of the vtable @var{vtable}.
@end deffn

set-struct-vtable-name!
@deffn {Scheme Procedure} set-struct-vtable-name! vtable name
@deffnx {C Function} scm_set_struct_vtable_name_x (vtable, name)
Set the name of the vtable @var{vtable} to @var{name}.
@end deffn

symbol?
@deffn {Scheme Procedure} symbol? obj
@deffnx {C Function} scm_symbol_p (obj)
Return @code{#t} if @var{obj} is a symbol, otherwise return
@code{#f}.
@end deffn

symbol-interned?
@deffn {Scheme Procedure} symbol-interned? symbol
@deffnx {C Function} scm_symbol_interned_p (symbol)
Return @code{#t} if @var{symbol} is interned, otherwise return
@code{#f}.
@end deffn

make-symbol
@deffn {Scheme Procedure} make-symbol name
@deffnx {C Function} scm_make_symbol (name)
Return a new uninterned symbol with the name @var{name}.  The returned symbol is guaranteed to be unique and future calls to @code{string->symbol} will not return it.
@end deffn

symbol->string
@deffn {Scheme Procedure} symbol->string s
@deffnx {C Function} scm_symbol_to_string (s)
Return the name of @var{symbol} as a string.  If the symbol was
part of an object returned as the value of a literal expression
(section @pxref{Literal expressions,,,r5rs, The Revised^5
Report on Scheme}) or by a call to the @code{read} procedure,
and its name contains alphabetic characters, then the string
returned will contain characters in the implementation's
preferred standard case---some implementations will prefer
upper case, others lower case.  If the symbol was returned by
@code{string->symbol}, the case of characters in the string
returned will be the same as the case in the string that was
passed to @code{string->symbol}.  It is an error to apply
mutation procedures like @code{string-set!} to strings returned
by this procedure.

The following examples assume that the implementation's
standard case is lower case:

@lisp
(symbol->string 'flying-fish)    @result{} "flying-fish"
(symbol->string 'Martin)         @result{}  "martin"
(symbol->string
   (string->symbol "Malvina")) @result{} "Malvina"
@end lisp
@end deffn

string->symbol
@deffn {Scheme Procedure} string->symbol string
@deffnx {C Function} scm_string_to_symbol (string)
Return the symbol whose name is @var{string}. This procedure
can create symbols with names containing special characters or
letters in the non-standard case, but it is usually a bad idea
to create such symbols because in some implementations of
Scheme they cannot be read as themselves.  See
@code{symbol->string}.

The following examples assume that the implementation's
standard case is lower case:

@lisp
(eq? 'mISSISSIppi 'mississippi) @result{} #t
(string->symbol "mISSISSIppi") @result{} @r{the symbol with name "mISSISSIppi"}
(eq? 'bitBlt (string->symbol "bitBlt")) @result{} #f
(eq? 'JollyWog
  (string->symbol (symbol->string 'JollyWog))) @result{} #t
(string=? "K. Harper, M.D."
  (symbol->string
    (string->symbol "K. Harper, M.D."))) @result{}#t
@end lisp
@end deffn

gensym
@deffn {Scheme Procedure} gensym [prefix]
@deffnx {C Function} scm_gensym (prefix)
Create a new symbol with a name constructed from a prefix and
a counter value. The string @var{prefix} can be specified as
an optional argument. Default prefix is @code{ g}.  The counter
is increased by 1 at each call. There is no provision for
resetting the counter.
@end deffn

symbol-hash
@deffn {Scheme Procedure} symbol-hash symbol
@deffnx {C Function} scm_symbol_hash (symbol)
Return a hash value for @var{symbol}.
@end deffn

symbol-fref
@deffn {Scheme Procedure} symbol-fref s
@deffnx {C Function} scm_symbol_fref (s)
Return the contents of @var{symbol}'s @dfn{function slot}.
@end deffn

symbol-pref
@deffn {Scheme Procedure} symbol-pref s
@deffnx {C Function} scm_symbol_pref (s)
Return the @dfn{property list} currently associated with @var{symbol}.
@end deffn

symbol-fset!
@deffn {Scheme Procedure} symbol-fset! s val
@deffnx {C Function} scm_symbol_fset_x (s, val)
Change the binding of @var{symbol}'s function slot.
@end deffn

symbol-pset!
@deffn {Scheme Procedure} symbol-pset! s val
@deffnx {C Function} scm_symbol_pset_x (s, val)
Change the binding of @var{symbol}'s property slot.
@end deffn

catch
@deffn {Scheme Procedure} catch key thunk handler
@deffnx {C Function} scm_catch (key, thunk, handler)
Invoke @var{thunk} in the dynamic context of @var{handler} for
exceptions matching @var{key}.  If thunk throws to the symbol
@var{key}, then @var{handler} is invoked this way:
@lisp
(handler key args ...)
@end lisp

@var{key} is a symbol or @code{#t}.

@var{thunk} takes no arguments.  If @var{thunk} returns
normally, that is the return value of @code{catch}.

Handler is invoked outside the scope of its own @code{catch}.
If @var{handler} again throws to the same key, a new handler
from further up the call chain is invoked.

If the key is @code{#t}, then a throw to @emph{any} symbol will
match this call to @code{catch}.
@end deffn

lazy-catch
@deffn {Scheme Procedure} lazy-catch key thunk handler
@deffnx {C Function} scm_lazy_catch (key, thunk, handler)
This behaves exactly like @code{catch}, except that it does
not unwind the stack before invoking @var{handler}.
The @var{handler} procedure is not allowed to return:
it must throw to another catch, or otherwise exit non-locally.
@end deffn

throw
@deffn {Scheme Procedure} throw key . args
@deffnx {C Function} scm_throw (key, args)
Invoke the catch form matching @var{key}, passing @var{args} to the
@var{handler}.  

@var{key} is a symbol.  It will match catches of the same symbol or of
@code{#t}.

If there is no handler at all, Guile prints an error and then exits.
@end deffn

values
@deffn {Scheme Procedure} values . args
@deffnx {C Function} scm_values (args)
Delivers all of its arguments to its continuation.  Except for
continuations created by the @code{call-with-values} procedure,
all continuations take exactly one value.  The effect of
passing no value or more than one value to continuations that
were not created by @code{call-with-values} is unspecified.
@end deffn

make-variable
@deffn {Scheme Procedure} make-variable init
@deffnx {C Function} scm_make_variable (init)
Return a variable initialized to value @var{init}.
@end deffn

make-undefined-variable
@deffn {Scheme Procedure} make-undefined-variable
@deffnx {C Function} scm_make_undefined_variable ()
Return a variable that is initially unbound.
@end deffn

variable?
@deffn {Scheme Procedure} variable? obj
@deffnx {C Function} scm_variable_p (obj)
Return @code{#t} iff @var{obj} is a variable object, else
return @code{#f}.
@end deffn

variable-ref
@deffn {Scheme Procedure} variable-ref var
@deffnx {C Function} scm_variable_ref (var)
Dereference @var{var} and return its value.
@var{var} must be a variable object; see @code{make-variable}
and @code{make-undefined-variable}.
@end deffn

variable-set!
@deffn {Scheme Procedure} variable-set! var val
@deffnx {C Function} scm_variable_set_x (var, val)
Set the value of the variable @var{var} to @var{val}.
@var{var} must be a variable object, @var{val} can be any
value. Return an unspecified value.
@end deffn

variable-bound?
@deffn {Scheme Procedure} variable-bound? var
@deffnx {C Function} scm_variable_bound_p (var)
Return @code{#t} iff @var{var} is bound to a value.
Throws an error if @var{var} is not a variable object.
@end deffn

vector?
@deffn {Scheme Procedure} vector? obj
@deffnx {C Function} scm_vector_p (obj)
Return @code{#t} if @var{obj} is a vector, otherwise return
@code{#f}.
@end deffn

list->vector
@deffn {Scheme Procedure} list->vector
implemented by the C function "scm_vector"
@end deffn

vector
@deffn {Scheme Procedure} vector . l
@deffnx {Scheme Procedure} list->vector l
@deffnx {C Function} scm_vector (l)
Return a newly allocated vector composed of the
given arguments.  Analogous to @code{list}.

@lisp
(vector 'a 'b 'c) @result{} #(a b c)
@end lisp
@end deffn

make-vector
@deffn {Scheme Procedure} make-vector k [fill]
@deffnx {C Function} scm_make_vector (k, fill)
Return a newly allocated vector of @var{k} elements.  If a
second argument is given, then each position is initialized to
@var{fill}.  Otherwise the initial contents of each position is
unspecified.
@end deffn

vector->list
@deffn {Scheme Procedure} vector->list v
@deffnx {C Function} scm_vector_to_list (v)
Return a newly allocated list composed of the elements of @var{v}.

@lisp
(vector->list '#(dah dah didah)) @result{}  (dah dah didah)
(list->vector '(dididit dah)) @result{}  #(dididit dah)
@end lisp
@end deffn

vector-fill!
@deffn {Scheme Procedure} vector-fill! v fill
@deffnx {C Function} scm_vector_fill_x (v, fill)
Store @var{fill} in every position of @var{vector}.  The value
returned by @code{vector-fill!} is unspecified.
@end deffn

vector-move-left!
@deffn {Scheme Procedure} vector-move-left! vec1 start1 end1 vec2 start2
@deffnx {C Function} scm_vector_move_left_x (vec1, start1, end1, vec2, start2)
Copy elements from @var{vec1}, positions @var{start1} to @var{end1},
to @var{vec2} starting at position @var{start2}.  @var{start1} and
@var{start2} are inclusive indices; @var{end1} is exclusive.

@code{vector-move-left!} copies elements in leftmost order.
Therefore, in the case where @var{vec1} and @var{vec2} refer to the
same vector, @code{vector-move-left!} is usually appropriate when
@var{start1} is greater than @var{start2}.
@end deffn

vector-move-right!
@deffn {Scheme Procedure} vector-move-right! vec1 start1 end1 vec2 start2
@deffnx {C Function} scm_vector_move_right_x (vec1, start1, end1, vec2, start2)
Copy elements from @var{vec1}, positions @var{start1} to @var{end1},
to @var{vec2} starting at position @var{start2}.  @var{start1} and
@var{start2} are inclusive indices; @var{end1} is exclusive.

@code{vector-move-right!} copies elements in rightmost order.
Therefore, in the case where @var{vec1} and @var{vec2} refer to the
same vector, @code{vector-move-right!} is usually appropriate when
@var{start1} is less than @var{start2}.
@end deffn

major-version
@deffn {Scheme Procedure} major-version
@deffnx {C Function} scm_major_version ()
Return a string containing Guile's major version number.
E.g., the 1 in "1.6.5".
@end deffn

minor-version
@deffn {Scheme Procedure} minor-version
@deffnx {C Function} scm_minor_version ()
Return a string containing Guile's minor version number.
E.g., the 6 in "1.6.5".
@end deffn

micro-version
@deffn {Scheme Procedure} micro-version
@deffnx {C Function} scm_micro_version ()
Return a string containing Guile's micro version number.
E.g., the 5 in "1.6.5".
@end deffn

version
@deffn {Scheme Procedure} version
@deffnx {Scheme Procedure} major-version
@deffnx {Scheme Procedure} minor-version
@deffnx {Scheme Procedure} micro-version
@deffnx {C Function} scm_version ()
Return a string describing Guile's version number, or its major, minor
or micro version number, respectively.

@lisp
(version) @result{} "1.6.0"
(major-version) @result{} "1"
(minor-version) @result{} "6"
(micro-version) @result{} "0"
@end lisp
@end deffn

make-soft-port
@deffn {Scheme Procedure} make-soft-port pv modes
@deffnx {C Function} scm_make_soft_port (pv, modes)
Return a port capable of receiving or delivering characters as
specified by the @var{modes} string (@pxref{File Ports,
open-file}).  @var{pv} must be a vector of length 5 or 6.  Its
components are as follows:

@enumerate 0
@item
procedure accepting one character for output
@item
procedure accepting a string for output
@item
thunk for flushing output
@item
thunk for getting one character
@item
thunk for closing port (not by garbage collection)
@item
(if present and not @code{#f}) thunk for computing the number of
characters that can be read from the port without blocking.
@end enumerate

For an output-only port only elements 0, 1, 2, and 4 need be
procedures.  For an input-only port only elements 3 and 4 need
be procedures.  Thunks 2 and 4 can instead be @code{#f} if
there is no useful operation for them to perform.

If thunk 3 returns @code{#f} or an @code{eof-object}
(@pxref{Input, eof-object?, ,r5rs, The Revised^5 Report on
Scheme}) it indicates that the port has reached end-of-file.
For example:

@lisp
(define stdout (current-output-port))
(define p (make-soft-port
           (vector
            (lambda (c) (write c stdout))
            (lambda (s) (display s stdout))
            (lambda () (display "." stdout))
            (lambda () (char-upcase (read-char)))
            (lambda () (display "@@" stdout)))
           "rw"))

(write p p) @result{} #<input-output: soft 8081e20>
@end lisp
@end deffn

make-weak-vector
@deffn {Scheme Procedure} make-weak-vector size [fill]
@deffnx {C Function} scm_make_weak_vector (size, fill)
Return a weak vector with @var{size} elements. If the optional
argument @var{fill} is given, all entries in the vector will be
set to @var{fill}. The default value for @var{fill} is the
empty list.
@end deffn

list->weak-vector
@deffn {Scheme Procedure} list->weak-vector
implemented by the C function "scm_weak_vector"
@end deffn

weak-vector
@deffn {Scheme Procedure} weak-vector . l
@deffnx {Scheme Procedure} list->weak-vector l
@deffnx {C Function} scm_weak_vector (l)
Construct a weak vector from a list: @code{weak-vector} uses
the list of its arguments while @code{list->weak-vector} uses
its only argument @var{l} (a list) to construct a weak vector
the same way @code{list->vector} would.
@end deffn

weak-vector?
@deffn {Scheme Procedure} weak-vector? obj
@deffnx {C Function} scm_weak_vector_p (obj)
Return @code{#t} if @var{obj} is a weak vector. Note that all
weak hashes are also weak vectors.
@end deffn

make-weak-key-hash-table
@deffn {Scheme Procedure} make-weak-key-hash-table size
@deffnx {Scheme Procedure} make-weak-value-hash-table size
@deffnx {Scheme Procedure} make-doubly-weak-hash-table size
@deffnx {C Function} scm_make_weak_key_hash_table (size)
Return a weak hash table with @var{size} buckets. As with any
hash table, choosing a good size for the table requires some
caution.

You can modify weak hash tables in exactly the same way you
would modify regular hash tables. (@pxref{Hash Tables})
@end deffn

make-weak-value-hash-table
@deffn {Scheme Procedure} make-weak-value-hash-table size
@deffnx {C Function} scm_make_weak_value_hash_table (size)
Return a hash table with weak values with @var{size} buckets.
(@pxref{Hash Tables})
@end deffn

make-doubly-weak-hash-table
@deffn {Scheme Procedure} make-doubly-weak-hash-table size
@deffnx {C Function} scm_make_doubly_weak_hash_table (size)
Return a hash table with weak keys and values with @var{size}
buckets.  (@pxref{Hash Tables})
@end deffn

weak-key-hash-table?
@deffn {Scheme Procedure} weak-key-hash-table? obj
@deffnx {Scheme Procedure} weak-value-hash-table? obj
@deffnx {Scheme Procedure} doubly-weak-hash-table? obj
@deffnx {C Function} scm_weak_key_hash_table_p (obj)
Return @code{#t} if @var{obj} is the specified weak hash
table. Note that a doubly weak hash table is neither a weak key
nor a weak value hash table.
@end deffn

weak-value-hash-table?
@deffn {Scheme Procedure} weak-value-hash-table? obj
@deffnx {C Function} scm_weak_value_hash_table_p (obj)
Return @code{#t} if @var{obj} is a weak value hash table.
@end deffn

doubly-weak-hash-table?
@deffn {Scheme Procedure} doubly-weak-hash-table? obj
@deffnx {C Function} scm_doubly_weak_hash_table_p (obj)
Return @code{#t} if @var{obj} is a doubly weak hash table.
@end deffn

dynamic-link
@deffn {Scheme Procedure} dynamic-link filename
@deffnx {C Function} scm_dynamic_link (filename)
Find the shared object (shared library) denoted by
@var{filename} and link it into the running Guile
application.  The returned
scheme object is a ``handle'' for the library which can
be passed to @code{dynamic-func}, @code{dynamic-call} etc.

Searching for object files is system dependent.  Normally,
if @var{filename} does have an explicit directory it will
be searched for in locations
such as @file{/usr/lib} and @file{/usr/local/lib}.
@end deffn

dynamic-object?
@deffn {Scheme Procedure} dynamic-object? obj
@deffnx {C Function} scm_dynamic_object_p (obj)
Return @code{#t} if @var{obj} is a dynamic object handle,
or @code{#f} otherwise.
@end deffn

dynamic-unlink
@deffn {Scheme Procedure} dynamic-unlink dobj
@deffnx {C Function} scm_dynamic_unlink (dobj)
Unlink a dynamic object from the application, if possible.  The
object must have been linked by @code{dynamic-link}, with 
@var{dobj} the corresponding handle.  After this procedure
is called, the handle can no longer be used to access the
object.
@end deffn

dynamic-func
@deffn {Scheme Procedure} dynamic-func name dobj
@deffnx {C Function} scm_dynamic_func (name, dobj)
Return a ``handle'' for the function @var{name} in the
shared object referred to by @var{dobj}.  The handle
can be passed to @code{dynamic-call} to actually
call the function.

Regardless whether your C compiler prepends an underscore
@samp{_} to the global names in a program, you should
@strong{not} include this underscore in @var{name}
since it will be added automatically when necessary.
@end deffn

dynamic-call
@deffn {Scheme Procedure} dynamic-call func dobj
@deffnx {C Function} scm_dynamic_call (func, dobj)
Call a C function in a dynamic object.  Two styles of
invocation are supported:

@itemize @bullet
@item @var{func} can be a function handle returned by
@code{dynamic-func}.  In this case @var{dobj} is
ignored
@item @var{func} can be a string with the name of the
function to call, with @var{dobj} the handle of the
dynamic object in which to find the function.
This is equivalent to
@smallexample

(dynamic-call (dynamic-func @var{func} @var{dobj}) #f)
@end smallexample
@end itemize

In either case, the function is passed no arguments
and its return value is ignored.
@end deffn

dynamic-args-call
@deffn {Scheme Procedure} dynamic-args-call func dobj args
@deffnx {C Function} scm_dynamic_args_call (func, dobj, args)
Call the C function indicated by @var{func} and @var{dobj},
just like @code{dynamic-call}, but pass it some arguments and
return its return value.  The C function is expected to take
two arguments and return an @code{int}, just like @code{main}:
@smallexample
int c_func (int argc, char **argv);
@end smallexample

The parameter @var{args} must be a list of strings and is
converted into an array of @code{char *}.  The array is passed
in @var{argv} and its size in @var{argc}.  The return value is
converted to a Scheme number and returned from the call to
@code{dynamic-args-call}.
@end deffn

array-fill!
@deffn {Scheme Procedure} array-fill! ra fill
@deffnx {C Function} scm_array_fill_x (ra, fill)
Store @var{fill} in every element of @var{array}.  The value returned
is unspecified.
@end deffn

array-copy-in-order!
@deffn {Scheme Procedure} array-copy-in-order!
implemented by the C function "scm_array_copy_x"
@end deffn

array-copy!
@deffn {Scheme Procedure} array-copy! src dst
@deffnx {Scheme Procedure} array-copy-in-order! src dst
@deffnx {C Function} scm_array_copy_x (src, dst)
Copy every element from vector or array @var{source} to the
corresponding element of @var{destination}.  @var{destination} must have
the same rank as @var{source}, and be at least as large in each
dimension.  The order is unspecified.
@end deffn

array-map-in-order!
@deffn {Scheme Procedure} array-map-in-order!
implemented by the C function "scm_array_map_x"
@end deffn

array-map!
@deffn {Scheme Procedure} array-map! ra0 proc . lra
@deffnx {Scheme Procedure} array-map-in-order! ra0 proc . lra
@deffnx {C Function} scm_array_map_x (ra0, proc, lra)
@var{array1}, @dots{} must have the same number of dimensions as
@var{array0} and have a range for each index which includes the range
for the corresponding index in @var{array0}.  @var{proc} is applied to
each tuple of elements of @var{array1} @dots{} and the result is stored
as the corresponding element in @var{array0}.  The value returned is
unspecified.  The order of application is unspecified.
@end deffn

array-for-each
@deffn {Scheme Procedure} array-for-each proc ra0 . lra
@deffnx {C Function} scm_array_for_each (proc, ra0, lra)
Apply @var{proc} to each tuple of elements of @var{array0} @dots{}
in row-major order.  The value returned is unspecified.
@end deffn

array-index-map!
@deffn {Scheme Procedure} array-index-map! ra proc
@deffnx {C Function} scm_array_index_map_x (ra, proc)
Apply @var{proc} to the indices of each element of @var{array} in
turn, storing the result in the corresponding element.  The value
returned and the order of application are unspecified.

One can implement @var{array-indexes} as
@lisp
(define (array-indexes array)
    (let ((ra (apply make-array #f (array-shape array))))
      (array-index-map! ra (lambda x x))
      ra))
@end lisp
Another example:
@lisp
(define (apl:index-generator n)
    (let ((v (make-uniform-vector n 1)))
      (array-index-map! v (lambda (i) i))
      v))
@end lisp
@end deffn

uniform-vector-length
@deffn {Scheme Procedure} uniform-vector-length v
@deffnx {C Function} scm_uniform_vector_length (v)
Return the number of elements in @var{uve}.
@end deffn

array?
@deffn {Scheme Procedure} array? v [prot]
@deffnx {C Function} scm_array_p (v, prot)
Return @code{#t} if the @var{obj} is an array, and @code{#f} if
not.  The @var{prototype} argument is used with uniform arrays
and is described elsewhere.
@end deffn

array-rank
@deffn {Scheme Procedure} array-rank ra
@deffnx {C Function} scm_array_rank (ra)
Return the number of dimensions of @var{obj}.  If @var{obj} is
not an array, @code{0} is returned.
@end deffn

array-dimensions
@deffn {Scheme Procedure} array-dimensions ra
@deffnx {C Function} scm_array_dimensions (ra)
@code{Array-dimensions} is similar to @code{array-shape} but replaces
elements with a @code{0} minimum with one greater than the maximum. So:
@lisp
(array-dimensions (make-array 'foo '(-1 3) 5)) @result{} ((-1 3) 5)
@end lisp
@end deffn

shared-array-root
@deffn {Scheme Procedure} shared-array-root ra
@deffnx {C Function} scm_shared_array_root (ra)
Return the root vector of a shared array.
@end deffn

shared-array-offset
@deffn {Scheme Procedure} shared-array-offset ra
@deffnx {C Function} scm_shared_array_offset (ra)
Return the root vector index of the first element in the array.
@end deffn

shared-array-increments
@deffn {Scheme Procedure} shared-array-increments ra
@deffnx {C Function} scm_shared_array_increments (ra)
For each dimension, return the distance between elements in the root vector.
@end deffn

dimensions->uniform-array
@deffn {Scheme Procedure} dimensions->uniform-array dims prot [fill]
@deffnx {Scheme Procedure} make-uniform-vector length prototype [fill]
@deffnx {C Function} scm_dimensions_to_uniform_array (dims, prot, fill)
Create and return a uniform array or vector of type
corresponding to @var{prototype} with dimensions @var{dims} or
length @var{length}.  If @var{fill} is supplied, it's used to
fill the array, otherwise @var{prototype} is used.
@end deffn

make-shared-array
@deffn {Scheme Procedure} make-shared-array oldra mapfunc . dims
@deffnx {C Function} scm_make_shared_array (oldra, mapfunc, dims)
@code{make-shared-array} can be used to create shared subarrays of other
arrays.  The @var{mapper} is a function that translates coordinates in
the new array into coordinates in the old array.  A @var{mapper} must be
linear, and its range must stay within the bounds of the old array, but
it can be otherwise arbitrary.  A simple example:
@lisp
(define fred (make-array #f 8 8))
(define freds-diagonal
  (make-shared-array fred (lambda (i) (list i i)) 8))
(array-set! freds-diagonal 'foo 3)
(array-ref fred 3 3) @result{} foo
(define freds-center
  (make-shared-array fred (lambda (i j) (list (+ 3 i) (+ 3 j))) 2 2))
(array-ref freds-center 0 0) @result{} foo
@end lisp
@end deffn

transpose-array
@deffn {Scheme Procedure} transpose-array ra . args
@deffnx {C Function} scm_transpose_array (ra, args)
Return an array sharing contents with @var{array}, but with
dimensions arranged in a different order.  There must be one
@var{dim} argument for each dimension of @var{array}.
@var{dim0}, @var{dim1}, @dots{} should be integers between 0
and the rank of the array to be returned.  Each integer in that
range must appear at least once in the argument list.

The values of @var{dim0}, @var{dim1}, @dots{} correspond to
dimensions in the array to be returned, their positions in the
argument list to dimensions of @var{array}.  Several @var{dim}s
may have the same value, in which case the returned array will
have smaller rank than @var{array}.

@lisp
(transpose-array '#2((a b) (c d)) 1 0) @result{} #2((a c) (b d))
(transpose-array '#2((a b) (c d)) 0 0) @result{} #1(a d)
(transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) @result{}
                #2((a 4) (b 5) (c 6))
@end lisp
@end deffn

enclose-array
@deffn {Scheme Procedure} enclose-array ra . axes
@deffnx {C Function} scm_enclose_array (ra, axes)
@var{dim0}, @var{dim1} @dots{} should be nonnegative integers less than
the rank of @var{array}.  @var{enclose-array} returns an array
resembling an array of shared arrays.  The dimensions of each shared
array are the same as the @var{dim}th dimensions of the original array,
the dimensions of the outer array are the same as those of the original
array that did not match a @var{dim}.

An enclosed array is not a general Scheme array.  Its elements may not
be set using @code{array-set!}.  Two references to the same element of
an enclosed array will be @code{equal?} but will not in general be
@code{eq?}.  The value returned by @var{array-prototype} when given an
enclosed array is unspecified.

examples:
@lisp
(enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1) @result{}
   #<enclosed-array (#1(a d) #1(b e) #1(c f)) (#1(1 4) #1(2 5) #1(3 6))>

(enclose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 0) @result{}
   #<enclosed-array #2((a 1) (d 4)) #2((b 2) (e 5)) #2((c 3) (f 6))>
@end lisp
@end deffn

array-in-bounds?
@deffn {Scheme Procedure} array-in-bounds? v . args
@deffnx {C Function} scm_array_in_bounds_p (v, args)
Return @code{#t} if its arguments would be acceptable to
@code{array-ref}.
@end deffn

array-ref
@deffn {Scheme Procedure} array-ref
implemented by the C function "scm_uniform_vector_ref"
@end deffn

uniform-vector-ref
@deffn {Scheme Procedure} uniform-vector-ref v args
@deffnx {Scheme Procedure} array-ref v . args
@deffnx {C Function} scm_uniform_vector_ref (v, args)
Return the element at the @code{(index1, index2)} element in
@var{array}.
@end deffn

uniform-array-set1!
@deffn {Scheme Procedure} uniform-array-set1!
implemented by the C function "scm_array_set_x"
@end deffn

array-set!
@deffn {Scheme Procedure} array-set! v obj . args
@deffnx {Scheme Procedure} uniform-array-set1! v obj args
@deffnx {C Function} scm_array_set_x (v, obj, args)
Set the element at the @code{(index1, index2)} element in @var{array} to
@var{new-value}.  The value returned by array-set! is unspecified.
@end deffn

array-contents
@deffn {Scheme Procedure} array-contents ra [strict]
@deffnx {C Function} scm_array_contents (ra, strict)
If @var{array} may be @dfn{unrolled} into a one dimensional shared array
without changing their order (last subscript changing fastest), then
@code{array-contents} returns that shared array, otherwise it returns
@code{#f}.  All arrays made by @var{make-array} and
@var{make-uniform-array} may be unrolled, some arrays made by
@var{make-shared-array} may not be.

If the optional argument @var{strict} is provided, a shared array will
be returned only if its elements are stored internally contiguous in
memory.
@end deffn

uniform-array-read!
@deffn {Scheme Procedure} uniform-array-read! ra [port_or_fd [start [end]]]
@deffnx {Scheme Procedure} uniform-vector-read! uve [port-or-fdes] [start] [end]
@deffnx {C Function} scm_uniform_array_read_x (ra, port_or_fd, start, end)
Attempt to read all elements of @var{ura}, in lexicographic order, as
binary objects from @var{port-or-fdes}.
If an end of file is encountered,
the objects up to that point are put into @var{ura}
(starting at the beginning) and the remainder of the array is
unchanged.

The optional arguments @var{start} and @var{end} allow
a specified region of a vector (or linearized array) to be read,
leaving the remainder of the vector unchanged.

@code{uniform-array-read!} returns the number of objects read.
@var{port-or-fdes} may be omitted, in which case it defaults to the value
returned by @code{(current-input-port)}.
@end deffn

uniform-array-write
@deffn {Scheme Procedure} uniform-array-write v [port_or_fd [start [end]]]
@deffnx {Scheme Procedure} uniform-vector-write uve [port-or-fdes] [start] [end]
@deffnx {C Function} scm_uniform_array_write (v, port_or_fd, start, end)
Writes all elements of @var{ura} as binary objects to
@var{port-or-fdes}.

The optional arguments @var{start}
and @var{end} allow
a specified region of a vector (or linearized array) to be written.

The number of objects actually written is returned.
@var{port-or-fdes} may be
omitted, in which case it defaults to the value returned by
@code{(current-output-port)}.
@end deffn

bit-count
@deffn {Scheme Procedure} bit-count b bitvector
@deffnx {C Function} scm_bit_count (b, bitvector)
Return the number of occurrences of the boolean @var{b} in
@var{bitvector}.
@end deffn

bit-position
@deffn {Scheme Procedure} bit-position item v k
@deffnx {C Function} scm_bit_position (item, v, k)
Return the minimum index of an occurrence of @var{bool} in
@var{bv} which is at least @var{k}.  If no @var{bool} occurs
within the specified range @code{#f} is returned.
@end deffn

bit-set*!
@deffn {Scheme Procedure} bit-set*! v kv obj
@deffnx {C Function} scm_bit_set_star_x (v, kv, obj)
If uve is a bit-vector @var{bv} and uve must be of the same
length.  If @var{bool} is @code{#t}, uve is OR'ed into
@var{bv}; If @var{bool} is @code{#f}, the inversion of uve is
AND'ed into @var{bv}.

If uve is a unsigned long integer vector all the elements of uve
must be between 0 and the @code{length} of @var{bv}.  The bits
of @var{bv} corresponding to the indexes in uve are set to
@var{bool}.  The return value is unspecified.
@end deffn

bit-count*
@deffn {Scheme Procedure} bit-count* v kv obj
@deffnx {C Function} scm_bit_count_star (v, kv, obj)
Return
@lisp
(bit-count (bit-set*! (if bool bv (bit-invert! bv)) uve #t) #t).
@end lisp
@var{bv} is not modified.
@end deffn

bit-invert!
@deffn {Scheme Procedure} bit-invert! v
@deffnx {C Function} scm_bit_invert_x (v)
Modify @var{bv} by replacing each element with its negation.
@end deffn

array->list
@deffn {Scheme Procedure} array->list v
@deffnx {C Function} scm_array_to_list (v)
Return a list consisting of all the elements, in order, of
@var{array}.
@end deffn

list->uniform-array
@deffn {Scheme Procedure} list->uniform-array ndim prot lst
@deffnx {Scheme Procedure} list->uniform-vector prot lst
@deffnx {C Function} scm_list_to_uniform_array (ndim, prot, lst)
Return a uniform array of the type indicated by prototype
@var{prot} with elements the same as those of @var{lst}.
Elements must be of the appropriate type, no coercions are
done.
@end deffn

array-prototype
@deffn {Scheme Procedure} array-prototype ra
@deffnx {C Function} scm_array_prototype (ra)
Return an object that would produce an array of the same type
as @var{array}, if used as the @var{prototype} for
@code{make-uniform-array}.
@end deffn

chown
@deffn {Scheme Procedure} chown object owner group
@deffnx {C Function} scm_chown (object, owner, group)
Change the ownership and group of the file referred to by @var{object} to
the integer values @var{owner} and @var{group}.  @var{object} can be
a string containing a file name or, if the platform
supports fchown, a port or integer file descriptor
which is open on the file.  The return value
is unspecified.

If @var{object} is a symbolic link, either the
ownership of the link or the ownership of the referenced file will be
changed depending on the operating system (lchown is
unsupported at present).  If @var{owner} or @var{group} is specified
as @code{-1}, then that ID is not changed.
@end deffn

chmod
@deffn {Scheme Procedure} chmod object mode
@deffnx {C Function} scm_chmod (object, mode)
Changes the permissions of the file referred to by @var{obj}.
@var{obj} can be a string containing a file name or a port or integer file
descriptor which is open on a file (in which case @code{fchmod} is used
as the underlying system call).
@var{mode} specifies
the new permissions as a decimal number, e.g., @code{(chmod "foo" #o755)}.
The return value is unspecified.
@end deffn

umask
@deffn {Scheme Procedure} umask [mode]
@deffnx {C Function} scm_umask (mode)
If @var{mode} is omitted, returns a decimal number representing the current
file creation mask.  Otherwise the file creation mask is set to
@var{mode} and the previous value is returned.

E.g., @code{(umask #o022)} sets the mask to octal 22, decimal 18.
@end deffn

open-fdes
@deffn {Scheme Procedure} open-fdes path flags [mode]
@deffnx {C Function} scm_open_fdes (path, flags, mode)
Similar to @code{open} but return a file descriptor instead of
a port.
@end deffn

open
@deffn {Scheme Procedure} open path flags [mode]
@deffnx {C Function} scm_open (path, flags, mode)
Open the file named by @var{path} for reading and/or writing.
@var{flags} is an integer specifying how the file should be opened.
@var{mode} is an integer specifying the permission bits of the file, if
it needs to be created, before the umask is applied.  The default is 666
(Unix itself has no default).

@var{flags} can be constructed by combining variables using @code{logior}.
Basic flags are:

@defvar O_RDONLY
Open the file read-only.
@end defvar
@defvar O_WRONLY
Open the file write-only.
@end defvar
@defvar O_RDWR
Open the file read/write.
@end defvar
@defvar O_APPEND
Append to the file instead of truncating.
@end defvar
@defvar O_CREAT
Create the file if it does not already exist.
@end defvar

See the Unix documentation of the @code{open} system call
for additional flags.
@end deffn

close
@deffn {Scheme Procedure} close fd_or_port
@deffnx {C Function} scm_close (fd_or_port)
Similar to close-port (@pxref{Closing, close-port}),
but also works on file descriptors.  A side
effect of closing a file descriptor is that any ports using that file
descriptor are moved to a different file descriptor and have
their revealed counts set to zero.
@end deffn

close-fdes
@deffn {Scheme Procedure} close-fdes fd
@deffnx {C Function} scm_close_fdes (fd)
A simple wrapper for the @code{close} system call.
Close file descriptor @var{fd}, which must be an integer.
Unlike close (@pxref{Ports and File Descriptors, close}),
the file descriptor will be closed even if a port is using it.
The return value is unspecified.
@end deffn

stat
@deffn {Scheme Procedure} stat object
@deffnx {C Function} scm_stat (object)
Return an object containing various information about the file
determined by @var{obj}.  @var{obj} can be a string containing
a file name or a port or integer file descriptor which is open
on a file (in which case @code{fstat} is used as the underlying
system call).

The object returned by @code{stat} can be passed as a single
parameter to the following procedures, all of which return
integers:

@table @code
@item stat:dev
The device containing the file.
@item stat:ino
The file serial number, which distinguishes this file from all
other files on the same device.
@item stat:mode
The mode of the file.  This includes file type information and
the file permission bits.  See @code{stat:type} and
@code{stat:perms} below.
@item stat:nlink
The number of hard links to the file.
@item stat:uid
The user ID of the file's owner.
@item stat:gid
The group ID of the file.
@item stat:rdev
Device ID; this entry is defined only for character or block
special files.
@item stat:size
The size of a regular file in bytes.
@item stat:atime
The last access time for the file.
@item stat:mtime
The last modification time for the file.
@item stat:ctime
The last modification time for the attributes of the file.
@item stat:blksize
The optimal block size for reading or writing the file, in
bytes.
@item stat:blocks
The amount of disk space that the file occupies measured in
units of 512 byte blocks.
@end table

In addition, the following procedures return the information
from stat:mode in a more convenient form:

@table @code
@item stat:type
A symbol representing the type of file.  Possible values are
regular, directory, symlink, block-special, char-special, fifo,
socket and unknown
@item stat:perms
An integer representing the access permission bits.
@end table
@end deffn

link
@deffn {Scheme Procedure} link oldpath newpath
@deffnx {C Function} scm_link (oldpath, newpath)
Creates a new name @var{newpath} in the file system for the
file named by @var{oldpath}.  If @var{oldpath} is a symbolic
link, the link may or may not be followed depending on the
system.
@end deffn

rename-file
@deffn {Scheme Procedure} rename-file oldname newname
@deffnx {C Function} scm_rename (oldname, newname)
Renames the file specified by @var{oldname} to @var{newname}.
The return value is unspecified.
@end deffn

delete-file
@deffn {Scheme Procedure} delete-file str
@deffnx {C Function} scm_delete_file (str)
Deletes (or "unlinks") the file specified by @var{path}.
@end deffn

mkdir
@deffn {Scheme Procedure} mkdir path [mode]
@deffnx {C Function} scm_mkdir (path, mode)
Create a new directory named by @var{path}.  If @var{mode} is omitted
then the permissions of the directory file are set using the current
umask.  Otherwise they are set to the decimal value specified with
@var{mode}.  The return value is unspecified.
@end deffn

rmdir
@deffn {Scheme Procedure} rmdir path
@deffnx {C Function} scm_rmdir (path)
Remove the existing directory named by @var{path}.  The directory must
be empty for this to succeed.  The return value is unspecified.
@end deffn

directory-stream?
@deffn {Scheme Procedure} directory-stream? obj
@deffnx {C Function} scm_directory_stream_p (obj)
Return a boolean indicating whether @var{object} is a directory
stream as returned by @code{opendir}.
@end deffn

opendir
@deffn {Scheme Procedure} opendir dirname
@deffnx {C Function} scm_opendir (dirname)
Open the directory specified by @var{path} and return a directory
stream.
@end deffn

readdir
@deffn {Scheme Procedure} readdir port
@deffnx {C Function} scm_readdir (port)
Return (as a string) the next directory entry from the directory stream
@var{stream}.  If there is no remaining entry to be read then the
end of file object is returned.
@end deffn

rewinddir
@deffn {Scheme Procedure} rewinddir port
@deffnx {C Function} scm_rewinddir (port)
Reset the directory port @var{stream} so that the next call to
@code{readdir} will return the first directory entry.
@end deffn

closedir
@deffn {Scheme Procedure} closedir port
@deffnx {C Function} scm_closedir (port)
Close the directory stream @var{stream}.
The return value is unspecified.
@end deffn

chdir
@deffn {Scheme Procedure} chdir str
@deffnx {C Function} scm_chdir (str)
Change the current working directory to @var{path}.
The return value is unspecified.
@end deffn

getcwd
@deffn {Scheme Procedure} getcwd
@deffnx {C Function} scm_getcwd ()
Return the name of the current working directory.
@end deffn

select
@deffn {Scheme Procedure} select reads writes excepts [secs [usecs]]
@deffnx {C Function} scm_select (reads, writes, excepts, secs, usecs)
This procedure has a variety of uses: waiting for the ability
to provide input, accept output, or the existence of
exceptional conditions on a collection of ports or file
descriptors, or waiting for a timeout to occur.
It also returns if interrupted by a signal.

@var{reads}, @var{writes} and @var{excepts} can be lists or
vectors, with each member a port or a file descriptor.
The value returned is a list of three corresponding
lists or vectors containing only the members which meet the
specified requirement.  The ability of port buffers to
provide input or accept output is taken into account.
Ordering of the input lists or vectors is not preserved.

The optional arguments @var{secs} and @var{usecs} specify the
timeout.  Either @var{secs} can be specified alone, as
either an integer or a real number, or both @var{secs} and
@var{usecs} can be specified as integers, in which case
@var{usecs} is an additional timeout expressed in
microseconds.  If @var{secs} is omitted or is @code{#f} then
select will wait for as long as it takes for one of the other
conditions to be satisfied.

The scsh version of @code{select} differs as follows:
Only vectors are accepted for the first three arguments.
The @var{usecs} argument is not supported.
Multiple values are returned instead of a list.
Duplicates in the input vectors appear only once in output.
An additional @code{select!} interface is provided.
@end deffn

fcntl
@deffn {Scheme Procedure} fcntl object cmd [value]
@deffnx {C Function} scm_fcntl (object, cmd, value)
Apply @var{command} to the specified file descriptor or the underlying
file descriptor of the specified port.  @var{value} is an optional
integer argument.

Values for @var{command} are:

@table @code
@item F_DUPFD
Duplicate a file descriptor
@item F_GETFD
Get flags associated with the file descriptor.
@item F_SETFD
Set flags associated with the file descriptor to @var{value}.
@item F_GETFL
Get flags associated with the open file.
@item F_SETFL
Set flags associated with the open file to @var{value}
@item F_GETOWN
Get the process ID of a socket's owner, for @code{SIGIO} signals.
@item F_SETOWN
Set the process that owns a socket to @var{value}, for @code{SIGIO} signals.
@item FD_CLOEXEC
The value used to indicate the "close on exec" flag with @code{F_GETFL} or
@code{F_SETFL}.
@end table
@end deffn

fsync
@deffn {Scheme Procedure} fsync object
@deffnx {C Function} scm_fsync (object)
Copies any unwritten data for the specified output file descriptor to disk.
If @var{port/fd} is a port, its buffer is flushed before the underlying
file descriptor is fsync'd.
The return value is unspecified.
@end deffn

symlink
@deffn {Scheme Procedure} symlink oldpath newpath
@deffnx {C Function} scm_symlink (oldpath, newpath)
Create a symbolic link named @var{path-to} with the value (i.e., pointing to)
@var{path-from}.  The return value is unspecified.
@end deffn

readlink
@deffn {Scheme Procedure} readlink path
@deffnx {C Function} scm_readlink (path)
Return the value of the symbolic link named by @var{path} (a
string), i.e., the file that the link points to.
@end deffn

lstat
@deffn {Scheme Procedure} lstat str
@deffnx {C Function} scm_lstat (str)
Similar to @code{stat}, but does not follow symbolic links, i.e.,
it will return information about a symbolic link itself, not the
file it points to.  @var{path} must be a string.
@end deffn

copy-file
@deffn {Scheme Procedure} copy-file oldfile newfile
@deffnx {C Function} scm_copy_file (oldfile, newfile)
Copy the file specified by @var{path-from} to @var{path-to}.
The return value is unspecified.
@end deffn

dirname
@deffn {Scheme Procedure} dirname filename
@deffnx {C Function} scm_dirname (filename)
Return the directory name component of the file name
@var{filename}. If @var{filename} does not contain a directory
component, @code{.} is returned.
@end deffn

basename
@deffn {Scheme Procedure} basename filename [suffix]
@deffnx {C Function} scm_basename (filename, suffix)
Return the base name of the file name @var{filename}. The
base name is the file name without any directory components.
If @var{suffix} is provided, and is equal to the end of
@var{basename}, it is removed also.
@end deffn

pipe
@deffn {Scheme Procedure} pipe
@deffnx {C Function} scm_pipe ()
Return a newly created pipe: a pair of ports which are linked
together on the local machine.  The @emph{car} is the input
port and the @emph{cdr} is the output port.  Data written (and
flushed) to the output port can be read from the input port.
Pipes are commonly used for communication with a newly forked
child process.  The need to flush the output port can be
avoided by making it unbuffered using @code{setvbuf}.

Writes occur atomically provided the size of the data in bytes
is not greater than the value of @code{PIPE_BUF}.  Note that
the output port is likely to block if too much data (typically
equal to @code{PIPE_BUF}) has been written but not yet read
from the input port.
@end deffn

getgroups
@deffn {Scheme Procedure} getgroups
@deffnx {C Function} scm_getgroups ()
Return a vector of integers representing the current
supplementary group IDs.
@end deffn

getpw
@deffn {Scheme Procedure} getpw [user]
@deffnx {C Function} scm_getpwuid (user)
Look up an entry in the user database.  @var{obj} can be an integer,
a string, or omitted, giving the behaviour of getpwuid, getpwnam
or getpwent respectively.
@end deffn

setpw
@deffn {Scheme Procedure} setpw [arg]
@deffnx {C Function} scm_setpwent (arg)
If called with a true argument, initialize or reset the password data
stream.  Otherwise, close the stream.  The @code{setpwent} and
@code{endpwent} procedures are implemented on top of this.
@end deffn

getgr
@deffn {Scheme Procedure} getgr [name]
@deffnx {C Function} scm_getgrgid (name)
Look up an entry in the group database.  @var{obj} can be an integer,
a string, or omitted, giving the behaviour of getgrgid, getgrnam
or getgrent respectively.
@end deffn

setgr
@deffn {Scheme Procedure} setgr [arg]
@deffnx {C Function} scm_setgrent (arg)
If called with a true argument, initialize or reset the group data
stream.  Otherwise, close the stream.  The @code{setgrent} and
@code{endgrent} procedures are implemented on top of this.
@end deffn

kill
@deffn {Scheme Procedure} kill pid sig
@deffnx {C Function} scm_kill (pid, sig)
Sends a signal to the specified process or group of processes.

@var{pid} specifies the processes to which the signal is sent:

@table @r
@item @var{pid} greater than 0
The process whose identifier is @var{pid}.
@item @var{pid} equal to 0
All processes in the current process group.
@item @var{pid} less than -1
The process group whose identifier is -@var{pid}
@item @var{pid} equal to -1
If the process is privileged, all processes except for some special
system processes.  Otherwise, all processes with the current effective
user ID.
@end table

@var{sig} should be specified using a variable corresponding to
the Unix symbolic name, e.g.,

@defvar SIGHUP
Hang-up signal.
@end defvar

@defvar SIGINT
Interrupt signal.
@end defvar
@end deffn

waitpid
@deffn {Scheme Procedure} waitpid pid [options]
@deffnx {C Function} scm_waitpid (pid, options)
This procedure collects status information from a child process which
has terminated or (optionally) stopped.  Normally it will
suspend the calling process until this can be done.  If more than one
child process is eligible then one will be chosen by the operating system.

The value of @var{pid} determines the behaviour:

@table @r
@item @var{pid} greater than 0
Request status information from the specified child process.
@item @var{pid} equal to -1 or WAIT_ANY
Request status information for any child process.
@item @var{pid} equal to 0 or WAIT_MYPGRP
Request status information for any child process in the current process
group.
@item @var{pid} less than -1
Request status information for any child process whose process group ID
is -@var{PID}.
@end table

The @var{options} argument, if supplied, should be the bitwise OR of the
values of zero or more of the following variables:

@defvar WNOHANG
Return immediately even if there are no child processes to be collected.
@end defvar

@defvar WUNTRACED
Report status information for stopped processes as well as terminated
processes.
@end defvar

The return value is a pair containing:

@enumerate
@item
The process ID of the child process, or 0 if @code{WNOHANG} was
specified and no process was collected.
@item
The integer status value.
@end enumerate
@end deffn

status:exit-val
@deffn {Scheme Procedure} status:exit-val status
@deffnx {C Function} scm_status_exit_val (status)
Return the exit status value, as would be set if a process
ended normally through a call to @code{exit} or @code{_exit},
if any, otherwise @code{#f}.
@end deffn

status:term-sig
@deffn {Scheme Procedure} status:term-sig status
@deffnx {C Function} scm_status_term_sig (status)
Return the signal number which terminated the process, if any,
otherwise @code{#f}.
@end deffn

status:stop-sig
@deffn {Scheme Procedure} status:stop-sig status
@deffnx {C Function} scm_status_stop_sig (status)
Return the signal number which stopped the process, if any,
otherwise @code{#f}.
@end deffn

getppid
@deffn {Scheme Procedure} getppid
@deffnx {C Function} scm_getppid ()
Return an integer representing the process ID of the parent
process.
@end deffn

getuid
@deffn {Scheme Procedure} getuid
@deffnx {C Function} scm_getuid ()
Return an integer representing the current real user ID.
@end deffn

getgid
@deffn {Scheme Procedure} getgid
@deffnx {C Function} scm_getgid ()
Return an integer representing the current real group ID.
@end deffn

geteuid
@deffn {Scheme Procedure} geteuid
@deffnx {C Function} scm_geteuid ()
Return an integer representing the current effective user ID.
If the system does not support effective IDs, then the real ID
is returned.  @code{(provided? 'EIDs)} reports whether the
system supports effective IDs.
@end deffn

getegid
@deffn {Scheme Procedure} getegid
@deffnx {C Function} scm_getegid ()
Return an integer representing the current effective group ID.
If the system does not support effective IDs, then the real ID
is returned.  @code{(provided? 'EIDs)} reports whether the
system supports effective IDs.
@end deffn

setuid
@deffn {Scheme Procedure} setuid id
@deffnx {C Function} scm_setuid (id)
Sets both the real and effective user IDs to the integer @var{id}, provided
the process has appropriate privileges.
The return value is unspecified.
@end deffn

setgid
@deffn {Scheme Procedure} setgid id
@deffnx {C Function} scm_setgid (id)
Sets both the real and effective group IDs to the integer @var{id}, provided
the process has appropriate privileges.
The return value is unspecified.
@end deffn

seteuid
@deffn {Scheme Procedure} seteuid id
@deffnx {C Function} scm_seteuid (id)
Sets the effective user ID to the integer @var{id}, provided the process
has appropriate privileges.  If effective IDs are not supported, the
real ID is set instead -- @code{(provided? 'EIDs)} reports whether the
system supports effective IDs.
The return value is unspecified.
@end deffn

setegid
@deffn {Scheme Procedure} setegid id
@deffnx {C Function} scm_setegid (id)
Sets the effective group ID to the integer @var{id}, provided the process
has appropriate privileges.  If effective IDs are not supported, the
real ID is set instead -- @code{(provided? 'EIDs)} reports whether the
system supports effective IDs.
The return value is unspecified.
@end deffn

getpgrp
@deffn {Scheme Procedure} getpgrp
@deffnx {C Function} scm_getpgrp ()
Return an integer representing the current process group ID.
This is the POSIX definition, not BSD.
@end deffn

setpgid
@deffn {Scheme Procedure} setpgid pid pgid
@deffnx {C Function} scm_setpgid (pid, pgid)
Move the process @var{pid} into the process group @var{pgid}.  @var{pid} or
@var{pgid} must be integers: they can be zero to indicate the ID of the
current process.
Fails on systems that do not support job control.
The return value is unspecified.
@end deffn

setsid
@deffn {Scheme Procedure} setsid
@deffnx {C Function} scm_setsid ()
Creates a new session.  The current process becomes the session leader
and is put in a new process group.  The process will be detached
from its controlling terminal if it has one.
The return value is an integer representing the new process group ID.
@end deffn

ttyname
@deffn {Scheme Procedure} ttyname port
@deffnx {C Function} scm_ttyname (port)
Return a string with the name of the serial terminal device
underlying @var{port}.
@end deffn

ctermid
@deffn {Scheme Procedure} ctermid
@deffnx {C Function} scm_ctermid ()
Return a string containing the file name of the controlling
terminal for the current process.
@end deffn

tcgetpgrp
@deffn {Scheme Procedure} tcgetpgrp port
@deffnx {C Function} scm_tcgetpgrp (port)
Return the process group ID of the foreground process group
associated with the terminal open on the file descriptor
underlying @var{port}.

If there is no foreground process group, the return value is a
number greater than 1 that does not match the process group ID
of any existing process group.  This can happen if all of the
processes in the job that was formerly the foreground job have
terminated, and no other job has yet been moved into the
foreground.
@end deffn

tcsetpgrp
@deffn {Scheme Procedure} tcsetpgrp port pgid
@deffnx {C Function} scm_tcsetpgrp (port, pgid)
Set the foreground process group ID for the terminal used by the file
descriptor underlying @var{port} to the integer @var{pgid}.
The calling process
must be a member of the same session as @var{pgid} and must have the same
controlling terminal.  The return value is unspecified.
@end deffn

execl
@deffn {Scheme Procedure} execl filename . args
@deffnx {C Function} scm_execl (filename, args)
Executes the file named by @var{path} as a new process image.
The remaining arguments are supplied to the process; from a C program
they are accessible as the @code{argv} argument to @code{main}.
Conventionally the first @var{arg} is the same as @var{path}.
All arguments must be strings.

If @var{arg} is missing, @var{path} is executed with a null
argument list, which may have system-dependent side-effects.

This procedure is currently implemented using the @code{execv} system
call, but we call it @code{execl} because of its Scheme calling interface.
@end deffn

execlp
@deffn {Scheme Procedure} execlp filename . args
@deffnx {C Function} scm_execlp (filename, args)
Similar to @code{execl}, however if
@var{filename} does not contain a slash
then the file to execute will be located by searching the
directories listed in the @code{PATH} environment variable.

This procedure is currently implemented using the @code{execvp} system
call, but we call it @code{execlp} because of its Scheme calling interface.
@end deffn

execle
@deffn {Scheme Procedure} execle filename env . args
@deffnx {C Function} scm_execle (filename, env, args)
Similar to @code{execl}, but the environment of the new process is
specified by @var{env}, which must be a list of strings as returned by the
@code{environ} procedure.

This procedure is currently implemented using the @code{execve} system
call, but we call it @code{execle} because of its Scheme calling interface.
@end deffn

primitive-fork
@deffn {Scheme Procedure} primitive-fork
@deffnx {C Function} scm_fork ()
Creates a new "child" process by duplicating the current "parent" process.
In the child the return value is 0.  In the parent the return value is
the integer process ID of the child.

This procedure has been renamed from @code{fork} to avoid a naming conflict
with the scsh fork.
@end deffn

uname
@deffn {Scheme Procedure} uname
@deffnx {C Function} scm_uname ()
Return an object with some information about the computer
system the program is running on.
@end deffn

environ
@deffn {Scheme Procedure} environ [env]
@deffnx {C Function} scm_environ (env)
If @var{env} is omitted, return the current environment (in the
Unix sense) as a list of strings.  Otherwise set the current
environment, which is also the default environment for child
processes, to the supplied list of strings.  Each member of
@var{env} should be of the form @code{NAME=VALUE} and values of
@code{NAME} should not be duplicated.  If @var{env} is supplied
then the return value is unspecified.
@end deffn

tmpnam
@deffn {Scheme Procedure} tmpnam
@deffnx {C Function} scm_tmpnam ()
Return a name in the file system that does not match any
existing file.  However there is no guarantee that another
process will not create the file after @code{tmpnam} is called.
Care should be taken if opening the file, e.g., use the
@code{O_EXCL} open flag or use @code{mkstemp!} instead.
@end deffn

mkstemp!
@deffn {Scheme Procedure} mkstemp! tmpl
@deffnx {C Function} scm_mkstemp (tmpl)
Create a new unique file in the file system and returns a new
buffered port open for reading and writing to the file.
@var{tmpl} is a string specifying where the file should be
created: it must end with @code{XXXXXX} and will be changed in
place to return the name of the temporary file.
@end deffn

utime
@deffn {Scheme Procedure} utime pathname [actime [modtime]]
@deffnx {C Function} scm_utime (pathname, actime, modtime)
@code{utime} sets the access and modification times for the
file named by @var{path}.  If @var{actime} or @var{modtime} is
not supplied, then the current time is used.  @var{actime} and
@var{modtime} must be integer time values as returned by the
@code{current-time} procedure.
@lisp
(utime "foo" (- (current-time) 3600))
@end lisp
will set the access time to one hour in the past and the
modification time to the current time.
@end deffn

access?
@deffn {Scheme Procedure} access? path how
@deffnx {C Function} scm_access (path, how)
Return @code{#t} if @var{path} corresponds to an existing file
and the current process has the type of access specified by
@var{how}, otherwise @code{#f}.  @var{how} should be specified
using the values of the variables listed below.  Multiple
values can be combined using a bitwise or, in which case
@code{#t} will only be returned if all accesses are granted.

Permissions are checked using the real id of the current
process, not the effective id, although it's the effective id
which determines whether the access would actually be granted.

@defvar R_OK
test for read permission.
@end defvar
@defvar W_OK
test for write permission.
@end defvar
@defvar X_OK
test for execute permission.
@end defvar
@defvar F_OK
test for existence of the file.
@end defvar
@end deffn

getpid
@deffn {Scheme Procedure} getpid
@deffnx {C Function} scm_getpid ()
Return an integer representing the current process ID.
@end deffn

putenv
@deffn {Scheme Procedure} putenv str
@deffnx {C Function} scm_putenv (str)
Modifies the environment of the current process, which is
also the default environment inherited by child processes.

If @var{string} is of the form @code{NAME=VALUE} then it will be written
directly into the environment, replacing any existing environment string
with
name matching @code{NAME}.  If @var{string} does not contain an equal
sign, then any existing string with name matching @var{string} will
be removed.

The return value is unspecified.
@end deffn

setlocale
@deffn {Scheme Procedure} setlocale category [locale]
@deffnx {C Function} scm_setlocale (category, locale)
If @var{locale} is omitted, return the current value of the
specified locale category as a system-dependent string.
@var{category} should be specified using the values
@code{LC_COLLATE}, @code{LC_ALL} etc.

Otherwise the specified locale category is set to the string
@var{locale} and the new value is returned as a
system-dependent string.  If @var{locale} is an empty string,
the locale will be set using environment variables.
@end deffn

mknod
@deffn {Scheme Procedure} mknod path type perms dev
@deffnx {C Function} scm_mknod (path, type, perms, dev)
Creates a new special file, such as a file corresponding to a device.
@var{path} specifies the name of the file.  @var{type} should
be one of the following symbols:
regular, directory, symlink, block-special, char-special,
fifo, or socket.  @var{perms} (an integer) specifies the file permissions.
@var{dev} (an integer) specifies which device the special file refers
to.  Its exact interpretation depends on the kind of special file
being created.

E.g.,
@lisp
(mknod "/dev/fd0" 'block-special #o660 (+ (* 2 256) 2))
@end lisp

The return value is unspecified.
@end deffn

nice
@deffn {Scheme Procedure} nice incr
@deffnx {C Function} scm_nice (incr)
Increment the priority of the current process by @var{incr}.  A higher
priority value means that the process runs less often.
The return value is unspecified.
@end deffn

sync
@deffn {Scheme Procedure} sync
@deffnx {C Function} scm_sync ()
Flush the operating system disk buffers.
The return value is unspecified.
@end deffn

crypt
@deffn {Scheme Procedure} crypt key salt
@deffnx {C Function} scm_crypt (key, salt)
Encrypt @var{key} using @var{salt} as the salt value to the
crypt(3) library call.
@end deffn

chroot
@deffn {Scheme Procedure} chroot path
@deffnx {C Function} scm_chroot (path)
Change the root directory to that specified in @var{path}.
This directory will be used for path names beginning with
@file{/}.  The root directory is inherited by all children
of the current process.  Only the superuser may change the
root directory.
@end deffn

getlogin
@deffn {Scheme Procedure} getlogin
@deffnx {C Function} scm_getlogin ()
Return a string containing the name of the user logged in on
the controlling terminal of the process, or @code{#f} if this
information cannot be obtained.
@end deffn

cuserid
@deffn {Scheme Procedure} cuserid
@deffnx {C Function} scm_cuserid ()
Return a string containing a user name associated with the
effective user id of the process.  Return @code{#f} if this
information cannot be obtained.
@end deffn

getpriority
@deffn {Scheme Procedure} getpriority which who
@deffnx {C Function} scm_getpriority (which, who)
Return the scheduling priority of the process, process group
or user, as indicated by @var{which} and @var{who}. @var{which}
is one of the variables @code{PRIO_PROCESS}, @code{PRIO_PGRP}
or @code{PRIO_USER}, and @var{who} is interpreted relative to
@var{which} (a process identifier for @code{PRIO_PROCESS},
process group identifier for @code{PRIO_PGRP}, and a user
identifier for @code{PRIO_USER}.  A zero value of @var{who}
denotes the current process, process group, or user.  Return
the highest priority (lowest numerical value) of any of the
specified processes.
@end deffn

setpriority
@deffn {Scheme Procedure} setpriority which who prio
@deffnx {C Function} scm_setpriority (which, who, prio)
Set the scheduling priority of the process, process group
or user, as indicated by @var{which} and @var{who}. @var{which}
is one of the variables @code{PRIO_PROCESS}, @code{PRIO_PGRP}
or @code{PRIO_USER}, and @var{who} is interpreted relative to
@var{which} (a process identifier for @code{PRIO_PROCESS},
process group identifier for @code{PRIO_PGRP}, and a user
identifier for @code{PRIO_USER}.  A zero value of @var{who}
denotes the current process, process group, or user.
@var{prio} is a value in the range -20 and 20, the default
priority is 0; lower priorities cause more favorable
scheduling.  Sets the priority of all of the specified
processes.  Only the super-user may lower priorities.
The return value is not specified.
@end deffn

getpass
@deffn {Scheme Procedure} getpass prompt
@deffnx {C Function} scm_getpass (prompt)
Display @var{prompt} to the standard error output and read
a password from @file{/dev/tty}.  If this file is not
accessible, it reads from standard input.  The password may be
up to 127 characters in length.  Additional characters and the
terminating newline character are discarded.  While reading
the password, echoing and the generation of signals by special
characters is disabled.
@end deffn

flock
@deffn {Scheme Procedure} flock file operation
@deffnx {C Function} scm_flock (file, operation)
Apply or remove an advisory lock on an open file.
@var{operation} specifies the action to be done:
@table @code
@item LOCK_SH
Shared lock.  More than one process may hold a shared lock
for a given file at a given time.
@item LOCK_EX
Exclusive lock.  Only one process may hold an exclusive lock
for a given file at a given time.
@item LOCK_UN
Unlock the file.
@item LOCK_NB
Don't block when locking.  May be specified by bitwise OR'ing
it to one of the other operations.
@end table
The return value is not specified. @var{file} may be an open
file descriptor or an open file descriptor port.
@end deffn

sethostname
@deffn {Scheme Procedure} sethostname name
@deffnx {C Function} scm_sethostname (name)
Set the host name of the current processor to @var{name}. May
only be used by the superuser.  The return value is not
specified.
@end deffn

gethostname
@deffn {Scheme Procedure} gethostname
@deffnx {C Function} scm_gethostname ()
Return the host name of the current processor.
@end deffn

gethost
@deffn {Scheme Procedure} gethost [host]
@deffnx {Scheme Procedure} gethostbyname hostname
@deffnx {Scheme Procedure} gethostbyaddr address
@deffnx {C Function} scm_gethost (host)
Look up a host by name or address, returning a host object.  The
@code{gethost} procedure will accept either a string name or an integer
address; if given no arguments, it behaves like @code{gethostent} (see
below).  If a name or address is supplied but the address can not be
found, an error will be thrown to one of the keys:
@code{host-not-found}, @code{try-again}, @code{no-recovery} or
@code{no-data}, corresponding to the equivalent @code{h_error} values.
Unusual conditions may result in errors thrown to the
@code{system-error} or @code{misc_error} keys.
@end deffn

getnet
@deffn {Scheme Procedure} getnet [net]
@deffnx {Scheme Procedure} getnetbyname net-name
@deffnx {Scheme Procedure} getnetbyaddr net-number
@deffnx {C Function} scm_getnet (net)
Look up a network by name or net number in the network database.  The
@var{net-name} argument must be a string, and the @var{net-number}
argument must be an integer.  @code{getnet} will accept either type of
argument, behaving like @code{getnetent} (see below) if no arguments are
given.
@end deffn

getproto
@deffn {Scheme Procedure} getproto [protocol]
@deffnx {Scheme Procedure} getprotobyname name
@deffnx {Scheme Procedure} getprotobynumber number
@deffnx {C Function} scm_getproto (protocol)
Look up a network protocol by name or by number.  @code{getprotobyname}
takes a string argument, and @code{getprotobynumber} takes an integer
argument.  @code{getproto} will accept either type, behaving like
@code{getprotoent} (see below) if no arguments are supplied.
@end deffn

getserv
@deffn {Scheme Procedure} getserv [name [protocol]]
@deffnx {Scheme Procedure} getservbyname name protocol
@deffnx {Scheme Procedure} getservbyport port protocol
@deffnx {C Function} scm_getserv (name, protocol)
Look up a network service by name or by service number, and return a
network service object.  The @var{protocol} argument specifies the name
of the desired protocol; if the protocol found in the network service
database does not match this name, a system error is signalled.

The @code{getserv} procedure will take either a service name or number
as its first argument; if given no arguments, it behaves like
@code{getservent} (see below).
@end deffn

sethost
@deffn {Scheme Procedure} sethost [stayopen]
@deffnx {C Function} scm_sethost (stayopen)
If @var{stayopen} is omitted, this is equivalent to @code{endhostent}.
Otherwise it is equivalent to @code{sethostent stayopen}.
@end deffn

setnet
@deffn {Scheme Procedure} setnet [stayopen]
@deffnx {C Function} scm_setnet (stayopen)
If @var{stayopen} is omitted, this is equivalent to @code{endnetent}.
Otherwise it is equivalent to @code{setnetent stayopen}.
@end deffn

setproto
@deffn {Scheme Procedure} setproto [stayopen]
@deffnx {C Function} scm_setproto (stayopen)
If @var{stayopen} is omitted, this is equivalent to @code{endprotoent}.
Otherwise it is equivalent to @code{setprotoent stayopen}.
@end deffn

setserv
@deffn {Scheme Procedure} setserv [stayopen]
@deffnx {C Function} scm_setserv (stayopen)
If @var{stayopen} is omitted, this is equivalent to @code{endservent}.
Otherwise it is equivalent to @code{setservent stayopen}.
@end deffn

htons
@deffn {Scheme Procedure} htons value
@deffnx {C Function} scm_htons (value)
Convert a 16 bit quantity from host to network byte ordering.
@var{value} is packed into 2 bytes, which are then converted
and returned as a new integer.
@end deffn

ntohs
@deffn {Scheme Procedure} ntohs value
@deffnx {C Function} scm_ntohs (value)
Convert a 16 bit quantity from network to host byte ordering.
@var{value} is packed into 2 bytes, which are then converted
and returned as a new integer.
@end deffn

htonl
@deffn {Scheme Procedure} htonl value
@deffnx {C Function} scm_htonl (value)
Convert a 32 bit quantity from host to network byte ordering.
@var{value} is packed into 4 bytes, which are then converted
and returned as a new integer.
@end deffn

ntohl
@deffn {Scheme Procedure} ntohl value
@deffnx {C Function} scm_ntohl (value)
Convert a 32 bit quantity from network to host byte ordering.
@var{value} is packed into 4 bytes, which are then converted
and returned as a new integer.
@end deffn

inet-aton
@deffn {Scheme Procedure} inet-aton address
@deffnx {C Function} scm_inet_aton (address)
Convert an IPv4 Internet address from printable string
(dotted decimal notation) to an integer.  E.g.,

@lisp
(inet-aton "127.0.0.1") @result{} 2130706433
@end lisp
@end deffn

inet-ntoa
@deffn {Scheme Procedure} inet-ntoa inetid
@deffnx {C Function} scm_inet_ntoa (inetid)
Convert an IPv4 Internet address to a printable
(dotted decimal notation) string.  E.g.,

@lisp
(inet-ntoa 2130706433) @result{} "127.0.0.1"
@end lisp
@end deffn

inet-netof
@deffn {Scheme Procedure} inet-netof address
@deffnx {C Function} scm_inet_netof (address)
Return the network number part of the given IPv4
Internet address.  E.g.,

@lisp
(inet-netof 2130706433) @result{} 127
@end lisp
@end deffn

inet-lnaof
@deffn {Scheme Procedure} inet-lnaof address
@deffnx {C Function} scm_lnaof (address)
Return the local-address-with-network part of the given
IPv4 Internet address, using the obsolete class A/B/C system.
E.g.,

@lisp
(inet-lnaof 2130706433) @result{} 1
@end lisp
@end deffn

inet-makeaddr
@deffn {Scheme Procedure} inet-makeaddr net lna
@deffnx {C Function} scm_inet_makeaddr (net, lna)
Make an IPv4 Internet address by combining the network number
@var{net} with the local-address-within-network number
@var{lna}.  E.g.,

@lisp
(inet-makeaddr 127 1) @result{} 2130706433
@end lisp
@end deffn

inet-pton
@deffn {Scheme Procedure} inet-pton family address
@deffnx {C Function} scm_inet_pton (family, address)
Convert a string containing a printable network address to
an integer address.  Note that unlike the C version of this
function,
the result is an integer with normal host byte ordering.
@var{family} can be @code{AF_INET} or @code{AF_INET6}.  E.g.,

@lisp
(inet-pton AF_INET "127.0.0.1") @result{} 2130706433
(inet-pton AF_INET6 "::1") @result{} 1
@end lisp
@end deffn

inet-ntop
@deffn {Scheme Procedure} inet-ntop family address
@deffnx {C Function} scm_inet_ntop (family, address)
Convert a network address into a printable string.
Note that unlike the C version of this function,
the input is an integer with normal host byte ordering.
@var{family} can be @code{AF_INET} or @code{AF_INET6}.  E.g.,

@lisp
(inet-ntop AF_INET 2130706433) @result{} "127.0.0.1"
(inet-ntop AF_INET6 (- (expt 2 128) 1)) @result{}
ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff
@end lisp
@end deffn

socket
@deffn {Scheme Procedure} socket family style proto
@deffnx {C Function} scm_socket (family, style, proto)
Return a new socket port of the type specified by @var{family},
@var{style} and @var{proto}.  All three parameters are
integers.  Supported values for @var{family} are
@code{AF_UNIX}, @code{AF_INET} and @code{AF_INET6}.
Typical values for @var{style} are @code{SOCK_STREAM},
@code{SOCK_DGRAM} and @code{SOCK_RAW}.

@var{proto} can be obtained from a protocol name using
@code{getprotobyname}.  A value of zero specifies the default
protocol, which is usually right.

A single socket port cannot by used for communication until it
has been connected to another socket.
@end deffn

socketpair
@deffn {Scheme Procedure} socketpair family style proto
@deffnx {C Function} scm_socketpair (family, style, proto)
Return a pair of connected (but unnamed) socket ports of the
type specified by @var{family}, @var{style} and @var{proto}.
Many systems support only socket pairs of the @code{AF_UNIX}
family.  Zero is likely to be the only meaningful value for
@var{proto}.
@end deffn

getsockopt
@deffn {Scheme Procedure} getsockopt sock level optname
@deffnx {C Function} scm_getsockopt (sock, level, optname)
Return the value of a particular socket option for the socket
port @var{sock}.  @var{level} is an integer code for type of
option being requested, e.g., @code{SOL_SOCKET} for
socket-level options.  @var{optname} is an integer code for the
option required and should be specified using one of the
symbols @code{SO_DEBUG}, @code{SO_REUSEADDR} etc.

The returned value is typically an integer but @code{SO_LINGER}
returns a pair of integers.
@end deffn

setsockopt
@deffn {Scheme Procedure} setsockopt sock level optname value
@deffnx {C Function} scm_setsockopt (sock, level, optname, value)
Set the value of a particular socket option for the socket
port @var{sock}.  @var{level} is an integer code for type of option
being set, e.g., @code{SOL_SOCKET} for socket-level options.
@var{optname} is an
integer code for the option to set and should be specified using one of
the symbols @code{SO_DEBUG}, @code{SO_REUSEADDR} etc.
@var{value} is the value to which the option should be set.  For
most options this must be an integer, but for @code{SO_LINGER} it must
be a pair.

The return value is unspecified.
@end deffn

shutdown
@deffn {Scheme Procedure} shutdown sock how
@deffnx {C Function} scm_shutdown (sock, how)
Sockets can be closed simply by using @code{close-port}. The
@code{shutdown} procedure allows reception or transmission on a
connection to be shut down individually, according to the parameter
@var{how}:

@table @asis
@item 0
Stop receiving data for this socket.  If further data arrives,  reject it.
@item 1
Stop trying to transmit data from this socket.  Discard any
data waiting to be sent.  Stop looking for acknowledgement of
data already sent; don't retransmit it if it is lost.
@item 2
Stop both reception and transmission.
@end table

The return value is unspecified.
@end deffn

connect
@deffn {Scheme Procedure} connect sock fam address . args
@deffnx {C Function} scm_connect (sock, fam, address, args)
Initiate a connection from a socket using a specified address
family to the address
specified by @var{address} and possibly @var{args}.
The format required for @var{address}
and @var{args} depends on the family of the socket.

For a socket of family @code{AF_UNIX},
only @var{address} is specified and must be a string with the
filename where the socket is to be created.

For a socket of family @code{AF_INET},
@var{address} must be an integer IPv4 host address and
@var{args} must be a single integer port number.

For a socket of family @code{AF_INET6},
@var{address} must be an integer IPv6 host address and
@var{args} may be up to three integers:
port [flowinfo] [scope_id],
where flowinfo and scope_id default to zero.

The return value is unspecified.
@end deffn

bind
@deffn {Scheme Procedure} bind sock fam address . args
@deffnx {C Function} scm_bind (sock, fam, address, args)
Assign an address to the socket port @var{sock}.
Generally this only needs to be done for server sockets,
so they know where to look for incoming connections.  A socket
without an address will be assigned one automatically when it
starts communicating.

The format of @var{address} and @var{args} depends
on the family of the socket.

For a socket of family @code{AF_UNIX}, only @var{address}
is specified and must be a string with the filename where
the socket is to be created.

For a socket of family @code{AF_INET}, @var{address}
must be an integer IPv4 address and @var{args}
must be a single integer port number.

The values of the following variables can also be used for
@var{address}:

@defvar INADDR_ANY
Allow connections from any address.
@end defvar

@defvar INADDR_LOOPBACK
The address of the local host using the loopback device.
@end defvar

@defvar INADDR_BROADCAST
The broadcast address on the local network.
@end defvar

@defvar INADDR_NONE
No address.
@end defvar

For a socket of family @code{AF_INET6}, @var{address}
must be an integer IPv6 address and @var{args}
may be up to three integers:
port [flowinfo] [scope_id],
where flowinfo and scope_id default to zero.

The return value is unspecified.
@end deffn

listen
@deffn {Scheme Procedure} listen sock backlog
@deffnx {C Function} scm_listen (sock, backlog)
Enable @var{sock} to accept connection
requests.  @var{backlog} is an integer specifying
the maximum length of the queue for pending connections.
If the queue fills, new clients will fail to connect until
the server calls @code{accept} to accept a connection from
the queue.

The return value is unspecified.
@end deffn

accept
@deffn {Scheme Procedure} accept sock
@deffnx {C Function} scm_accept (sock)
Accept a connection on a bound, listening socket.
If there
are no pending connections in the queue, wait until
one is available unless the non-blocking option has been
set on the socket.

The return value is a
pair in which the @emph{car} is a new socket port for the
connection and
the @emph{cdr} is an object with address information about the
client which initiated the connection.

@var{sock} does not become part of the
connection and will continue to accept new requests.
@end deffn

getsockname
@deffn {Scheme Procedure} getsockname sock
@deffnx {C Function} scm_getsockname (sock)
Return the address of @var{sock}, in the same form as the
object returned by @code{accept}.  On many systems the address
of a socket in the @code{AF_FILE} namespace cannot be read.
@end deffn

getpeername
@deffn {Scheme Procedure} getpeername sock
@deffnx {C Function} scm_getpeername (sock)
Return the address that @var{sock}
is connected to, in the same form as the object returned by
@code{accept}.  On many systems the address of a socket in the
@code{AF_FILE} namespace cannot be read.
@end deffn

recv!
@deffn {Scheme Procedure} recv! sock buf [flags]
@deffnx {C Function} scm_recv (sock, buf, flags)
Receive data from a socket port.
@var{sock} must already
be bound to the address from which data is to be received.
@var{buf} is a string into which
the data will be written.  The size of @var{buf} limits
the amount of
data which can be received: in the case of packet
protocols, if a packet larger than this limit is encountered
then some data
will be irrevocably lost.

The optional @var{flags} argument is a value or
bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

The value returned is the number of bytes read from the
socket.

Note that the data is read directly from the socket file
descriptor:
any unread buffered port data is ignored.
@end deffn

send
@deffn {Scheme Procedure} send sock message [flags]
@deffnx {C Function} scm_send (sock, message, flags)
Transmit the string @var{message} on a socket port @var{sock}.
@var{sock} must already be bound to a destination address.  The
value returned is the number of bytes transmitted --
it's possible for
this to be less than the length of @var{message}
if the socket is
set to be non-blocking.  The optional @var{flags} argument
is a value or
bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

Note that the data is written directly to the socket
file descriptor:
any unflushed buffered port data is ignored.
@end deffn

recvfrom!
@deffn {Scheme Procedure} recvfrom! sock str [flags [start [end]]]
@deffnx {C Function} scm_recvfrom (sock, str, flags, start, end)
Return data from the socket port @var{sock} and also
information about where the data was received from.
@var{sock} must already be bound to the address from which
data is to be received.  @code{str}, is a string into which the
data will be written.  The size of @var{str} limits the amount
of data which can be received: in the case of packet protocols,
if a packet larger than this limit is encountered then some
data will be irrevocably lost.

The optional @var{flags} argument is a value or bitwise OR of
@code{MSG_OOB}, @code{MSG_PEEK}, @code{MSG_DONTROUTE} etc.

The value returned is a pair: the @emph{car} is the number of
bytes read from the socket and the @emph{cdr} an address object
in the same form as returned by @code{accept}.  The address
will given as @code{#f} if not available, as is usually the
case for stream sockets.

The @var{start} and @var{end} arguments specify a substring of
@var{str} to which the data should be written.

Note that the data is read directly from the socket file
descriptor: any unread buffered port data is ignored.
@end deffn

sendto
@deffn {Scheme Procedure} sendto sock message fam address . args_and_flags
@deffnx {C Function} scm_sendto (sock, message, fam, address, args_and_flags)
Transmit the string @var{message} on the socket port
@var{sock}.  The
destination address is specified using the @var{fam},
@var{address} and
@var{args_and_flags} arguments, in a similar way to the
@code{connect} procedure.  @var{args_and_flags} contains
the usual connection arguments optionally followed by
a flags argument, which is a value or
bitwise OR of MSG_OOB, MSG_PEEK, MSG_DONTROUTE etc.

The value returned is the number of bytes transmitted --
it's possible for
this to be less than the length of @var{message} if the
socket is
set to be non-blocking.
Note that the data is written directly to the socket
file descriptor:
any unflushed buffered port data is ignored.
@end deffn

regexp?
@deffn {Scheme Procedure} regexp? obj
@deffnx {C Function} scm_regexp_p (obj)
Return @code{#t} if @var{obj} is a compiled regular expression,
or @code{#f} otherwise.
@end deffn

make-regexp
@deffn {Scheme Procedure} make-regexp pat . flags
@deffnx {C Function} scm_make_regexp (pat, flags)
Compile the regular expression described by @var{pat}, and
return the compiled regexp structure.  If @var{pat} does not
describe a legal regular expression, @code{make-regexp} throws
a @code{regular-expression-syntax} error.

The @var{flags} arguments change the behavior of the compiled
regular expression.  The following flags may be supplied:

@table @code
@item regexp/icase
Consider uppercase and lowercase letters to be the same when
matching.
@item regexp/newline
If a newline appears in the target string, then permit the
@samp{^} and @samp{$} operators to match immediately after or
immediately before the newline, respectively.  Also, the
@samp{.} and @samp{[^...]} operators will never match a newline
character.  The intent of this flag is to treat the target
string as a buffer containing many lines of text, and the
regular expression as a pattern that may match a single one of
those lines.
@item regexp/basic
Compile a basic (``obsolete'') regexp instead of the extended
(``modern'') regexps that are the default.  Basic regexps do
not consider @samp{|}, @samp{+} or @samp{?} to be special
characters, and require the @samp{@{...@}} and @samp{(...)}
metacharacters to be backslash-escaped (@pxref{Backslash
Escapes}).  There are several other differences between basic
and extended regular expressions, but these are the most
significant.
@item regexp/extended
Compile an extended regular expression rather than a basic
regexp.  This is the default behavior; this flag will not
usually be needed.  If a call to @code{make-regexp} includes
both @code{regexp/basic} and @code{regexp/extended} flags, the
one which comes last will override the earlier one.
@end table
@end deffn

regexp-exec
@deffn {Scheme Procedure} regexp-exec rx str [start [flags]]
@deffnx {C Function} scm_regexp_exec (rx, str, start, flags)
Match the compiled regular expression @var{rx} against
@code{str}.  If the optional integer @var{start} argument is
provided, begin matching from that position in the string.
Return a match structure describing the results of the match,
or @code{#f} if no match could be found.

The @var{flags} arguments change the matching behavior.
The following flags may be supplied:

@table @code
@item regexp/notbol
Operator @samp{^} always fails (unless @code{regexp/newline}
is used).  Use this when the beginning of the string should
not be considered the beginning of a line.
@item regexp/noteol
Operator @samp{$} always fails (unless @code{regexp/newline}
is used).  Use this when the end of the string should not be
considered the end of a line.
@end table
@end deffn

single-active-thread?
@deffn {Scheme Procedure} single-active-thread?
implemented by the C function "scm_single_thread_p"
@end deffn

yield
@deffn {Scheme Procedure} yield
implemented by the C function "scm_yield"
@end deffn

call-with-new-thread
@deffn {Scheme Procedure} call-with-new-thread
implemented by the C function "scm_call_with_new_thread"
@end deffn

current-thread
@deffn {Scheme Procedure} current-thread
implemented by the C function "scm_current_thread"
@end deffn

all-threads
@deffn {Scheme Procedure} all-threads
implemented by the C function "scm_all_threads"
@end deffn

join-thread
@deffn {Scheme Procedure} join-thread
implemented by the C function "scm_join_thread"
@end deffn

make-mutex
@deffn {Scheme Procedure} make-mutex
implemented by the C function "scm_make_mutex"
@end deffn

lock-mutex
@deffn {Scheme Procedure} lock-mutex
implemented by the C function "scm_lock_mutex"
@end deffn

unlock-mutex
@deffn {Scheme Procedure} unlock-mutex
implemented by the C function "scm_unlock_mutex"
@end deffn

make-condition-variable
@deffn {Scheme Procedure} make-condition-variable
implemented by the C function "scm_make_condition_variable"
@end deffn

wait-condition-variable
@deffn {Scheme Procedure} wait-condition-variable
implemented by the C function "scm_wait_condition_variable"
@end deffn

signal-condition-variable
@deffn {Scheme Procedure} signal-condition-variable
implemented by the C function "scm_signal_condition_variable"
@end deffn
